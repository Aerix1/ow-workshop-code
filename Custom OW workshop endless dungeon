variables
{
	global:
		0: roomPositionX
		1: roomPositionY
		2: floorNumber
		3: loopCounter1
		4: loopCounter2
		5: roomType
		6: temp
		7: roomTypesString
		8: roomTypesColor
		9: battleInProgress
		10: currentRoom
		11: enemySpawnPool
		12: gemstoneTypes
		13: rarityColors
		14: itemNames
		15: itemPositions
		16: itemSlots
		17: itemSubtypes
		18: itemEffects
		19: itemTexts
		20: itemPowers
		21: newItemPos
		22: itemRarities
		23: newItemSlot
		24: newItemEnhance
		25: rarityRoll
		26: newItemRarity
		27: newItemName
		28: heroWeaponNames
		29: teamGold
		30: treasureEffect
		31: hallBeaten
		32: shopEffects
		33: eliteColors
		34: eliteNames
		35: newItemSubtype
		36: stairwellEffect
		37: itemProperties
		38: itemPropertyValue
		39: newItemAffixes
		40: itemRolledAffixes
		41: stringsAffix
		42: stringsDesc
		43: teamLuck
		44: widowDamageMod
		45: teamGoldSacrificed
		46: extraItemEffects
		47: itemExtraEffect
		48: roomEliteCount
		49: activeCurse
		50: cursesList
		51: savePowers
		52: challengeModifier
		53: futureFortune
		54: roomsSinceLastEvent
		55: guestData
		56: saveItemNames
		57: saveWeaponProperties
		58: saveBodyProperties
		59: saveHeadProperties
		60: saveLegsProperties
		61: saveSpecialProperties
		62: saveItemRarity
		63: saveSpecialGemstoneType
		64: savePlayerRole
		65: saveWeaponType
		66: treasureItems
		67: torchDifficulty
		68: torchColors
		69: torchNames
		70: currentDifficulty
		71: eventOccured
		72: eventKills
		73: isEventActive
		74: randomRoll
		75: alexBot
		76: eventTimer
		77: loopCounter3
		78: loopCounter4
		79: alexGiftee
		80: specialHeroDesc
		81: saveUniqueItems
		82: itemUnique
		83: isUniqueItem
		84: uniqueWeaponNames
		85: itemUniqueID
		86: itemUniqueProperties
		87: targetPlayer
		88: uniqueItemSpawn
		89: manipGold
		90: sacrificeRoomUses
		91: manipText
		92: manipSuccessRate
		93: manipBusy
		94: flavorTexts
		95: currentTextID
		96: treasureOpenEffect
		97: treasureOrbs
		98: specialTreasureType
		99: specialHallType
		100: floorMapSize
		101: unvisitedRooms
		102: sigmaDamageMod
		103: shopPos
		104: shopText
		105: deathsThisFloor
		106: deathsThisRoom
		107: usedBlackHall
		108: specialHallCooldown
		109: guaranteedWhiteHall
		110: lockedItems
		111: loopCounter5
		112: bossRushCounter
		113: saveUniqueHero
		114: hallChances
		115: markedRoom
		116: eliteEventType
		117: eventType
		118: shopPurchases
		119: currentInput
		120: eventInfoText
		121: saveBlackBlood
		122: uniqueHeroDescriptions
		123: uniqueAbilityInfo
		124: param1
		125: param2
		126: param3
		127: uniqueAbilityNames

	player:
		0: statDamage
		1: statHealth
		2: statDefense
		3: statHealing
		4: statCriticalChance
		5: statCriticalPower
		6: statCooldown
		7: randomRoll
		8: weaponPower
		9: bodyPower
		10: headPower
		11: legsPower
		12: specialPower
		13: itemNames
		14: weaponProperties
		15: bodyProperties
		16: headProperties
		17: legsProperties
		18: specialProperties
		19: itemIndex
		20: itemRarity
		21: specialGemstoneType
		22: tempSwapValue
		23: itemSlot
		24: damageText
		25: damageTextTimer
		26: eliteIndex
		27: eliteBossBar
		28: eliteEffect
		29: overloadingDamageBuffer
		30: isDowned
		31: recoveryProgress
		32: deathInjury
		33: downedHelpIndicator
		34: healingText
		35: healingTextTimer
		36: ultimateAmount
		37: playerRole
		38: healingNullTime
		39: isBoss
		40: maxAmmo
		41: shopCooldown
		42: isCritical
		43: playerUniqueItems
		44: targetPosition
		45: bodyDamageMod
		46: guidingLightEffect
		47: playerPossessed
		48: headDamageMod
		49: isDodging
		50: jumpBuffer
		51: feetDamageMod
		52: statMoveSpeed
		53: boltTarget
		54: boltEffect
		55: resAvailable
		56: specialDamageMod
		57: loopCounter
		58: echoBeamEffect
		59: playerBlackBlood
		60: playerGrace
		61: transformationItemCount
		62: uniqueHero
		63: abilityTarget
		64: usingAbility1
		65: abilityEffects
		66: loopCounter2
		67: transformationEffect
		68: potionType
		69: potionUses
		70: potionMaxUses
		71: potionTimeLeft
		72: forceRecalculateStats
		73: playerHolyMantle
		74: primaryComboCount
		75: playerRage
		76: primaryEffect
		77: secondaryEffect
		78: statDodgeChance
		79: thirdPersonOn
		80: AnimatedUlt
		81: ChoseToBeDevil
		82: potionMod
		83: itemDisplays
		84: aiTarget
		85: sigmaDamageMod
		86: loop3
		87: heroDamageMod
		88: orbEffects
		89: loop4
		90: savedItemID
		91: isGuest
		92: guestVoiceLines
		93: guestID
		94: tempArray
		95: zero
		97: padthaiX
		98: sparksNum
		99: Scale
		100: PlayerName
}

subroutines
{
	0: RecalculateStats
	1: SpawnItem
	2: OnRoomTransition
	3: FloorGen
	4: SpawnItemForSlot
	5: FloorSetup
	6: Manipulator
	7: TreasureDrop
	8: EvaluateHallChance
	9: GoodFortunes
	10: BadFortunes
	11: SpawnSoul
	12: GuestSpawns
	102: SpecialRoom
	103: GeneralShop
	104: DropItem
}

rule("setup")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.floorNumber = Workshop Setting Integer(Custom String("match settings"), Custom String("starting floor"), 0, 0, 20, 0);
		"[changed:q] Added a timestamp comment for version control. 2022/04/02 00:21"
		disabled Disable Inspector Recording;
		Disable Built-In Game Mode Announcer;
		Disable Built-In Game Mode Completion;
		Disable Built-In Game Mode Music;
		Global.roomTypesString = Array(Custom String("empty"), Custom String("uncleared"), Custom String("a treasure room"), Custom String(
			"a shop"), Custom String("a challenge room"), Custom String("a boss room"), Custom String("a fountain"), Custom String(
			"a shrine"), Custom String("a stairwell"), Custom String("the ancient manipulator"), Custom String("the black hall"),
			Custom String("the white hall"), Custom String("a sacrifice room"));
		Global.roomTypesColor = Array(Color(White), Color(Gray), Color(Yellow), Color(Orange), Color(Red), Color(Violet), Color(Green),
			Color(Turquoise), Color(Purple), Color(Rose), Color(Black), Color(White), Color(Black));
		Global.gemstoneTypes = Array(Custom String("damage"), Custom String("critical chance"), Custom String("healing"), Custom String(
			"health"), Custom String("cooldown reduction"), Custom String("defense"), Custom String("critical power"), Custom String(
			"dodge chance"));
		Global.rarityColors = Array(Color(Gray), Color(White), Color(Green), Color(Blue), Color(Purple), Color(Yellow), Color(Red), Color(
			Orange), Color(Rose));
		Global.itemNames = Empty Array;
		Global.itemPositions = Empty Array;
		Global.itemSlots = Empty Array;
		Global.itemSubtypes = Empty Array;
		Global.itemEffects = Empty Array;
		Global.itemTexts = Empty Array;
		Global.itemPowers = Empty Array;
		Global.itemRarities = Empty Array;
		Global.eliteColors = Array(Custom Color(255, 64, 0, 255), Custom Color(255, 255, 192, 255), Custom Color(64, 32, 255, 255),
			Custom Color(64, 255, 32, 255), Custom Color(255, 255, 64, 255), Custom Color(64, 255, 255, 255), Custom Color(0, 128, 0, 255),
			Custom Color(160, 32, 255, 255), Custom Color(108, 108, 108, 255), Custom Color(160, 0, 0, 255));
		"ror2 elites fit in here quite well"
		Global.eliteNames = Array(Custom String("blazing"), Custom String("glacial"), Custom String("overloading"), Custom String(
			"mending"), Custom String("bulwark"), Custom String("celestine"), Custom String("malachite"), Custom String("void-touched"),
			Custom String("stalwart"), Custom String("tainted"));
		Global.itemProperties = Empty Array;
		Global.itemPropertyValue = Empty Array;
		Global.stringsAffix = Array(Array(Custom String("precise {x}"), Custom String("deadly {x}"), Custom String("quick {x}"),
			Custom String("extended {x}"), Custom String("vampiric {x}")), Array(Custom String("vigilant {x}"), Custom String(
			"regenerating {x}"), Custom String("reinforced {x}"), Custom String("plated {x}"), Custom String("heavy {x}")), Array(
			Custom String("mindful {x}"), Custom String("graceful {x}"), Custom String("shielding {x}"), Custom String("absorbing {x}"),
			Custom String("attuned {x}")), Array(Custom String("swift {x}"), Custom String("sturdy {x}"), Custom String("powerful {x}"),
			Custom String("agile {x}"), Custom String("elusive {x}")), Array(Custom String("golden {x}"), Custom String("silver {x}"),
			Custom String("platinum {x}"), Custom String("tungsten {x}"), Custom String("luminite {x}")));
		Global.stringsDesc = Array(Array(Custom String("+{x}% critical chance"), Custom String("+{x}% critical power"), Custom String(
			"+{x}% cooldown reduction"), Custom String("+{x}% max ammo"), Custom String("+{x}% lifesteal")), Array(Custom String(
			"+{x}% defense"), Custom String("+{x}% healing"), Custom String("reflect {x}% of damage taken"), Custom String(
			"+{x}% of max hp as armor"), Custom String("+{x}% knockback resistance")), Array(Custom String("+{x}% critical power"),
			Custom String("+{x}% cooldown reduction"), Custom String("+{x}% of max hp as shield"), Custom String("+{x}% healing received"),
			Custom String("+{x}% critical chance")), Array(Custom String("+{x}% move speed"), Custom String("+{x}% health"), Custom String(
			"+{x}% damage"), Custom String("+{x}% cooldown reduction"), Custom String("+{x}% dodge chance")), Array(Custom String(
			"+{x}% healing and health"), Custom String("+{x}% cooldown reduction and damage"), Custom String(
			"+{x}% critical chance and critical power"), Custom String("+{x}% ultimate charge rate"), Custom String(
			"+{x}% defense and dodge chance")));
		Global.currentRoom = Global.roomType[Global.roomPositionX][Global.roomPositionY];
		Global.extraItemEffects = Empty Array;
		Global.cursesList = Array(Custom String(""), Custom String("Curse of the Labyrinth"), Custom String("Curse of the Lost"),
			Custom String("Curse of the Blind"), Custom String("Curse of the Unknown"), Custom String("Curse of the Maze"), Custom String(
			"Curse of the Darkness"));
		Call Subroutine(FloorSetup);
		Global.savePowers = Array(Empty Array, Empty Array, Empty Array, Empty Array, Empty Array);
		Global.saveItemNames = Array(0, 0, 0, 0, 0);
		Global.saveWeaponProperties = Array(0, 0, 0, 0, 0);
		Global.saveBodyProperties = Array(0, 0, 0, 0, 0);
		Global.saveHeadProperties = Array(0, 0, 0, 0, 0);
		Global.saveLegsProperties = Array(0, 0, 0, 0, 0);
		Global.saveSpecialProperties = Array(0, 0, 0, 0, 0);
		Global.saveItemRarity = Array(0, 0, 0, 0, 0);
		Global.saveSpecialGemstoneType = Array(0, 0, 0, 0, 0);
		Global.savePlayerRole = Array(-1, -1, -1, -1, -1);
		Global.saveWeaponType = Array(-1, -1, -1, -1, -1);
		Global.torchColors = Array(Color(Yellow), Color(Orange), Color(Red), Color(Violet), Color(Gray), Color(Black));
		Global.torchNames = Array(Custom String("the torch flame is roaring."), Custom String(
			"the torch light is fading, but is still bright."), Custom String("the torch's flame is withering."), Custom String(
			"the darkness engulfs you."), Custom String("you feel a looming presence nearby..."), Custom String(
			"the lord of terror is watching you."));
		Global.shopPos = Array(Vector(8, 0, 0), Vector(4, 0, 0), Vector(0, 0, 0), Vector(-4, 0, 0), Vector(-8, 0, 0), Vector(0, 0, -4));
		Global.shopText = Array(Custom String("buy a weapon"), Custom String("buy body armor"), Custom String("buy headgear"),
			Custom String("buy boots"), Custom String("buy an accessory"), Custom String("buy a potion"));
		Global.manipText = Array(Custom String("reforge weapon"), Custom String("reforge armor"), Custom String("reforge headgear"),
			Custom String("reforge boots"), Custom String("reforge accessory"));
		Global.saveUniqueItems = Array(0, 0, 0, 0, 0);
		Global.itemUnique = Empty Array;
		Global.saveBlackBlood = Array(0, 0, 0, 0, 0);
		Global.teamGold = Workshop Setting Real(Custom String("match settings"), Custom String("starting gold"), 0, 0, 10000, 3);
		Global.teamLuck = Workshop Setting Real(Custom String("match settings"), Custom String("starting luck"), 0, 0, 10, 4);
		Global.teamGoldSacrificed = 5000 * Global.teamLuck ^ 2;
		Global.saveUniqueHero = Array(False, False, False, False, False);
		Global.roomsSinceLastEvent = 99999;
		Global.currentTextID = -1;
		Global.bossRushCounter = 1;
	}
}

rule("flavor texts")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.flavorTexts = Array(Custom String("sometimes it's better to not fully clear the floor"), Custom String(
			"don't rush too much, enemies get stronger with each floor"), Custom String("stalwart elites are a meme"), Custom String(
			"this is not darkest dungeon"), Custom String("this is not endless dunge---- hol' up"), Custom String(
			"some treasures can only be found in darkness..."), Custom String("crouch to dim the torch"), Custom String(
			"darker torch = more rewards and harder enemies"), Custom String("healing can crit too"), Custom String(
			"healing stat increases your natural regen rate"), Custom String("spend your gold wisely"), Custom String(
			"luck affects way more things that you think"), Custom String(
			"death injuries make it harder to recover you the next time you fall"), Custom String(
			"rest at fountain when no one in your team has death injuries to get a blessing!"), Custom String("keep it up"), Custom String(
			"have you met {0} alex houk before? he's a cool dude.", Hero Icon String(Hero(Lifeweaver))), Custom String(
			"take care of yourself"), Custom String("skill issue"), Custom String(
			"we live in a rough time, but trust me, everything will be okay"), Custom String("make sure to visit our discord server!"),
			Custom String("life is pain"), Custom String("bruh"), Custom String("i need healing - genji"), Custom String(
			"please stop spamming \"i need healing\" - mercy"), Custom String("i need healing - reinhardt"), Custom String(
			"well that was quick"), Custom String("how far can you go before the server dies?"), Custom String(
			"you should download some more RAM"), Custom String("h"), Custom String("ancient manipulator is a scam (not really)"),
			Custom String("some items are known to have unique properties"), Custom String(
			"have respect to your teammates, don't steal their items xD"), Custom String(
			"alux is the cutest dragon fella that i know. pet the alux."), Custom String("how many references to other games are here?"),
			Custom String("reject humanity, return to monke"), Custom String("alex has made a total of 5 workshop game modes"),
			Custom String("dying is overrated"), Custom String(
			"echo can't use ult because ow workshop ceases to spawn enemies when she does"), Custom String(
			"be kind to others, and they will be kind to you"), Custom String("tread lightly"), Custom String(
			"diablo might look evil, but if you get to know him, you won't regret it"), Custom String("we do be gaming"), Custom String(
			"uwu"), Custom String("the end is nigh"), Custom String("the stars are calling"), Custom String("here, have a cup of tea"),
			Custom String("legends say that if you play this mode on august the 16th, alex will gift you a real cake"), Custom String(
			"don't look behind you"), Custom String("when it's getting dark, diablo comes to reap your soul... jk"), Custom String(
			"don't forget to upgrade your items at the ancient manipulator"), Custom String("bosses are just bulletsponges"),
			Custom String("there are a total of 6 item rarities, plus two for unique items"), Custom String("wait a minute"),
			Custom String("em tsurt, emit fo etsaw si segassem gnisrever"), Custom String("don't trust anyone"), Custom String(
			"void-touched enemies can instantly kill you with their death explosion"), Custom String("stay calm"), Custom String(
			"how many floors are in here?"), Custom String(
			"the old mansion, lost in time\r\nyour party ventures inside\r\nsoon you reach the second floor\r\nand find the same climb once more"),
			Custom String("we do a little trolling"), Custom String("why does this mode exist?"), Custom String(
			"stop wasting your free time"), Custom String("we need to go deeper"), Custom String("imagine not imagining"), Custom String(
			"the tree of light will rise again"), Custom String("there are six different curses in this game"), Custom String(
			"home is where your heart is"), Custom String("this is 69th message in the list - nice"), Custom String(
			"alex has 12 guardians, each from a different world"), Custom String("stay determined"), Custom String(
			"kill - die - learn - repeat"), Custom String("break the cycle"), Custom String("universe collapses around you"),
			Custom String("atone for your sins"), Custom String("if you're reading this, then stop nooooooo---"), Custom String(
			"what is the point of the shop?"), Custom String("go touch some grass"), Custom String("good luck"), Custom String(
			"how many times have you seen alex hosting a lobby of this mode?"), Custom String("ah that's hot"), Custom String(
			"how did your last room go?"), Custom String("please stop"), Custom String("not a pve we needed, but a pve we deserved"),
			Custom String("come on, you are so close"), Custom String("who needs friends when you have depression?"), Custom String(
			"have problems surviving? just don't die lol"), Custom String("the higher they climb, the harder they fall"), Custom String(
			"give me your best shot - cassidy"), Custom String("no, this is not a costume - torbjorn"), Custom String(
			"and dey say chivalry is dead - doomfist"), Custom String("my motorcycle isn't the only thing i ride - ashe"), Custom String(
			"lol no flavor text this time"), Custom String("*snap* yep, this one is going to my cringe compilation"), Custom String(
			"*sad violin noises*"), Custom String("sometimes you can hear alex crying in this dungeon? who did he lose?"), Custom String(
			"the time has come."), Custom String("say hi from me to my big demon friend - alex"), Custom String(
			"i hope you enjoy this mode xD"), Custom String("ah snap, here we go again"), Custom String("I never much liked strawberries"),
			Custom String("Oh boy, here I go killing again"), Custom String("alex says skill issue but then gives hanzo hit scan arrows"),
			Custom String("When you fear someone, that's because you gave them the power to have control over you"), Custom String(
			"The Devil is closer than you think."), Custom String("Animated is a top tier coder mhm yes."), Custom String(
			"The text below me is lying\nThe text above me is telling the truth"), Custom String("\"haha, ha, one!\" - Sonic"),
			Custom String("I've come to make an announcement\nshadow the hedgehog is a beach a$$\nmf"), Custom String(
			"Wow shadow you're an a$$hole\nYou are what you eat sonic"), Custom String("Nerf Delirium"), Custom String(
			"hear me out, mega mush"), Custom String("I am the one who knocks"), Custom String("*insert funny reference here*"),
			Custom String("Have you played rogue legacy 2? Amazing game."), Custom String("{0} You serve zero purpose {0}", Icon String(
			Bolt)), Custom String("Animated has worked on many projects, but has never made a game himself"), Custom String(
			"You did this to me."), Custom String("If you hear crying in this dungeon, no you don't"), Custom String(
			"Do not trust the voices..."), Custom String("So... you come here often?"), Custom String(
			"The end is never The end is never The end is never The end is never The end is never The end is never The end is never"),
			Custom String("\"Experience my balls\" - Zenyatta"), Custom String("Batman I caught a little pokemon..."), Custom String(
			"You should start reading these, they're pretty funny"), Custom String("I know what you did {0}.", Host Player), Custom String(
			"Sometimes it not be like it do, but it is"), Custom String("{0} XBOX LIVE!!! {0}", Icon String(X)));
	}
}

rule("[changed:q][changed:v][changed:p] Floor Setup")
{
	event
	{
		Subroutine;
		FloorSetup;
	}

	actions
	{
		Destroy All Dummy Bots;
		Destroy All In-World Text;
		Destroy All Effects;
		Destroy All HUD Text;
		Destroy All Progress Bar HUD Text;
		Global.rarityRoll = Random Real(0, 100);
		If(Global.rarityRoll <= 5 * Global.floorNumber - 5 * Global.teamLuck + 5 * Global.torchDifficulty && !Is True For Any(All Players(
			Team 1), Current Array Element.playerRole == 0 && Current Array Element.playerUniqueItems[2] == 3));
			Global.activeCurse = Random Integer(1, 6);
		Else;
			Global.activeCurse = 0;
		End;
		"[changed:q] This would allow more flexible map size of each floor"
		Global.floorMapSize = 6 + (Global.activeCurse == 1 ? 2 : 0);
		For Global Variable(loopCounter1, 0, Global.floorMapSize, 1);
			For Global Variable(loopCounter2, 0, Global.floorMapSize, 1);
				Create Effect(Filtered Array(All Players(Team 1), !Global.battleInProgress && Global.activeCurse != 2 && (
					Global.currentRoom < 10 || Global.currentRoom >= 12)), Sphere, Global.roomPositionX == Evaluate Once(Global.loopCounter1)
					&& Global.roomPositionY == Evaluate Once(Global.loopCounter2) ? Color(Sky Blue)
					: Global.roomTypesColor[Global.roomType[Evaluate Once(Global.loopCounter1)][Evaluate Once(Global.loopCounter2)]], Vector(
					-0.500 * Global.floorMapSize + 0.500 + Global.loopCounter1, 0, -0.500 * Global.floorMapSize + 0.500 + Global.loopCounter2),
					0.500, Visible To and Color);
			End;
			Wait(0.016, Ignore Condition);
		End;
		"[changed:q] prepare an array to record rooms for randomized selection in setup/maze"
		Global.unvisitedRooms = Array();
		For Global Variable(loopCounter1, 0, Global.floorMapSize ^ 2, 1);
			Modify Global Variable(unvisitedRooms, Append To Array, Global.loopCounter1);
		End;
		Call Subroutine(FloorGen);
		Wait(0.300, Ignore Condition);
		For Global Variable(loopCounter1, 0, 4, 1);
			For Global Variable(loopCounter2, 0, 3, 1);
				Create Beam Effect(Filtered Array(All Players(Team 1), !Global.battleInProgress && (
					Global.currentRoom < 10 || Global.currentRoom >= 12)), Good Beam, Array(Vector(-19.500, 0, -2), Vector(19.500, 0, -2), Vector(
					-2, 0, -19.500), Vector(-2, 0, 19.500))[Global.loopCounter1] + Array(Vector(0, 0, 0), Vector(0, 6, 0), Vector(
					Global.loopCounter1 > 1 ? 4 : 0, 6, Global.loopCounter1 > 1 ? 0 : 4))[Global.loopCounter2], Array(Vector(-19.500, 6, -2),
					Vector(19.500, 6, -2), Vector(-2, 6, -19.500), Vector(-2, 6, 19.500))[Global.loopCounter1] + Array(Vector(0, 0, 0), Vector(
					Global.loopCounter1 > 1 ? 4 : 0, 0, Global.loopCounter1 > 1 ? 0 : 4), Vector(Global.loopCounter1 > 1 ? 4 : 0, -6,
					Global.loopCounter1 > 1 ? 0 : 4))[Global.loopCounter2], Global.roomTypesColor[Global.roomType[Global.roomPositionX + Array(-1,
					1, 0, 0)[Evaluate Once(Global.loopCounter1)]][Global.roomPositionY + Array(0, 0, -1, 1)[Evaluate Once(Global.loopCounter1)]]],
					Visible To and Color);
				Wait(0.016, Ignore Condition);
			End;
		End;
		Create HUD Text(All Players(All Teams), Custom String("this room is {0}", Global.roomTypesString[Global.currentRoom]), Null, Null,
			Left, 1, Global.roomTypesColor[Global.currentRoom], Color(White), Color(White), Visible To String and Color,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("floor {0}", Global.floorNumber), Null, Null, Left, -1, Color(White), Color(
			White), Color(White), Visible To and String, Default Visibility);
		Wait(0.100, Ignore Condition);
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.playerBlackBlood > 0), Null, Null, Custom String(
			"{0} black blood: {1}%", Icon String(Poison), Round To Integer(Local Player.playerBlackBlood, Up)), Left, 11, Color(White),
			Color(White), Color(Black), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} damage: {1}%", Ability Icon String(Hero(Genji), Button(
			Ultimate)), Round To Integer(Local Player.statDamage, Up)), Left, 12, Color(White), Color(White), Color(Red),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} critical chance: {1}%", Ability Icon String(Hero(Cassidy),
			Button(Ability 2)), Round To Integer(Local Player.statCriticalChance, Up)), Left, 13, Color(White), Color(White), Color(
			Orange), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} healing: {1}%", Ability Icon String(Hero(Mercy), Button(
			Ultimate)), Round To Integer(Local Player.statHealing, Up)), Left, 14, Color(White), Color(White), Color(Yellow),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} health: {1}%", Icon String(Heart), Round To Integer(
			Local Player.statHealth, Up)), Left, 15, Color(White), Color(White), Color(Green), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} cooldown reduction: {1}%", Ability Icon String(Hero(Tracer),
			Button(Ability 2)), Round To Integer(Local Player.statCooldown, Up)), Left, 16, Color(White), Color(White), Color(Aqua),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} defense: {1}%", Ability Icon String(Hero(Brigitte), Button(
			Secondary Fire)), Round To Integer(Local Player.statDefense, Up)), Left, 17, Color(White), Color(White), Color(Blue),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} dodge chance: {1}%", Ability Icon String(Hero(Moira),
			Button(Ability 1)), Round To Integer(Local Player.statDodgeChance, Up)), Left, 18, Color(White), Color(White), Color(Violet),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} critical power: {1}%", Ability Icon String(Hero(Cassidy),
			Button(Ultimate)), Round To Integer(Local Player.statCriticalPower, Up)), Left, 19, Color(White), Color(White), Color(Rose),
			Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), !Global.battleInProgress && !Current Array Element.itemDisplays),
			Custom String("weapon: {0}", Local Player.itemNames[0]), Null, Null, Right, 0, Global.rarityColors[Local Player.itemRarity[0]],
			Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.weaponPower > 0), Null, Null,
			Custom String("+{0}% damage", Round To Integer(Local Player.weaponPower, Up)), Right, 1, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Wait(0.100, Ignore Condition);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && !Current Array Element.uniqueHero), Custom String(
			"body: {0}", Local Player.itemNames[1]), Null, Null, Right, 6, Global.rarityColors[Local Player.itemRarity[1]], Color(White),
			Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.bodyPower > 0), Null, Null,
			Custom String("+{0}% health", Round To Integer(Local Player.bodyPower, Up)), Right, 7, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && !Current Array Element.uniqueHero), Custom String(
			"head: {0}", Local Player.itemNames[2]), Null, Null, Right, 12, Global.rarityColors[Local Player.itemRarity[2]], Color(White),
			Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.headPower > 0), Null, Null,
			Custom String("+{0}% healing", Round To Integer(Local Player.headPower, Up)), Right, 13, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && !Current Array Element.uniqueHero), Custom String(
			"legs: {0}", Local Player.itemNames[3]), Null, Null, Right, 18, Global.rarityColors[Local Player.itemRarity[3]], Color(White),
			Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.legsPower > 0), Null, Null,
			Custom String("+{0}% defense", Round To Integer(Local Player.legsPower, Up)), Right, 19, Color(White), Color(White), Color(
			White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && !Current Array Element.uniqueHero), Custom String(
			"special: {0}", Local Player.itemNames[4]), Null, Null, Right, 24, Global.rarityColors[Local Player.itemRarity[4]], Color(
			White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.specialPower > 0), Null, Null,
			Custom String("+{0}% {1}", Round To Integer(Local Player.specialPower, Up),
			Global.gemstoneTypes[Local Player.specialGemstoneType]), Right, 25, Color(White), Color(White), Color(White),
			Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("team gold: {0}", Global.teamGold), Null, Null, Left, -3, Color(Yellow),
			Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.deathInjury > 0), Custom String(
			"{0} death injury x{1}", Icon String(Skull), Local Player.deathInjury), Null, Null, Right, -10, Color(Red), Color(White),
			Color(White), Visible To and String, Default Visibility);
		Create Progress Bar HUD Text(Filtered Array(All Players(All Teams), Current Array Element.isDowned), Local Player.recoveryProgress,
			Custom String("you have been downed"), Top, 1, Color(Yellow), Color(White), Visible To Values and Color, Default Visibility);
		Wait(0.100, Ignore Condition);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.weaponProperties[0])
			> 0 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[0][Local Player.weaponProperties[0][0]], Custom String("{x}"), Local Player.weaponProperties[1][0]), Right,
			2, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.bodyProperties[0])
			> 0 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[1][Local Player.bodyProperties[0][0]], Custom String("{x}"), Local Player.bodyProperties[1][0]), Right, 8,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.headProperties[0])
			> 0 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[2][Local Player.headProperties[0][0]], Custom String("{x}"), Local Player.headProperties[1][0]), Right, 14,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.legsProperties[0])
			> 0 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[3][Local Player.legsProperties[0][0]], Custom String("{x}"), Local Player.legsProperties[1][0]), Right, 20,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.specialProperties[0])
			> 0 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[4][Local Player.specialProperties[0][0]], Custom String("{x}"), Local Player.specialProperties[1][0]),
			Right, 26, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.weaponProperties[0])
			> 1 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[0][Local Player.weaponProperties[0][1]], Custom String("{x}"), Local Player.weaponProperties[1][1]), Right,
			3, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.bodyProperties[0])
			> 1 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[1][Local Player.bodyProperties[0][1]], Custom String("{x}"), Local Player.bodyProperties[1][1]), Right, 9,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Wait(0.100, Ignore Condition);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.headProperties[0])
			> 1 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[2][Local Player.headProperties[0][1]], Custom String("{x}"), Local Player.headProperties[1][1]), Right, 15,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.legsProperties[0])
			> 1 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[3][Local Player.legsProperties[0][1]], Custom String("{x}"), Local Player.legsProperties[1][1]), Right, 21,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.specialProperties[0])
			> 1 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[4][Local Player.specialProperties[0][1]], Custom String("{x}"), Local Player.specialProperties[1][1]),
			Right, 27, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.weaponProperties[0])
			> 2 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[0][Local Player.weaponProperties[0][2]], Custom String("{x}"), Local Player.weaponProperties[1][2]), Right,
			4, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.bodyProperties[0])
			> 2 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[1][Local Player.bodyProperties[0][2]], Custom String("{x}"), Local Player.bodyProperties[1][2]), Right, 10,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.headProperties[0])
			> 2 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[2][Local Player.headProperties[0][2]], Custom String("{x}"), Local Player.headProperties[1][2]), Right, 16,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.legsProperties[0])
			> 2 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[3][Local Player.legsProperties[0][2]], Custom String("{x}"), Local Player.legsProperties[1][2]), Right, 22,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Count Of(Current Array Element.specialProperties[0])
			> 2 && !Global.battleInProgress && !Current Array Element.itemDisplays), Null, Null, String Replace(
			Global.stringsDesc[4][Local Player.specialProperties[0][2]], Custom String("{x}"), Local Player.specialProperties[1][2]),
			Right, 28, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Wait(0.100, Ignore Condition);
		Create Effect(Filtered Array(All Players(All Teams),
			!Global.battleInProgress && Global.activeCurse != 2 && Global.currentRoom < 10), Light Shaft, Color(Sky Blue), Vector(
			-2.500 + (Global.activeCurse == 1 ? -1 : 0) + Global.roomPositionX, 0, -2.500 + (Global.activeCurse == 1 ? -1 : 0)
			+ Global.roomPositionY), 0.200, Visible To Position and Radius);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.teamLuck > 0), Custom String("luck: +{0}", Global.teamLuck), Null,
			Null, Left, -2, Custom Color(0, 160, 0, 255), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), !Global.battleInProgress), Null, Custom String(
			"[{0}] - pick up items\r\n[{0}] + [{1}] - third person\r\nhold [{2}] - toggle item display", Input Binding String(Button(
			Interact)), Input Binding String(Button(Crouch)), Input Binding String(Button(Melee))), Null, Top, -1, Color(White), Color(
			Green), Color(White), Visible To and String, Default Visibility);
		Start Healing Modification(Filtered Array(All Players(Team 1), Current Array Element.healingNullTime > 0), All Players(Team 1), 0,
			Receivers Healers and Healing Percent);
		Create Effect(Filtered Array(All Players(Team 1), Current Array Element.healingNullTime > 0), Ana Biotic Grenade No Healing Effect,
			Team 2, Local Player, 1, Visible To Position and Radius);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.activeCurse != 0), Custom String("{0}",
			Global.cursesList[Global.activeCurse]), Null, Null, Left, 0, Color(Purple), Color(White), Color(White), Visible To and String,
			Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Current Array Element.deathInjury < 0), Custom String(
			"{0} blessing of life x{1}", Ability Icon String(Hero(Mercy), Button(Ability 2)), 0 - Local Player.deathInjury), Null, Null,
			Right, -10, Color(Green), Color(White), Color(White), Visible To and String, Default Visibility);
		Global.torchDifficulty = Global.activeCurse == 6 ? 2 : 0;
		Create Effect(All Players(All Teams), Bad Aura, Global.torchColors[Global.torchDifficulty], Vector(0, 32, 0), 12,
			Visible To Position Radius and Color);
		Create HUD Text(All Players(All Teams), Null, Global.torchNames[Global.torchDifficulty], Null, Top, -2, Color(White),
			Global.torchColors[Global.torchDifficulty], Color(White), Visible To String and Color, Default Visibility);
		Global.currentDifficulty = 0;
		Global.eventOccured = False;
		Wait(0.100, Ignore Condition);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.eventTimer > 0 && Global.eventType == 1), Custom String(
			"party {0} | {1} alex", Global.eventKills, Player Stat(Global.alexBot, Final Blows)), Null, Null, Top, 1, Color(Turquoise),
			Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams), Global.eventTimer > 0 && Global.eventType == 2), Custom String(
			"{0} points | {1}", Global.eventKills, Array(Custom String("rare"), Custom String("epic"), Custom String("legendary"),
			Custom String("mythical"), Custom String("divine"))[Round To Integer(Global.eventKills / 25, Down)]), Null, Null, Top, 1,
			Array(Color(Blue), Color(Purple), Color(Orange), Color(Rose), Color(Sky Blue))[Round To Integer(Global.eventKills / 25, Down)],
			Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams),
			!Global.battleInProgress && !Current Array Element.uniqueHero && Array Contains(Global.specialHeroDesc[0], Hero Of(
			Current Array Element))), Null, Null, Custom String("{0}{1}\r\n{2}", Hero Icon String(Hero Of(Local Player)), Hero Of(
			Local Player), Global.specialHeroDesc[1][Index Of Array Value(Global.specialHeroDesc[0], Hero Of(Local Player))]), Right, -3,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.playerUniqueItems[0] != 0), Null,
			Null, Global.itemUniqueProperties[0][Local Player.playerUniqueItems[0] - 1], Right, 5, Color(White), Color(White), Color(
			Orange), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.playerUniqueItems[1] != 0), Null,
			Null, Global.itemUniqueProperties[1][Local Player.playerRole * 4 + (Local Player.playerUniqueItems[1] - 1)], Right, 11, Color(
			White), Color(White), Color(Orange), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.playerUniqueItems[2] != 0), Null,
			Null, Global.itemUniqueProperties[2][Local Player.playerRole * 4 + (Local Player.playerUniqueItems[2] - 1)], Right, 17, Color(
			White), Color(White), Color(Orange), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.playerUniqueItems[3] != 0), Null,
			Null, Global.itemUniqueProperties[3][Local Player.playerRole * 4 + (Local Player.playerUniqueItems[3] - 1)], Right, 23, Color(
			White), Color(White), Color(Orange), Visible To and String, Default Visibility);
		Create HUD Text(Filtered Array(All Players(All Teams),
			!Global.battleInProgress && !Current Array Element.itemDisplays && Current Array Element.playerUniqueItems[4] != 0), Null,
			Null, Global.itemUniqueProperties[4][Local Player.playerUniqueItems[4] - 1], Right, 29, Color(White), Color(White), Color(
			Orange), Visible To and String, Default Visibility);
		Global.currentTextID = Random Integer(0, Count Of(Global.flavorTexts) - 1);
		Global.deathsThisFloor = 0;
		If(Global.floorNumber == 2 && Global.specialHallType == 1);
			Global.guaranteedWhiteHall = True;
		End;
		If(Global.specialHallCooldown > 0);
			Global.specialHallCooldown -= 1;
		End;
		Global.specialHallType = 0;
		Create In-World Text(Filtered Array(All Players(All Teams), !Global.battleInProgress), Global.currentTextID == -1 ? Custom String(
			"welcome to the endless dungeon!\r\nall players must stand next to the same door\r\nto move between rooms")
			: Global.flavorTexts[Global.currentTextID], Vector(0, 7, 0), 1.600, Do Not Clip, Visible To Position String and Color,
			Global.currentRoom == 10 ? Color(Red) : (Global.currentRoom == 11 ? Color(Yellow) : Color(Gray)), Default Visibility);
		Global.lockedItems = False;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("black hall {0}% | {1}% white hall", Global.hallChances[0],
			Global.hallChances[1]), Top, -4, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		All Players(Team 1).playerGrace = False;
		Wait(0.100, Ignore Condition);
		Create HUD Text(Filtered Array(All Players(All Teams), !Global.battleInProgress && Current Array Element.uniqueHero), Null, Null,
			Custom String("{0} Unique Hero: {1}\r\n{2}", Hero Icon String(Hero Of(Local Player)), Array(Custom String("Petra"),
			Custom String("Diablo"), Custom String("Mithrix"))[Local Player.playerRole],
			Global.uniqueHeroDescriptions[Local Player.playerRole]), Right, -3, Color(White), Color(White), Array(Color(Yellow), Color(
			Red), Color(Blue))[Local Player.playerRole], Visible To String and Color, Default Visibility);
		Create Progress Bar HUD Text(Filtered Array(All Players(All Teams),
			Current Array Element.uniqueHero || Current Array Element.PlayerName == Custom String("AnimatedNerd")),
			Local Player.playerRage, Local Player.playerRage == 100 ? Custom String("rage ready!") : Custom String("rage"), Top, -26,
			Local Player.playerRage == -90 ? Custom Color(255, Sine From Degrees(-90 + Total Time Elapsed * 90 % 90) * 255,
			Sine From Degrees(-90 + Total Time Elapsed * 90 % 90) * 255, 255) : Custom Color(255, 255 - Local Player.playerRage * 2.550, 0,
			255), Color(White), Visible To Values and Color, Default Visibility);
		For Global Variable(loopCounter1, 0, 5, 1);
			Create HUD Text(Filtered Array(All Players(Team 1), !Global.battleInProgress && Current Array Element.uniqueHero), Custom String(
				"[{0}] {1}", Input Binding String(Array(Button(Primary Fire), Button(Secondary Fire), Button(Ability 1), Button(Ability 2),
				Button(Ultimate))[Evaluate Once(Global.loopCounter1)]), Global.uniqueAbilityNames[Local Player.playerRole][Evaluate Once(
				Global.loopCounter1)]), Null, Null, Right, 30 + Global.loopCounter1 * 2, Color(White), Color(White), Color(White),
				Visible To String and Color, Default Visibility);
			Create HUD Text(Filtered Array(All Players(All Teams), !Global.battleInProgress && Current Array Element.uniqueHero), Null, Null,
				Global.uniqueAbilityInfo[Local Player.playerRole][Evaluate Once(Global.loopCounter1)], Right, 31 + Global.loopCounter1 * 2,
				Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		End;
		Global.shopPurchases = 0;
		Wait(0.100, Ignore Condition);
		Create HUD Text(All Players(Team 1), Custom String("potion: {0}{1}", Local Player.itemNames[5],
			Local Player.itemRarity[5] != 0 ? Custom String(" | {0}/{1} uses", Local Player.potionUses, Local Player.potionMaxUses)
			: Custom String("")), Null, Null, Left, 31, Local Player.itemRarity[5] != 0 ? (Local Player.potionUses == 0 ? Color(Red)
			: Color(Aqua)) : Color(Gray), Color(White), Color(White), Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Current Array Element.itemRarity[5] != 0), Null, Null, Custom String(
			"hold {0} to use", Input Binding String(Button(Reload))), Left, 33, Color(White), Color(White), Color(White),
			Visible To String and Color, Default Visibility);
		Create HUD Text(Filtered Array(All Players(Team 1), Current Array Element.itemRarity[5] != 0), Null, Null, Array(Custom String(
			"Instantly heal by 60% of Max Health"), Custom String("Heal by 15% Max Health per second for 15 seconds"), Custom String(
			"Deal +100% damage, decaying over 30 seconds"), Custom String("Take 75% less damage, decaying over 15 seconds"), Custom String(
			"For 10 seconds your abilities recharge almost instantly"), Custom String(
			"Guarantees all attacks to be Critical for 15 seconds"), Custom String(
			"Become immune to all damage and Crowd Control for 2 seconds"), Custom String("Grant team +0.5 Luck for the current room"),
			Custom String("Neutralizes (25~50)% of your Black Blood, randomly"), Custom String("Fully charge your Ultimate"),
			Custom String("Increase your Critical Power by 100% for 20 seconds"), Custom String("Create a random item"), Custom String(
			"it irradiates justice and support."), Custom String("probably this belongs to a big bad demon."), Custom String(
			"king of nothing, the bulwark of the weak."))[Local Player.potionType], Left, 32, Color(White), Color(White), Color(White),
			Visible To String and Color, Default Visibility);
		Global.sacrificeRoomUses = 0;
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("run time: {0}{1}:{2}",
			Total Time Elapsed >= 3600 ? Custom String("{0}:", Round To Integer(Total Time Elapsed / 3600, Down)) : Custom String(""),
			Total Time Elapsed >= 3600 ? Custom String("{0}{1}", Round To Integer(Total Time Elapsed % 3600 / 600, Down), Round To Integer(
			Total Time Elapsed % 600 / 60, Down)) : Custom String("{0}", Round To Integer(Total Time Elapsed / 60, Down)), Custom String(
			"{0}{1}", Round To Integer(Total Time Elapsed % 60 / 10, Down), Round To Integer(Total Time Elapsed % 10, Down))), Top, -100,
			Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
		Create In-World Text(Filtered Array(All Players(All Teams), Global.roomPositionX > 0 && !Global.battleInProgress && (
			Global.currentRoom < 10 || Global.currentRoom >= 12)),
			Global.roomTypesString[Global.roomType[Global.roomPositionX - 1][Global.roomPositionY]], Vector(-20, 6, 0), 1, Do Not Clip,
			Visible To String and Color, Global.roomTypesColor[Global.roomType[Global.roomPositionX - 1][Global.roomPositionY]],
			Default Visibility);
		Create In-World Text(Filtered Array(All Players(All Teams),
			Global.roomPositionX < Global.floorMapSize - 1 && !Global.battleInProgress && (
			Global.currentRoom < 10 || Global.currentRoom >= 12)),
			Global.roomTypesString[Global.roomType[Global.roomPositionX + 1][Global.roomPositionY]], Vector(20, 6, 0), 1, Do Not Clip,
			Visible To String and Color, Global.roomTypesColor[Global.roomType[Global.roomPositionX + 1][Global.roomPositionY]],
			Default Visibility);
		Create In-World Text(Filtered Array(All Players(All Teams), Global.roomPositionY > 0 && !Global.battleInProgress && (
			Global.currentRoom < 10 || Global.currentRoom >= 12)),
			Global.roomTypesString[Global.roomType[Global.roomPositionX][Global.roomPositionY - 1]], Vector(0, 6, -20), 1, Do Not Clip,
			Visible To String and Color, Global.roomTypesColor[Global.roomType[Global.roomPositionX][Global.roomPositionY - 1]],
			Default Visibility);
		Create In-World Text(Filtered Array(All Players(All Teams),
			Global.roomPositionY < Global.floorMapSize - 1 && !Global.battleInProgress && (
			Global.currentRoom < 10 || Global.currentRoom >= 12)),
			Global.roomTypesString[Global.roomType[Global.roomPositionX][Global.roomPositionY + 1]], Vector(0, 6, 20), 1, Do Not Clip,
			Visible To String and Color, Global.roomTypesColor[Global.roomType[Global.roomPositionX][Global.roomPositionY + 1]],
			Default Visibility);
		Wait(0.100, Ignore Condition);
	}
}

rule("[changed:q]FloorGen")
{
	event
	{
		Subroutine;
		FloorGen;
	}

	actions
	{
		Destroy All Icons;
		Global.roomType = Array();
		For Global Variable(loopCounter1, 0, Global.floorMapSize, 1);
			Global.temp = Empty Array;
			For Global Variable(loopCounter2, 0, Global.floorMapSize, 1);
				Modify Global Variable(temp, Append To Array, 1);
			End;
			Modify Global Variable(roomType, Append To Array, Array(Global.temp));
		End;
		Global.temp = Empty Array;
		For Global Variable(loopCounter1, 0, Global.floorMapSize, 1);
			For Global Variable(loopCounter2, 0, Global.floorMapSize, 1);
				Global.rarityRoll = Random Real(0, 100);
				If(Global.rarityRoll <= 12.500);
					Global.temp = Global.roomType[Global.loopCounter1];
					Global.temp[Global.loopCounter2] = 4;
					Global.roomType[Global.loopCounter1] = Global.temp;
				End;
			End;
		End;
		For Global Variable(loopCounter1, 0, 3 + (Global.activeCurse == 1 ? 2 : 0), 1);
			Global.param1 = 2;
			Call Subroutine(SpecialRoom);
			Wait(0.016, Ignore Condition);
		End;
		Global.param1 = 3;
		Call Subroutine(SpecialRoom);
		Wait(0.016, Ignore Condition);
		Global.param1 = 5;
		Call Subroutine(SpecialRoom);
		Wait(0.016, Ignore Condition);
		Global.param1 = Global.floorNumber % 2 == 1 ? 12 : 6;
		Call Subroutine(SpecialRoom);
		Wait(0.016, Ignore Condition);
		Global.param1 = 7;
		Call Subroutine(SpecialRoom);
		Wait(0.016, Ignore Condition);
		If(Global.floorNumber >= 3);
			Global.param1 = 9;
			Call Subroutine(SpecialRoom);
			Wait(0.016, Ignore Condition);
		End;
		Global.param1 = 0;
		Call Subroutine(SpecialRoom);
		Wait(0.016, Ignore Condition);
		"[new:q] prepare the unvisited array for maze"
		Global.unvisitedRooms = Array();
		For Global Variable(loopCounter1, 0, Global.floorMapSize ^ 2, 1);
			Modify Global Variable(unvisitedRooms, Append To Array, Global.loopCounter1);
		End;
		"[new:q] Remove the entrance"
		Modify Global Variable(unvisitedRooms, Remove From Array By Value,
			Global.roomPositionX * Global.floorMapSize + Global.roomPositionY);
		"Set up enemy spawns"
		Global.enemySpawnPool = Empty Array;
		Global.rarityRoll = Random Real(0, 100);
		Global.eliteEventType = 0;
		If(Global.rarityRoll <= 10);
			Global.eliteEventType = Random Integer(1, Global.floorNumber >= 3 ? 10 : 5);
			Big Message(All Players(All Teams), Custom String("event: only {0} elites on this floor!",
				Global.eliteNames[Global.eliteEventType - 1]));
			Create HUD Text(All Players(All Teams), Null, Null, Custom String("{0} elites only", Global.eliteNames[Global.eliteEventType - 1]),
				Left, 7, Color(White), Color(White), Global.eliteColors[Global.eliteEventType - 1], Visible To String and Color,
				Default Visibility);
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Tank Heroes, Array(Hero(D.Va),
				Hero(Zarya)))));
			Modify Global Variable(enemySpawnPool, Append To Array, Array Slice(Randomized Array(All Damage Heroes), 0, 3));
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Support Heroes, Hero(Moira))));
		Else If(Global.rarityRoll <= 20);
			Global.enemySpawnPool = Array(Random Value In Array(Remove From Array(All Heroes, Array(Hero(D.Va), Hero(Moira), Hero(Zarya)))));
			Big Message(All Players(All Teams), Custom String("event: only {0} {1} on this floor!", Hero Icon String(Global.enemySpawnPool[0]),
				Global.enemySpawnPool[0]));
		Else If(Global.rarityRoll <= 25);
			Big Message(All Players(All Teams), Custom String("event: all rooms became challenge rooms!"));
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Tank Heroes, Array(Hero(D.Va),
				Hero(Zarya)))));
			Modify Global Variable(enemySpawnPool, Append To Array, Array Slice(Randomized Array(All Damage Heroes), 0, 3));
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Support Heroes, Hero(Moira))));
			For Global Variable(loopCounter1, 0, Global.floorMapSize, 1);
				For Global Variable(loopCounter2, 0, Global.floorMapSize, 1);
					If(Global.roomType[Global.loopCounter1][Global.loopCounter2] == 1);
						Global.temp = Global.roomType[Global.loopCounter1];
						Global.temp[Global.loopCounter2] = 4;
						Global.roomType[Global.loopCounter1] = Global.temp;
					End;
				End;
			End;
		Else;
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Tank Heroes, Array(Hero(D.Va),
				Hero(Zarya)))));
			Modify Global Variable(enemySpawnPool, Append To Array, Array Slice(Randomized Array(All Damage Heroes), 0, 3));
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Support Heroes, Hero(Moira))));
		End;
		If(Count Of(Filtered Array(All Players(Team 1),
			Current Array Element.playerRole == 1 && Current Array Element.playerUniqueItems[3] == 4)) > 0);
			Global.markedRoom = Random Integer(1, Global.floorMapSize ^ 2);
			Create Icon(Filtered Array(All Players(All Teams),
				!Global.battleInProgress && Global.activeCurse != 2 && Global.currentRoom < 10 && Global.markedRoom != 0), Vector(
				-0.500 * Global.floorMapSize + Round To Integer((Global.markedRoom - 1) / Global.floorMapSize, Down) + 0.500, 0,
				-0.500 * Global.floorMapSize + Round To Integer((Global.markedRoom - 1) % Global.floorMapSize, Down) + 0.500), Arrow: Down,
				Visible To and Position, Color(Red), False);
		Else;
			Global.markedRoom = 0;
		End;
		If(Global.futureFortune);
			Global.futureFortune = False;
			Call Subroutine(GoodFortunes);
		End;
	}
}

rule("player stuff")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(!Is Dummy Bot(Event Player) || Event Player.isGuest) == True;
	}

	actions
	{
		Event Player.PlayerName = Custom String("{0}", Event Player);
		Disable Game Mode HUD(Event Player);
		Event Player.statDamage = 100;
		Event Player.statHealth = 100;
		Event Player.statHealing = 100;
		Event Player.statCriticalChance = 10;
		Event Player.statCriticalPower = 150;
		Event Player.weaponProperties = Array(Empty Array, Empty Array);
		Event Player.bodyProperties = Array(Empty Array, Empty Array);
		Event Player.headProperties = Array(Empty Array, Empty Array);
		Event Player.legsProperties = Array(Empty Array, Empty Array);
		Event Player.specialProperties = Array(Empty Array, Empty Array);
		Event Player.itemNames = Array(Custom String("none"), Custom String("none"), Custom String("none"), Custom String("none"),
			Custom String("none"), Custom String("none"));
		If(Event Player.isGuest && Is Dummy Bot(Event Player));
			Event Player.weaponPower = 20 * (Global.floorNumber * 2 + 8) + Random Real(0, 25);
			Event Player.headPower = 20 * (Global.floorNumber * 2 + 8) + Random Real(0, 25);
			Event Player.bodyPower = 25 * (Global.floorNumber * 2 + 8) + Random Real(0, 30);
			Event Player.legsPower = 70 * (1 - 0.990 ^ (Global.floorNumber * 2 + 8) * Random Real(0.925, 0.975));
			Event Player.specialGemstoneType = Global.guestData[Event Player.guestID][6] % 8;
			Event Player.specialPower = Array Contains(Array(1, 4, 5, 7), Event Player.specialGemstoneType) ? (1 - 0.985 ^ (
				Global.floorNumber * 2 + 8) * Random Real(0.850, 0.950)) * 100 : 10 * (Global.floorNumber * 2 + 8) + Random Real(0, 10);
			Event Player.itemRarity = Array(7, 7, 7, 7, 7, 0);
			Event Player.playerUniqueItems = Append To Array(Array Slice(Global.guestData[Event Player.guestID], 2, 5), 0);
		Else;
			Event Player.itemRarity = Array(0, 0, 0, 0, 0, 0);
			Event Player.playerUniqueItems = Array(0, 0, 0, 0, 0, 0);
		End;
		Disable Messages(Event Player);
		Chase Player Variable At Rate(Event Player, damageTextTimer, 0, 1, Destination and Rate);
		Chase Player Variable At Rate(Event Player, recoveryProgress, 0, 5, Destination and Rate);
		Chase Player Variable At Rate(Event Player, healingTextTimer, 0, 1, Destination and Rate);
		Wait Until(Has Spawned(Event Player), 99999);
		Wait(0.100, Ignore Condition);
		Teleport(Event Player, Vector(4, 0, 0));
		Chase Player Variable At Rate(Event Player, healingNullTime, 0, 1, Destination and Rate);
		If(Event Player.isGuest);
			Event Player.playerRole = -1;
		Else If(Array Contains(All Tank Heroes, Hero Of(Event Player)));
			Event Player.playerRole = 2;
		Else If(Array Contains(All Damage Heroes, Hero Of(Event Player)));
			Event Player.playerRole = 1;
		Else;
			Event Player.playerRole = 0;
		End;
		Global.savePlayerRole[Slot Of(Event Player)] = Event Player.playerRole;
		Global.saveWeaponType[Slot Of(Event Player)] = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Event Player));
		Global.savePowers[Slot Of(Event Player)] = Array(0, 0, 0, 0, 0);
		Global.saveItemNames[Slot Of(Event Player)] = 0;
		Global.saveWeaponProperties[Slot Of(Event Player)] = 0;
		Global.saveBodyProperties[Slot Of(Event Player)] = 0;
		Global.saveHeadProperties[Slot Of(Event Player)] = 0;
		Global.saveLegsProperties[Slot Of(Event Player)] = 0;
		Global.saveSpecialProperties[Slot Of(Event Player)] = 0;
		Global.saveItemRarity[Slot Of(Event Player)] = Array(0, 0, 0, 0, 0, 0);
		Global.saveUniqueItems[Slot Of(Event Player)] = Array(0, 0, 0, 0, 0, 0);
		Global.saveSpecialGemstoneType[Slot Of(Event Player)] = 0;
		Global.saveUniqueHero[Slot Of(Event Player)] = False;
		Event Player.maxAmmo = Array(Max Ammo(Event Player, 0), Max Ammo(Event Player, 1));
		Chase Player Variable At Rate(Event Player, shopCooldown, 0, 1, Destination and Rate);
		Wait(0.500, Ignore Condition);
		Call Subroutine(RecalculateStats);
		Event Player.playerGrace = True;
		Event Player.potionUses = 3;
		Event Player.potionMaxUses = 3;
		Chase Player Variable At Rate(Event Player, potionTimeLeft, 0, 1, Destination and Rate);
		Start Damage Modification(All Players(Team 2), Filtered Array(Array(Event Player), Event Player.isCritical),
			Event Player.statCriticalPower, Receivers Damagers and Damage Percent);
		Start Healing Modification(All Players(Team 1), Filtered Array(Array(Event Player), Event Player.isCritical),
			Event Player.statCriticalPower, Receivers Healers and Healing Percent);
		Event Player.orbEffects = Empty Array;
	}
}

rule("[changed:q][changed:p]move left")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(-20, 0,
			0)) <= 6) == True;
		Global.roomPositionX > 0;
		Global.battleInProgress == False;
		Number Of Players(Team 1) > 0;
		Number Of Players(Team 2) == 0;
		Has Spawned(Global.treasureOpenEffect) == False;
		(Global.currentRoom < 10 || Global.currentRoom >= 12) == True;
		Global.floorNumber < 667;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.roomPositionX -= 1;
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Set Facing(All Players(Team 1), Right, To World);
		Call Subroutine(OnRoomTransition);
		Wait(0.100, Ignore Condition);
		Global.currentRoom = Global.roomType[Global.roomPositionX][Global.roomPositionY];
		Wait(0.250, Ignore Condition);
		If(Array Contains(Array(1, 2, 4, 5), Global.currentRoom));
			Global.currentDifficulty += 1;
		Else;
			Global.currentDifficulty += 0.251;
		End;
	}
}

rule("[changed:q][changed:p]move right")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(20, 0,
			0)) <= 6) == True;
		Global.roomPositionX < Global.floorMapSize - 1;
		Global.battleInProgress == False;
		Number Of Players(Team 1) > 0;
		Number Of Players(Team 2) == 0;
		Has Spawned(Global.treasureOpenEffect) == False;
		(Global.currentRoom < 10 || Global.currentRoom >= 12) == True;
		Global.floorNumber < 667;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.roomPositionX += 1;
		Teleport(All Players(Team 1), Vector(-12, 0, 0));
		Set Facing(All Players(Team 1), Left, To World);
		Call Subroutine(OnRoomTransition);
		Wait(0.100, Ignore Condition);
		Global.currentRoom = Global.roomType[Global.roomPositionX][Global.roomPositionY];
		Wait(0.250, Ignore Condition);
		If(Array Contains(Array(1, 2, 4, 5), Global.currentRoom));
			Global.currentDifficulty += 1;
		Else;
			Global.currentDifficulty += 0.251;
		End;
	}
}

rule("[changed:q][changed:p] move up")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0,
			-20)) <= 6) == True;
		Global.roomPositionY > 0;
		Global.battleInProgress == False;
		Number Of Players(Team 1) > 0;
		Number Of Players(Team 2) == 0;
		Has Spawned(Global.treasureOpenEffect) == False;
		(Global.currentRoom < 10 || Global.currentRoom >= 12) == True;
		Global.floorNumber < 667;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.roomPositionY -= 1;
		Teleport(All Players(Team 1), Vector(0, 0, 12));
		Set Facing(All Players(Team 1), Backward, To World);
		Call Subroutine(OnRoomTransition);
		Wait(0.100, Ignore Condition);
		Global.currentRoom = Global.roomType[Global.roomPositionX][Global.roomPositionY];
		Wait(0.250, Ignore Condition);
		If(Array Contains(Array(1, 2, 4, 5), Global.currentRoom));
			Global.currentDifficulty += 1;
		Else;
			Global.currentDifficulty += 0.251;
		End;
	}
}

rule("[changed:q][changed:p] move down")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0,
			20)) <= 6) == True;
		Global.roomPositionY < Global.floorMapSize - 1;
		Global.battleInProgress == False;
		Number Of Players(Team 1) > 0;
		Number Of Players(Team 2) == 0;
		Has Spawned(Global.treasureOpenEffect) == False;
		(Global.currentRoom < 10 || Global.currentRoom >= 12) == True;
		Global.floorNumber < 667;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.roomPositionY += 1;
		Teleport(All Players(Team 1), Vector(0, 0, -12));
		Set Facing(All Players(Team 1), Forward, To World);
		Call Subroutine(OnRoomTransition);
		Wait(0.100, Ignore Condition);
		Global.currentRoom = Global.roomType[Global.roomPositionX][Global.roomPositionY];
		Wait(0.250, Ignore Condition);
		If(Array Contains(Array(1, 2, 4, 5), Global.currentRoom));
			Global.currentDifficulty += 1;
		Else;
			Global.currentDifficulty += 0.251;
		End;
	}
}

rule("[changed:q][changed:p] normal uncleared room + challenge")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		(Global.currentRoom == 1 || Global.currentRoom == 4) == True;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element)) == True;
		Number Of Players(Team 1) > 0;
		Global.battleInProgress == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Global.battleInProgress = True;
		If(Count Of(Global.enemySpawnPool) > 1);
			Global.enemySpawnPool = Empty Array;
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Tank Heroes, Array(Hero(D.Va),
				Hero(Zarya)))));
			Modify Global Variable(enemySpawnPool, Append To Array, Array Slice(Randomized Array(All Damage Heroes), 0, 3));
			Modify Global Variable(enemySpawnPool, Append To Array, Random Value In Array(Remove From Array(All Support Heroes, Hero(Moira))));
		End;
		Global.randomRoll = Random Real(0, 1);
		If(Global.currentRoom == 1 && Global.randomRoll < 0.150 * Global.torchDifficulty);
			Big Message(All Players(Team 1), Custom String("the darkness grows..."));
			Global.temp = Global.roomType[Global.roomPositionX];
			Global.temp[Global.roomPositionY] = 4;
			Global.roomType[Global.roomPositionX] = Global.temp;
			Global.currentRoom = 4;
		End;
		If(Global.currentRoom == 4);
			Global.challengeModifier = Random Integer(1, 10);
		End;
		Chase Player Variable At Rate(All Players(Team 1), ultimateAmount, 100, 1, Destination and Rate);
		For Global Variable(loopCounter3, 0, Count Of(Filtered Array(All Players(Team 1),
			Current Array Element.playerUniqueItems[2] == 1 && Current Array Element.playerRole == 0)), 1);
			Global.targetPlayer = Random Value In Array(Filtered Array(All Players(Team 1), Current Array Element.guidingLightEffect == 0));
			Create Effect(All Players(All Teams), Good Aura, Color(Yellow), Evaluate Once(Global.targetPlayer), 2,
				Visible To Position and Radius);
			Global.targetPlayer.guidingLightEffect = Last Created Entity;
		End;
		Global.randomRoll = Random Real(0, 100);
		If(Global.randomRoll <= (4 + Global.roomsSinceLastEvent * 0.100 + Global.teamLuck) * Workshop Setting Real(Custom String(
			"random events"), Custom String("event chance rate"), 1, 0, 10, 0) && (!Global.eventOccured || Workshop Setting Toggle(
			Custom String("random events"), Custom String("allow multiple events per floor"), False, 4)));
			Global.challengeModifier = 0;
			If(Global.roomsSinceLastEvent > 32767);
				Global.eventType = 3;
				Global.eventKills = 0;
			Else;
				Global.temp = Empty Array;
				If(Workshop Setting Toggle(Custom String("random events"), Custom String("enable alex event"), True, 1));
					Modify Global Variable(temp, Append To Array, 1);
				End;
				If(Workshop Setting Toggle(Custom String("random events"), Custom String("enable madeline event"), True, 2));
					Modify Global Variable(temp, Append To Array, 2);
				End;
				If(Workshop Setting Toggle(Custom String("random events"), Custom String("enable yae miko event"), True, 3));
					Modify Global Variable(temp, Append To Array, 3);
				End;
				If(Count Of(Global.temp) != 0);
					Global.eventType = Random Value In Array(Global.temp);
					Global.eventKills = 0;
				End;
			End;
			Global.isEventActive = True;
			Global.roomsSinceLastEvent = 0;
		Else;
			Call Subroutine(GuestSpawns);
			For Global Variable(loopCounter3, 0, Min(Random Integer(2, 4) + (Global.currentRoom == 4 ? 1 : 0) + Number Of Players(Team 1), 8),
				1);
				Create Dummy Bot(Global.enemySpawnPool, Team 2, -1, Vector(Random Real(-18, 18), 0, Random Real(-18, 18)), Vector(0, 0, 0));
				Wait(0.750, Ignore Condition);
				Wait Until(Server Load <= 180, 1);
			End;
			Global.roomsSinceLastEvent += 1;
		End;
	}
}

rule("destroy bots on death")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	actions
	{
		Wait(1.500, Ignore Condition);
		If(Event Player.eliteIndex != 0);
			Global.roomEliteCount -= 1;
		End;
		Destroy Dummy Bot(Team 2, Slot Of(Event Player));
	}
}

rule("[changed:p] room cleared")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.battleInProgress == True;
		Number Of Players(Team 2) == 0;
		Global.isEventActive == False;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Global.challengeModifier = 0;
		If(Global.currentRoom == 4);
			Global.newItemPos = Vector(0, 1, 0);
			Call Subroutine(SpawnItem);
		End;
		Call Subroutine(EvaluateHallChance);
		All Players(Team 1).recoveryProgress = 420;
		If(Global.currentRoom == 5);
			For Global Variable(loopCounter4, 0, Number Of Players(Team 1) + 2 * Global.torchDifficulty, 1);
				Global.newItemPos = Direction From Angles(360 / (Number Of Players(Team 1) + 2 * Global.torchDifficulty) * Global.loopCounter4, 0)
					* 12 + Vector(0, 0.600, 0);
				Call Subroutine(SpawnItem);
				Wait(0.250, Ignore Condition);
			End;
			Wait(0.500, Ignore Condition);
			Global.randomRoll = Random Real(0, 100);
			If(Global.floorNumber > 0 && Global.randomRoll <= (Global.deathsThisFloor == 0 ? 100 : (Global.deathsThisRoom == 0 ? 36 : 1))
				* 0.500 ^ Global.specialHallCooldown + Last Of(Sorted Array(All Players(Team 1),
				Current Array Element.transformationItemCount)).transformationItemCount * 25);
				"guaranteed white hall after skipping first black hall"
				If(Global.guaranteedWhiteHall || Is True For Any(All Players(Team 1),
					Current Array Element.playerRole == 0 && Current Array Element.transformationItemCount >= 3));
					Global.specialHallType = 2;
					Global.guaranteedWhiteHall = False;
				"always black hall on floor 1"
				Else If(Global.floorNumber == 1 || Global.usedBlackHall || Is True For Any(All Players(Team 1),
						Current Array Element.playerRole == 1 && Current Array Element.transformationItemCount >= 3));
					Global.specialHallType = 1;
				Else;
					Global.specialHallType = Random Integer(1, 2);
				End;
				Global.specialHallCooldown = 3;
				If(Global.specialHallType == 2);
					Small Message(Filtered Array(All Players(Team 1),
						Current Array Element.playerRole == 0 && Current Array Element.transformationItemCount >= 3), Custom String(
						"a faint glow is calling for you..."));
					Create Effect(Filtered Array(All Players(All Teams), !Global.battleInProgress), Ring, Color(White), Vector(0, 0, 8), 5,
						Visible To Position and Radius);
					Global.shopEffects = Array(Last Created Entity);
					Create In-World Text(Filtered Array(All Players(All Teams), !Global.battleInProgress), Custom String("enter the white hall"),
						Vector(0, 2, 8), 1.600, Clip Against Surfaces, Visible To Position and String, Color(White), Default Visibility);
					Modify Global Variable(shopEffects, Append To Array, Last Text ID);
				Else If(Global.specialHallType == 1);
					Small Message(Filtered Array(All Players(Team 1),
						Current Array Element.playerRole == 1 && Current Array Element.transformationItemCount >= 3), Custom String(
						"the infernal power is calling for you..."));
					Create Effect(Filtered Array(All Players(All Teams), !Global.battleInProgress), Ring, Color(Black), Vector(0, 0, 8), 5,
						Visible To Position and Radius);
					Global.shopEffects = Array(Last Created Entity);
					Create In-World Text(Filtered Array(All Players(All Teams), !Global.battleInProgress), Custom String("enter the black hall"),
						Vector(0, 2, 8), 1.600, Clip Against Surfaces, Visible To Position and String, Color(Black), Default Visibility);
					Modify Global Variable(shopEffects, Append To Array, Last Text ID);
				End;
			End;
			If(Global.floorNumber == 6 && Total Time Elapsed <= 3600);
				Global.bossRushCounter = 0;
				Create Effect(Filtered Array(All Players(All Teams), !Global.battleInProgress && Global.bossRushCounter == 0), Ring, Color(Red),
					Vector(0, 0, -8), 5, Visible To Position and Radius);
				Modify Global Variable(shopEffects, Append To Array, Last Created Entity);
				Create In-World Text(Filtered Array(All Players(All Teams), !Global.battleInProgress && Global.bossRushCounter == 0),
					Custom String("enter the hall of legends"), Vector(0, 2, -8), 1.600, Clip Against Surfaces, Visible To Position and String,
					Color(Red), Default Visibility);
				Modify Global Variable(shopEffects, Append To Array, Last Text ID);
			End;
		End;
		If(Global.currentRoom != 12 && Global.currentRoom != 8);
			Global.temp = Global.roomType[Global.roomPositionX];
			Global.temp[Global.roomPositionY] = Global.currentRoom == 5 ? 8 : 0;
			Global.roomType[Global.roomPositionX] = Global.temp;
			Global.currentRoom = Global.currentRoom == 5 ? 8 : 0;
			If(Global.floorNumber == 6 && Total Time Elapsed < 3600);
				Global.temp = 0;
			End;
		End;
		Global.battleInProgress = False;
		Small Message(All Players(All Teams), Custom String("room cleared"));
		Respawn(All Players(Team 1));
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Stop Chasing Player Variable(All Players(Team 1), ultimateAmount);
		Global.roomEliteCount = 0;
		Stop Camera(All Players(All Teams));
		Clear Status(All Players(Team 1), Phased Out);
		Stop Facing(All Players(All Teams));
		Stop Throttle In Direction(All Players(All Teams));
		All Players(All Teams).playerPossessed = False;
		Filtered Array(All Players(Team 1), Current Array Element.playerBlackBlood > 0).playerBlackBlood -= 1;
		Filtered Array(All Players(Team 1),
			Current Array Element.playerRole == 1 && Current Array Element.playerUniqueItems[1] == 3 && Current Array Element.playerBlackBlood < 50)
			.playerBlackBlood += 3;
		Start Camera(Filtered Array(All Players(Team 1), Current Array Element.thirdPersonOn), Update Every Frame(Ray Cast Hit Position(
			Eye Position(Local Player), Eye Position(Local Player) + Facing Direction Of(Local Player) * -4, All Players(All Teams),
			Local Player, False)), Update Every Frame(Eye Position(Local Player)), 0);
		Global.temp = First Of(Filtered Array(All Players(Team 1), Current Array Element.isGuest));
		If(Global.temp != Null && Global.temp != 0);
			Global.randomRoll = Random Real(0, 1);
			If(Global.randomRoll <= 0.100 * Global.teamLuck);
				Global.newItemSlot = Random Integer(1, 4);
				Global.newItemPos = Vector(0, 0, 0);
				Global.newItemSubtype = Array Contains(All Tank Heroes, Hero Of(Global.temp)) ? 2 : (Array Contains(All Support Heroes, Hero Of(
					Global.temp)) ? 0 : 1);
				Global.uniqueItemSpawn = True;
				Global.itemUniqueID = Global.temp.playerUniqueItems[Global.newItemSlot];
				Call Subroutine(SpawnItemForSlot);
				Small Message(All Players(All Teams), Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(Global.temp)),
					Global.guestData[Global.temp.guestID][0], Global.temp.guestVoiceLines[5]));
				Communicate(Global.temp, You are Welcome);
				Wait(2, Ignore Condition);
			End;
			Small Message(All Players(All Teams), Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(Global.temp)),
				Global.guestData[Global.temp.guestID][0], Global.temp.guestVoiceLines[4]));
			Communicate(Global.temp, Goodbye);
			Wait(1, Ignore Condition);
			Destroy Dummy Bot(Team 1, 5);
		End;
	}
}

rule("[changed:p]movement, facing and stats")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	actions
	{
		Set Max Health(Event Player, 8 * Workshop Setting Real(Custom String("match settings"), Custom String("enemy damage rate"), 1,
			0.100, 5, 1) * (0.700 + Global.torchDifficulty * 0.200) * (0.750 + (Number Of Players(Team 1) - 1) * 0.250)
			* 1.500 ^ Global.floorNumber);
		Set Damage Dealt(Event Player, 3 * Workshop Setting Real(Custom String("match settings"), Custom String("enemy health rate"), 1,
			0.100, 5, 2) * (0.700 + Global.torchDifficulty * 0.200) * (0.750 + (Number Of Players(Team 1) - 1) * 0.250) * (
			1.450 + Global.floorNumber * 0.010) ^ Global.floorNumber);
		Set Damage Received(Event Player, 75);
		If(Event Player.isBoss);
			"[changed:p] Adjust boss difficulty"
			Set Damage Received(Event Player, 15);
			Start Damage Modification(All Players(Team 1), Event Player, 160, Receivers Damagers and Damage Percent);
			Add Health Pool To Player(Event Player, Health, Max Health(Event Player) * (1 + Number Of Players(Team 1) * 3.500), True, False);
			Start Scaling Player(Event Player, 3, False);
			Start Modifying Hero Voice Lines(Event Player, 0.500, False);
		End;
		"enemies start attacking 1 second after appearing"
		Wait(1, Ignore Condition);
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Position Of(Event Player.aiTarget) + Vector(0, 0.800, 0)),
			360, To World, Direction and Turn Rate);
		Start Throttle In Direction(Event Player, Direction Towards(Event Player, Event Player.aiTarget), 1, To World,
			Replace existing throttle, Direction and Magnitude);
		If(Event Player.isBoss);
			Create Progress Bar In-World Text(All Players(All Teams), Normalized Health(Event Player) * 100, Custom String("{1}boss {0}",
				Hero Of(Event Player), Event Player.eliteIndex != 0 ? Custom String("{0} ", Global.eliteNames[Event Player.eliteIndex - 1])
				: Custom String("")), Event Player, 1, Clip Against Surfaces, Color(Red), Color(White), Visible To Position Values and Color,
				Default Visibility);
		End;
	}
}

rule("targeting")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is Alive(Event Player) == True;
	}

	actions
	{
		Event Player.aiTarget = First Of(Sorted Array(Filtered Array(All Living Players(Team 1), Has Spawned(Current Array Element)
			&& !Current Array Element.isDowned), Distance Between(Current Array Element, Event Player)));
		Wait(Min(0.500, Server Load / 200), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("general primary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Primary Fire)) == 0;
		Array Contains(Array(Hero(Kiriko), Hero(Moira)), Hero Of(Event Player)) == False;
		(!Has Status(Event Player, Hacked) || (Has Status(Event Player, Hacked) && Event Player.isBoss)) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
		Wait(Random Real(2, 3), Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("[changed:p] general secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
		Array Contains(Array(Hero(Bastion), Hero(Reinhardt), Hero(Pharah), Hero(Brigitte)), Hero Of(Event Player)) == False;
		(Event Player.isBoss || (!Event Player.isBoss && !Has Status(Event Player, Hacked))) == True;
	}

	actions
	{
		Wait(Random Real(1, 2), Ignore Condition);
		Start Holding Button(Event Player, Button(Secondary Fire));
		Wait(Random Real(2, 3), Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Secondary Fire));
	}
}

rule("general ab1")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		(Ability Cooldown(Event Player, Button(Ability 1)) == 0 || Ability Charge(Event Player, Button(Ability 1)) > 0) == True;
		Hero Of(Event Player) != Hero(Bastion);
		(Event Player.isBoss || (!Event Player.isBoss && !Has Status(Event Player, Hacked))) == True;
	}

	actions
	{
		Wait(Random Real(1, 2), Ignore Condition);
		Start Holding Button(Event Player, Button(Ability 1));
		Wait(Random Real(2, 3), Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Ability 1));
	}
}

rule("general ab2")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		(Ability Cooldown(Event Player, Button(Ability 2)) == 0 || Ability Charge(Event Player, Button(Ability 2)) > 0) == True;
		(Event Player.isBoss || (!Event Player.isBoss && !Has Status(Event Player, Hacked))) == True;
	}

	actions
	{
		Wait(Random Real(1, 2), Ignore Condition);
		Start Holding Button(Event Player, Button(Ability 2));
		Wait(Random Real(2, 3), Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Ability 2));
	}
}

rule("[changed:p] RecalculateStats")
{
	event
	{
		Subroutine;
		RecalculateStats;
	}

	actions
	{
		Remove All Health Pools From Player(Event Player);
		If(Event Player.uniqueHero || Event Player.ChoseToBeDevil);
			Event Player.statCooldown = 100 - 100 * 0.920 ^ Global.floorNumber;
			Event Player.statMoveSpeed = 100;
			Event Player.statDamage = (
				Event Player.playerRole == 1 ? 100 + Event Player.weaponPower + Global.floorNumber * 66 : 80 + Global.floorNumber * 55)
				* 1.050 ^ Global.floorNumber;
			Event Player.statCriticalChance = 10 + Global.floorNumber * 10;
			Event Player.statCriticalPower = 150 + Global.floorNumber * 30 * 1.050 ^ Global.floorNumber;
			Event Player.statHealth = (
				Event Player.playerRole == 2 ? 200 + Event Player.weaponPower + Global.floorNumber * 225 : 100 + Global.floorNumber * 125)
				* 1.050 ^ Global.floorNumber;
			Event Player.statDefense = 100 - 100 * 0.920 ^ Global.floorNumber;
			Event Player.statDodgeChance = 60 - 60 * 0.940 ^ Global.floorNumber;
			Event Player.statHealing = (
				Event Player.playerRole == 0 ? 100 + Event Player.weaponPower + Global.floorNumber * 110 : 100 + Global.floorNumber * 80)
				* 1.050 ^ Global.floorNumber;
		Else;
			Event Player.statCooldown = 0;
			Event Player.statMoveSpeed = 100;
			Event Player.statDodgeChance = 5;
			Event Player.statDamage = 100 + Event Player.weaponPower;
			Event Player.statCriticalChance = 10;
			Event Player.statCriticalPower = 150;
			Event Player.statHealth = 100 + Event Player.bodyPower;
			Event Player.statDefense = Event Player.legsPower;
			Event Player.statHealing = 100 + Event Player.headPower;
			Set Jump Vertical Speed(Event Player, 100);
			If(Event Player.specialGemstoneType == 0);
				Event Player.statDamage += Event Player.specialPower;
			Else If(Event Player.specialGemstoneType == 1);
				Event Player.statCriticalChance += Event Player.specialPower;
			Else If(Event Player.specialGemstoneType == 2);
				Event Player.statHealing += Event Player.specialPower;
			Else If(Event Player.specialGemstoneType == 3);
				Event Player.statHealth += Event Player.specialPower;
			Else If(Event Player.specialGemstoneType == 4);
				Event Player.statCooldown += Event Player.specialPower;
			Else If(Event Player.specialGemstoneType == 5);
				Event Player.statDefense += (100 - Min(100, Event Player.statDefense)) * (Event Player.specialPower / 100);
			Else If(Event Player.specialGemstoneType == 6);
				Event Player.statCriticalPower += Event Player.specialPower;
			Else If(Event Player.specialGemstoneType == 7);
				Event Player.statDodgeChance += (60 - Min(60, Event Player.statDodgeChance)) * (Event Player.specialPower / 60);
			End;
			Wait(0.100, Ignore Condition);
			If(Array Contains(Event Player.weaponProperties[0], 0));
				Event Player.statCriticalChance += Event Player.weaponProperties[1][Index Of Array Value(Event Player.weaponProperties[0], 0)];
			End;
			If(Array Contains(Event Player.weaponProperties[0], 1));
				Event Player.statCriticalPower *= 1 + Event Player.weaponProperties[1][Index Of Array Value(Event Player.weaponProperties[0], 1)
					] / 100;
			End;
			If(Array Contains(Event Player.weaponProperties[0], 2));
				Event Player.statCooldown += (100 - Event Player.statCooldown) * (Event Player.weaponProperties[1][Index Of Array Value(
					Event Player.weaponProperties[0], 2)] / 100);
			End;
			If(Array Contains(Event Player.weaponProperties[0], 3));
				Set Max Ammo(Event Player, 0, Event Player.maxAmmo[0] * (1 + Event Player.weaponProperties[1][Index Of Array Value(
					Event Player.weaponProperties[0], 3)] / 100));
				Set Max Ammo(Event Player, 1, Event Player.maxAmmo[1] * (1 + Event Player.weaponProperties[1][Index Of Array Value(
					Event Player.weaponProperties[0], 3)] / 100));
			Else;
				Set Max Ammo(Event Player, 0, Event Player.maxAmmo[0]);
				Set Max Ammo(Event Player, 1, Event Player.maxAmmo[1]);
			End;
			If(Array Contains(Event Player.bodyProperties[0], 0));
				Event Player.statDefense += (100 - Min(100, Event Player.statDefense)) * (Event Player.bodyProperties[1][Index Of Array Value(
					Event Player.bodyProperties[0], 0)] / 100);
			End;
			If(Array Contains(Event Player.bodyProperties[0], 1));
				Event Player.statHealing *= 1 + Event Player.bodyProperties[1][Index Of Array Value(Event Player.bodyProperties[0], 1)] / 100;
			End;
			If(Array Contains(Event Player.headProperties[0], 0));
				Event Player.statCriticalPower *= 1 + Event Player.headProperties[1][Index Of Array Value(Event Player.headProperties[0], 0)
					] / 100;
			End;
			If(Array Contains(Event Player.headProperties[0], 1));
				Event Player.statCooldown += (100 - Event Player.statCooldown) * (Event Player.headProperties[1][Index Of Array Value(
					Event Player.headProperties[0], 1)] / 100);
			End;
			If(Array Contains(Event Player.headProperties[0], 3));
				Set Healing Received(Event Player, 100 + Event Player.headProperties[1][Index Of Array Value(Event Player.headProperties[0], 3)]);
			Else;
				Set Healing Received(Event Player, 100);
			End;
			If(Array Contains(Event Player.headProperties[0], 4));
				Event Player.statCriticalChance += Event Player.headProperties[1][Index Of Array Value(Event Player.headProperties[0], 4)];
			End;
			If(Array Contains(Event Player.legsProperties[0], 0));
				Event Player.statMoveSpeed += Event Player.legsProperties[1][Index Of Array Value(Event Player.legsProperties[0], 0)];
			End;
			If(Array Contains(Event Player.legsProperties[0], 1));
				Event Player.statHealth *= 1 + Event Player.legsProperties[1][Index Of Array Value(Event Player.legsProperties[0], 1)] / 100;
			End;
			If(Array Contains(Event Player.legsProperties[0], 2));
				Event Player.statDamage *= 1 + Event Player.legsProperties[1][Index Of Array Value(Event Player.legsProperties[0], 2)] / 100;
			End;
			If(Array Contains(Event Player.legsProperties[0], 3));
				Event Player.statCooldown += (100 - Event Player.statCooldown) * (Event Player.legsProperties[1][Index Of Array Value(
					Event Player.legsProperties[0], 3)] / 100);
			End;
			If(Array Contains(Event Player.legsProperties[0], 4));
				Event Player.statDodgeChance += (60 - Event Player.statDodgeChance) * (Event Player.legsProperties[1][Index Of Array Value(
					Event Player.legsProperties[0], 4)] / 100);
			End;
			If(Array Contains(Event Player.specialProperties[0], 0));
				Event Player.statHealing *= 1 + Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 0)
					] / 100;
				Event Player.statHealth *= 1 + Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 0)] / 100;
			End;
			If(Array Contains(Event Player.specialProperties[0], 1));
				Event Player.statCooldown += (100 - Min(100, Event Player.statCooldown)) * (Event Player.specialProperties[1][Index Of Array Value(
					Event Player.specialProperties[0], 1)] / 100);
				Event Player.statDamage *= 1 + Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 1)] / 100;
			End;
			If(Array Contains(Event Player.specialProperties[0], 2));
				Event Player.statCriticalChance += Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 2)];
				Event Player.statCriticalPower *= 1 + Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 2)
					] / 100;
			End;
			If(Array Contains(Event Player.specialProperties[0], 4));
				Event Player.statDefense += (100 - Min(100, Event Player.statDefense)) * (Event Player.specialProperties[1][Index Of Array Value(
					Event Player.specialProperties[0], 4)] / 100);
				Event Player.statDodgeChance += (60 - Min(60, Event Player.statDodgeChance)) * (
					Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 4)] / 600);
			End;
			If(Event Player.playerUniqueItems[1] == 1 && Event Player.playerRole == 1);
				Event Player.statDamage *= 2;
				Event Player.statDefense -= 50;
			End;
			If(Event Player.playerUniqueItems[1] == 2 && Event Player.playerRole == 1);
				Event Player.statHealth *= 1.500;
			End;
			If(Event Player.playerUniqueItems[2] == 2 && Event Player.playerRole == 1);
				Event Player.statHealth *= 1.500;
				Event Player.statDamage *= 1.500;
				Event Player.statCriticalPower *= 1.500;
				Event Player.statCriticalChance += 50;
			End;
			If(Event Player.playerUniqueItems[2] == 2 && Event Player.playerRole == 2);
				Event Player.statDodgeChance += 25;
			End;
			If(Event Player.playerUniqueItems[3] == 1 && Event Player.playerRole == 0);
				Event Player.statMoveSpeed += 30;
			End;
			If(Event Player.playerUniqueItems[3] == 2 && Event Player.playerRole == 1);
				Event Player.statMoveSpeed += 50;
			End;
			If(Event Player.playerUniqueItems[3] == 1 && Event Player.playerRole == 2);
				Set Jump Vertical Speed(Event Player, 225);
			End;
			If(Event Player.playerUniqueItems[1] == 3 && Event Player.playerRole == 1);
				Event Player.statDamage *= 1 + Event Player.playerBlackBlood / 40;
			End;
			If(Event Player.playerUniqueItems[1] == 4 && Event Player.playerRole == 1);
				Event Player.statDamage *= 1.250;
				Event Player.statHealth *= 1.250;
				Event Player.statHealing *= 1.250;
				Event Player.statDefense += (100 - Min(100, Event Player.statDefense)) * 0.250;
				Event Player.statCooldown += (100 - Min(100, Event Player.statCooldown)) * 0.250;
				Event Player.statDodgeChance += (60 - Min(60, Event Player.statDodgeChance)) * 0.250;
				Event Player.statCriticalPower *= 1.250;
				Event Player.statCriticalChance += 25;
			End;
			If(Event Player.playerUniqueItems[4] == 10);
				Event Player.statDamage *= 1.250;
				Event Player.statHealth *= 1.250;
				Event Player.statDefense += (100 - Min(100, Event Player.statDefense)) * 0.250;
				Event Player.statCriticalPower *= 1.250;
			End;
			If(Event Player.playerUniqueItems[3] == 2 && Event Player.playerRole == 2);
				Event Player.statMoveSpeed /= 2;
				Event Player.statHealth *= 2;
				Event Player.statDefense += (100 - Min(100, Event Player.statDefense)) * 0.250;
			End;
			If(Event Player.playerUniqueItems[3] == 3 && Event Player.playerRole == 1);
				Event Player.statMoveSpeed += 2.500 * (Global.floorMapSize ^ 2 - Count Of(Global.unvisitedRooms));
				Event Player.statDefense += (100 - Min(100, Event Player.statDefense)) * (Global.floorMapSize ^ 2 - Count Of(
					Global.unvisitedRooms)) * 0.010;
			End;
			If(Hero Of(Event Player) == Hero(Widowmaker));
				Event Player.statCriticalPower *= 1 + Event Player.statCriticalChance / 50;
				Event Player.statCriticalChance = 0;
			End;
			If(Hero Of(Event Player) == Hero(Mercy));
				Event Player.statHealing += Event Player.statDamage - 100;
			End;
		End;
		If(Event Player.statCriticalChance > 100);
			Event Player.statCriticalPower += Event Player.statCriticalChance - 100;
			Event Player.statCriticalChance = 100;
		End;
		Set Damage Dealt(Event Player, Event Player.statDamage);
		If(Event Player.playerBlackBlood < 0);
			Event Player.playerBlackBlood = 0;
		End;
		Wait(0.100, Ignore Condition);
		If(!(Event Player.uniqueHero && Event Player.playerRole == 1));
			Set Max Health(Event Player, Event Player.statHealth * ((100 - Event Player.playerBlackBlood) / 100));
		Else;
			"Dib is immune to Black Blood"
			Set Max Health(Event Player, Event Player.statHealth);
		End;
		If(Event Player.statDefense > 95);
			Event Player.statDefense = 95;
		End;
		Set Damage Received(Event Player, Max(0, 100 - Event Player.statDefense));
		Set Healing Dealt(Event Player, Event Player.statHealing);
		Set Move Speed(Event Player, Event Player.statMoveSpeed);
		If(Array Contains(Event Player.bodyProperties[0], 3));
			Add Health Pool To Player(Event Player, Armor, Max Health(Event Player)
				* 0.010 * Event Player.bodyProperties[1][Index Of Array Value(Event Player.bodyProperties[0], 3)], True, False);
		End;
		If(Array Contains(Event Player.headProperties[0], 2));
			Add Health Pool To Player(Event Player, Shields, Max Health(Event Player)
				* 0.010 * Event Player.headProperties[1][Index Of Array Value(Event Player.headProperties[0], 2)], True, False);
		End;
		If(Event Player.playerUniqueItems[1] == 2 && Event Player.playerRole == 1);
			Add Health Pool To Player(Event Player, Shields, Max Health(Event Player), True, False);
			Wait(0.100, Ignore Condition);
			Set Max Health(Event Player, 0.001);
		End;
		Wait(0.100, Ignore Condition);
		If(Hero Of(Event Player) == Hero(Reinhardt));
			Set Knockback Received(Event Player, 0);
		Else;
			If(Array Contains(Event Player.bodyProperties[0], 4));
				Set Knockback Received(Event Player, 100 - Event Player.bodyProperties[1][Index Of Array Value(Event Player.bodyProperties[0], 4)
					]);
			Else;
				Set Knockback Received(Event Player, 100);
			End;
		End;
		Set Knockback Dealt(Event Player, Event Player.uniqueHero && Event Player.playerRole == 2 ? 400 : 100);
		Global.saveBlackBlood[Slot Of(Event Player)] = Event Player.playerBlackBlood;
		Event Player.transformationItemCount = 0;
		If(Event Player.playerRole == 0);
			Event Player.transformationItemCount += Array Contains(Array(4), Event Player.playerUniqueItems[1]) ? 1 : 0;
			Event Player.transformationItemCount += Array Contains(Array(1), Event Player.playerUniqueItems[2]) ? 1 : 0;
			Event Player.transformationItemCount += Array Contains(Array(3, 4), Event Player.playerUniqueItems[3]) ? 1 : 0;
			Event Player.transformationItemCount += Array Contains(Array(3, 11, 14), Event Player.playerUniqueItems[4]) ? 1 : 0;
		Else If(Event Player.playerRole == 1);
			Event Player.transformationItemCount += Array Contains(Array(3), Event Player.playerUniqueItems[1]) ? 1 : 0;
			Event Player.transformationItemCount += Array Contains(Array(2), Event Player.playerUniqueItems[2]) ? 1 : 0;
			Event Player.transformationItemCount += Array Contains(Array(1, 4), Event Player.playerUniqueItems[3]) ? 1 : 0;
			Event Player.transformationItemCount += Array Contains(Array(9, 10, 15), Event Player.playerUniqueItems[4]) ? 1 : 0;
		End;
		If(Event Player.uniqueHero);
			Set Secondary Fire Enabled(Event Player, False);
			Set Ability 1 Enabled(Event Player, False);
			Set Ability 2 Enabled(Event Player, False);
			Set Ultimate Ability Enabled(Event Player, False);
		End;
		If(Event Player.potionUses > Event Player.potionMaxUses);
			Event Player.potionUses = Event Player.potionMaxUses;
		End;
		If(!Global.battleInProgress || Event Player.isGuest);
			Heal(Event Player, Null, Max Health(Event Player));
		End;
		If(Hero Of(Event Player) == Hero(Doomfist));
			Add Health Pool To Player(Event Player, Armor, 75 * (Event Player.statHealth / 100), True, True);
		End;
	}
}

rule("cooldown for primary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Primary Fire)) > 0;
		Hero Of(Event Player) != Hero(Moira);
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Primary Fire), Ability Cooldown(Event Player, Button(Primary Fire)) * (
			1 - Event Player.statCooldown * 0.010) * (Global.challengeModifier == 2 ? 2.500 : 1));
		If(Event Player.playerUniqueItems[4] == 5);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= 50);
				Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
			End;
		End;
	}
}

rule("cooldown for secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Secondary Fire)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Secondary Fire), Ability Cooldown(Event Player, Button(Secondary Fire)) * (
			1 - Event Player.statCooldown * 0.010) * (Global.challengeModifier == 2 ? 2.500 : 1));
		If(Event Player.playerUniqueItems[4] == 5);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= 50);
				Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
			End;
		End;
	}
}

rule("cooldown for ab1")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 1)) > 0;
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 1), Ability Cooldown(Event Player, Button(Ability 1)) * (
			1 - Event Player.statCooldown * 0.010) * (Global.challengeModifier == 2 ? 2.500 : 1));
		If(Event Player.playerUniqueItems[4] == 5);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= 50);
				Set Ability Cooldown(Event Player, Button(Ability 1), 0);
				Set Ability Charge(Event Player, Button(Ability 1), Ability Charge(Event Player, Button(Ability 1)) + 1);
			End;
		End;
	}
}

rule("cooldown for ab2")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 2)) > 0;
		Hero Of(Event Player) != Hero(Baptiste);
	}

	actions
	{
		Set Ability Cooldown(Event Player, Button(Ability 2), Ability Cooldown(Event Player, Button(Ability 2)) * (
			1 - Event Player.statCooldown * 0.010) * (Global.challengeModifier == 2 ? 2.500 : 1));
		If(Event Player.playerUniqueItems[4] == 5);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= 50);
				Set Ability Cooldown(Event Player, Button(Ability 2), 0);
				Set Ability Charge(Event Player, Button(Ability 2), Ability Charge(Event Player, Button(Ability 2)) + 1);
			End;
		End;
	}
}

rule("crit & damage text")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Victim != Event Player;
		Event Ability != Null;
	}

	actions
	{
		If(Event Player.damageText != 0);
			Destroy In-World Text(Event Player.damageText);
		End;
		Event Player.randomRoll = Random Real(0, 100);
		If(Event Player.playerUniqueItems[4] == 7 && Event Player.randomRoll <= 2 && !Victim.isBoss);
			Clear Status(Victim, Phased Out);
			Clear Status(Victim, Unkillable);
			Kill(Victim, Event Player);
			Create In-World Text(Event Player, Custom String("∞"), Update Every Frame(Eye Position(Victim) + Evaluate Once(Vector(Random Real(
				-0.500, 0.500), Random Real(-0.500, 0.500), Random Real(-0.500, 0.500))) + Vector(0, (1 - Event Player.damageTextTimer)
				* 2 - 1, 0)), 6, Do Not Clip, Visible To Position and Color, Color(Black), Default Visibility);
			Event Player.damageText = Last Text ID;
			Event Player.damageTextTimer = 1;
			Abort;
		End;
		Event Player.isCritical = (Hero Of(Event Player) == Hero(Widowmaker) && Event Was Critical Hit) || (
			Event Player.randomRoll <= Event Player.statCriticalChance) || Is True For Any(Players On Hero(Hero(Widowmaker), Team 1),
			Is Using Ultimate(Current Array Element)) || (Event Player.potionType == 5 && Event Player.potionTimeLeft > 0);
		Create In-World Text(Event Player, Custom String("{0}", Round To Integer(Event Damage, Up)), Eye Position(Victim) + Evaluate Once(
			Vector(Random Real(-0.500, 0.500), Random Real(-0.500, 0.500), Random Real(-0.500, 0.500))) + Vector(0, (
			1 - Event Player.damageTextTimer) * 2 - 1, 0), 2.500, Do Not Clip, Visible To Position and Color, Event Player.isCritical ? (
			Event Was Critical Hit ? Color(Orange) : Color(Yellow)) : (Event Was Critical Hit ? Color(Red) : Color(White)),
			Default Visibility);
		Event Player.damageText = Last Text ID;
		Event Player.damageTextTimer = 1;
		Wait(0.100, Ignore Condition);
	}
}

rule("[changed:q]SpawnItem - rewrite")
{
	event
	{
		Subroutine;
		SpawnItem;
	}

	actions
	{
		Global.newItemSlot = Random Integer(0, 4);
		If(Global.newItemSlot == 0);
			Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Random Value In Array(Filtered Array(All Players(
				Team 1), !Is Dummy Bot(Current Array Element)))));
		Else If(Global.newItemSlot == 4);
			Global.newItemSubtype = Random Integer(0, 7);
		Else;
			Global.newItemSubtype = Random Value In Array(Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element)))
				.playerRole;
		End;
		Call Subroutine(SpawnItemForSlot);
	}
}

rule("[changed:p]item drops")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Team Of(Victim) == Team 2;
	}

	actions
	{
		If(!Is Dummy Bot(Event Player));
			Global.teamGold += Round To Integer(Victim.eliteIndex != 0 ? Random Real(5, 8) : Random Real(1, 2) * (Global.teamLuck / 3 + 1),
				Down);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= (Victim.eliteIndex != 0 ? 15 : 4 * (Global.teamLuck / 4 + 1)));
				Play Effect(All Players(All Teams), Buff Explosion Sound, Color(White), Position Of(Event Player), 150);
				Global.newItemPos = Nearest Walkable Position(Position Of(Victim)) + Vector(0, 0.600, 0);
				Call Subroutine(SpawnItem);
			End;
			If(Global.isEventActive);
				Global.eventKills += 1;
			End;
		End;
		If(Event Player.isGuest);
			Small Message(All Players(All Teams), Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(Event Player)),
				Global.guestData[Event Player.guestID][0], Event Player.guestVoiceLines[1]));
		End;
		Wait(0.500, Ignore Condition);
	}
}

rule("[changed:q]pick up an item")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is True For Any(Global.itemPositions, Distance Between(Current Array Element, Event Player)
			<= 2 && Global.itemSlots[Current Array Index] != -1) == True;
	}

	actions
	{
		If(Event Player.uniqueHero);
			Small Message(Event Player, Custom String("{0} you can't equip normal items anymore.", Icon String(No)));
			Abort;
		End;
		If(Global.lockedItems);
			Small Message(Event Player, Custom String("hold [{0}] to buy", Input Binding String(Button(Interact))));
			Wait(1, Abort When False);
		End;
		Event Player.itemIndex = Index Of Array Value(Global.itemPositions, First Of(Sorted Array(Filtered Array(Global.itemPositions,
			Global.itemSlots[Current Array Index] != -1), Distance Between(Current Array Element, Event Player))));
		Event Player.itemSlot = Global.itemSlots[Event Player.itemIndex];
		"[changed:q] only check once"
		If(Event Player.itemSlot == 0 && Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Event Player))
			!= Global.itemSubtypes[Event Player.itemIndex]);
			"[changed:q] only check once"
			If(Global.activeCurse == 3);
				Small Message(Event Player, Custom String("{0} You feel like you can't equip that item...", Icon String(No)));
				Abort;
			End;
			Small Message(Event Player, Custom String("{0} Only {1} can equip this.", Icon String(No),
				Global.heroWeaponNames[0][Global.itemSubtypes[Event Player.itemIndex]]));
			Abort;
		Else If(Event Player.itemSlot >= 1 && Event Player.itemSlot <= 3 && ((Array Contains(All Tank Heroes, Hero Of(Event Player))
				&& Global.itemSubtypes[Event Player.itemIndex] != 2) || (Array Contains(All Damage Heroes, Hero Of(Event Player))
				&& Global.itemSubtypes[Event Player.itemIndex] != 1) || (Array Contains(All Support Heroes, Hero Of(Event Player))
				&& Global.itemSubtypes[Event Player.itemIndex] != 0)));
			"[changed:q] only check once"
			If(Global.activeCurse == 3);
				Small Message(Event Player, Custom String("{0} You feel like you can't equip that item...", Icon String(No)));
				Abort;
			End;
			If(Global.itemSubtypes[Event Player.itemIndex] == 0);
				Small Message(Event Player, Custom String("{0} Only supports may equip light armor.", Icon String(No)));
			Else If(Global.itemSubtypes[Event Player.itemIndex] == 1);
				Small Message(Event Player, Custom String("{0} Only dps may equip medium armor.", Icon String(No)));
			Else;
				Small Message(Event Player, Custom String("{0} Only tanks may equip heavy armor.", Icon String(No)));
			End;
			Abort;
		Else If(Event Player.itemSlot == 5 && Event Player.potionTimeLeft > 0);
			Small Message(Event Player, Custom String("{0} You must wait before your current potion effect wears off.", Icon String(No)));
			Abort;
		End;
		If(Event Player.itemSlot != -1);
			Event Player.tempSwapValue = Event Player.itemNames[Event Player.itemSlot];
			If(Event Player.tempSwapValue != Custom String("none") && !Global.lockedItems);
				Event Player.itemNames[Event Player.itemSlot] = Global.itemNames[Event Player.itemIndex];
				Global.saveItemNames[Slot Of(Event Player)] = Event Player.itemNames;
				Global.itemNames[Event Player.itemIndex] = Event Player.tempSwapValue;
				Event Player.tempSwapValue = Event Player.itemRarity[Event Player.itemSlot];
				Event Player.itemRarity[Event Player.itemSlot] = Global.itemRarities[Event Player.itemIndex];
				Global.saveItemRarity[Slot Of(Event Player)] = Event Player.itemRarity;
				Global.itemRarities[Event Player.itemIndex] = Event Player.tempSwapValue;
				Event Player.tempSwapValue = Event Player.playerUniqueItems[Event Player.itemSlot];
				Event Player.playerUniqueItems[Event Player.itemSlot] = Global.itemUnique[Event Player.itemIndex];
				Global.itemUnique[Event Player.itemIndex] = Event Player.tempSwapValue;
				Global.saveUniqueItems[Slot Of(Event Player)] = Event Player.playerUniqueItems;
				If(Event Player.itemSlot == 0);
					Event Player.tempSwapValue = Event Player.weaponPower;
					Event Player.weaponPower = Global.itemPowers[Event Player.itemIndex];
					Global.itemPowers[Event Player.itemIndex] = Event Player.tempSwapValue;
					Event Player.tempSwapValue = Event Player.weaponProperties;
					Event Player.weaponProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Event Player.weaponPower, Global.savePowers[Slot Of(Event Player)][1],
						Global.savePowers[Slot Of(Event Player)][2], Global.savePowers[Slot Of(Event Player)][3], Global.savePowers[Slot Of(
						Event Player)][4]);
					Global.saveWeaponProperties[Slot Of(Event Player)] = Event Player.weaponProperties;
				Else If(Event Player.itemSlot == 1);
					Event Player.tempSwapValue = Event Player.bodyPower;
					Event Player.bodyPower = Global.itemPowers[Event Player.itemIndex];
					Global.itemPowers[Event Player.itemIndex] = Event Player.tempSwapValue;
					Event Player.tempSwapValue = Event Player.bodyProperties;
					Event Player.bodyProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Event Player.bodyPower,
						Global.savePowers[Slot Of(Event Player)][2], Global.savePowers[Slot Of(Event Player)][3], Global.savePowers[Slot Of(
						Event Player)][4]);
					Global.saveBodyProperties[Slot Of(Event Player)] = Event Player.bodyProperties;
				Else If(Event Player.itemSlot == 2);
					Event Player.tempSwapValue = Event Player.headPower;
					Event Player.headPower = Global.itemPowers[Event Player.itemIndex];
					Global.itemPowers[Event Player.itemIndex] = Event Player.tempSwapValue;
					Event Player.tempSwapValue = Event Player.headProperties;
					Event Player.headProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Global.savePowers[Slot Of(
						Event Player)][1], Event Player.headPower, Global.savePowers[Slot Of(Event Player)][3], Global.savePowers[Slot Of(Event Player)
						][4]);
					Global.saveHeadProperties[Slot Of(Event Player)] = Event Player.headProperties;
				Else If(Event Player.itemSlot == 3);
					Event Player.tempSwapValue = Event Player.legsPower;
					Event Player.legsPower = Global.itemPowers[Event Player.itemIndex];
					Global.itemPowers[Event Player.itemIndex] = Event Player.tempSwapValue;
					Event Player.tempSwapValue = Event Player.legsProperties;
					Event Player.legsProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Global.savePowers[Slot Of(
						Event Player)][1], Global.savePowers[Slot Of(Event Player)][2], Event Player.legsPower, Global.savePowers[Slot Of(Event Player)
						][4]);
					Global.saveLegsProperties[Slot Of(Event Player)] = Event Player.legsProperties;
				Else If(Event Player.itemSlot == 4);
					Event Player.tempSwapValue = Event Player.specialPower;
					Event Player.specialPower = Global.itemPowers[Event Player.itemIndex];
					Global.itemPowers[Event Player.itemIndex] = Event Player.tempSwapValue;
					Event Player.tempSwapValue = Event Player.specialGemstoneType;
					Event Player.specialGemstoneType = Global.itemSubtypes[Event Player.itemIndex];
					Global.itemSubtypes[Event Player.itemIndex] = Event Player.tempSwapValue;
					Event Player.tempSwapValue = Event Player.specialProperties;
					Event Player.specialProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Global.savePowers[Slot Of(
						Event Player)][1], Global.savePowers[Slot Of(Event Player)][2], Global.savePowers[Slot Of(Event Player)][3],
						Event Player.specialPower);
					Global.saveSpecialProperties[Slot Of(Event Player)] = Event Player.specialProperties;
					Global.saveSpecialGemstoneType[Slot Of(Event Player)] = Event Player.specialGemstoneType;
				Else If(Event Player.itemSlot == 5);
					Event Player.tempSwapValue = Event Player.potionType;
					Event Player.potionType = Global.itemSubtypes[Event Player.itemIndex];
					Global.itemSubtypes[Event Player.itemIndex] = Event Player.tempSwapValue;
					Event Player.potionMaxUses = Event Player.potionType >= 8 ? 1 : 3;
					If(Event Player.potionUses > Event Player.potionMaxUses);
						Event Player.potionUses = Event Player.potionMaxUses;
					End;
				End;
				Global.itemProperties[Event Player.itemIndex] = Event Player.tempSwapValue[0];
				Global.itemPropertyValue[Event Player.itemIndex] = Event Player.tempSwapValue[1];
			Else;
				If(Global.lockedItems);
					If(Event Player.playerUniqueItems[4] != 9);
						Event Player.playerBlackBlood += (100 - Event Player.playerBlackBlood) * (
							Global.itemRarities[Event Player.itemIndex] == 8 ? 0.400 : 0.250);
					Else;
						Event Player.deathInjury += Global.itemRarities[Event Player.itemIndex] == 8 ? 4 : 2;
					End;
					Global.usedBlackHall = True;
				End;
				If(Global.itemUnique[Event Player.itemIndex] == 2 && Event Player.playerRole == 1 && Event Player.itemSlot == 2);
					Global.usedBlackHall = True;
				End;
				Event Player.itemNames[Event Player.itemSlot] = Global.itemNames[Event Player.itemIndex];
				Global.saveItemNames[Slot Of(Event Player)] = Event Player.itemNames;
				Event Player.itemRarity[Event Player.itemSlot] = Global.itemRarities[Event Player.itemIndex];
				Global.saveItemRarity[Slot Of(Event Player)] = Event Player.itemRarity;
				Event Player.playerUniqueItems[Event Player.itemSlot] = Global.itemUnique[Event Player.itemIndex];
				Global.saveUniqueItems[Slot Of(Event Player)] = Event Player.playerUniqueItems;
				If(Event Player.itemSlot == 0);
					Event Player.weaponPower = Global.itemPowers[Event Player.itemIndex];
					Event Player.weaponProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Event Player.weaponPower, Global.savePowers[Slot Of(Event Player)][1],
						Global.savePowers[Slot Of(Event Player)][2], Global.savePowers[Slot Of(Event Player)][3], Global.savePowers[Slot Of(
						Event Player)][4]);
					Global.saveWeaponProperties[Slot Of(Event Player)] = Event Player.weaponProperties;
				Else If(Event Player.itemSlot == 1);
					Event Player.bodyPower = Global.itemPowers[Event Player.itemIndex];
					Event Player.bodyProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Event Player.bodyPower,
						Global.savePowers[Slot Of(Event Player)][2], Global.savePowers[Slot Of(Event Player)][3], Global.savePowers[Slot Of(
						Event Player)][4]);
					Global.saveBodyProperties[Slot Of(Event Player)] = Event Player.bodyProperties;
				Else If(Event Player.itemSlot == 2);
					Event Player.headPower = Global.itemPowers[Event Player.itemIndex];
					Event Player.headProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Global.savePowers[Slot Of(
						Event Player)][1], Event Player.headPower, Global.savePowers[Slot Of(Event Player)][3], Global.savePowers[Slot Of(Event Player)
						][4]);
					Global.saveHeadProperties[Slot Of(Event Player)] = Event Player.headProperties;
				Else If(Event Player.itemSlot == 3);
					Event Player.legsPower = Global.itemPowers[Event Player.itemIndex];
					Event Player.legsProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Global.savePowers[Slot Of(
						Event Player)][1], Global.savePowers[Slot Of(Event Player)][2], Event Player.legsPower, Global.savePowers[Slot Of(Event Player)
						][4]);
					Global.saveLegsProperties[Slot Of(Event Player)] = Event Player.legsProperties;
				Else If(Event Player.itemSlot == 4);
					Event Player.specialPower = Global.itemPowers[Event Player.itemIndex];
					Event Player.specialGemstoneType = Global.itemSubtypes[Event Player.itemIndex];
					Event Player.specialProperties = Array(Global.itemProperties[Event Player.itemIndex],
						Global.itemPropertyValue[Event Player.itemIndex]);
					Global.savePowers[Slot Of(Event Player)] = Array(Global.savePowers[Slot Of(Event Player)][0], Global.savePowers[Slot Of(
						Event Player)][1], Global.savePowers[Slot Of(Event Player)][2], Global.savePowers[Slot Of(Event Player)][3],
						Event Player.specialPower);
					Global.saveSpecialProperties[Slot Of(Event Player)] = Event Player.specialProperties;
					Global.saveSpecialGemstoneType[Slot Of(Event Player)] = Event Player.specialGemstoneType;
				Else If(Event Player.itemSlot == 5);
					Event Player.potionType = Global.itemSubtypes[Event Player.itemIndex];
				End;
				Global.itemSlots[Event Player.itemIndex] = -1;
				Destroy Effect(Global.itemEffects[Event Player.itemIndex]);
				Destroy In-World Text(Global.itemTexts[Event Player.itemIndex]);
			End;
			Destroy Effect(Global.extraItemEffects[Event Player.itemIndex]);
		End;
		Event Player.potionMaxUses = (Event Player.potionType >= 8 ? 1 : 3) * (Event Player.playerUniqueItems[4] == 11 ? 2 : 1);
		If(Event Player.potionUses > Event Player.potionMaxUses);
			Event Player.potionUses = Event Player.potionMaxUses;
		End;
		Call Subroutine(RecalculateStats);
		Wait(0.600, Ignore Condition);
	}
}

rule("[changed:q][changed:p] OnRoomTransition")
{
	event
	{
		Subroutine;
		OnRoomTransition;
	}

	actions
	{
		If(Global.activeCurse == 5);
			Global.rarityRoll = Random Real(0, 100);
			"[changed:p] dimmed torch or luck also influence the chance to trigger the curse?"
			If(
				Global.rarityRoll <= 30 - Global.teamLuck + 1.200 * Global.torchDifficulty && Global.roomType[Global.roomPositionX][Global.roomPositionY] != 0 && Count Of(
				Global.unvisitedRooms) > 0);
				Global.loopCounter1 = Random Value In Array(Global.unvisitedRooms);
				Global.roomPositionX = Round To Integer(Global.loopCounter1 / Global.floorMapSize, Down);
				Global.roomPositionY = Global.loopCounter1 % Global.floorMapSize;
				Small Message(All Players(All Teams), Custom String("something is wrong..."));
			End;
		End;
		"[new:p] no repeated teleport to the same room"
		Modify Global Variable(unvisitedRooms, Remove From Array By Value,
			Global.roomPositionX * Global.floorMapSize + Global.roomPositionY);
		Destroy Effect(Global.treasureEffect[0]);
		Destroy Effect(Global.treasureEffect[1]);
		Destroy Effect(Global.treasureEffect[2]);
		Global.treasureEffect = Empty Array;
		Destroy Effect(Global.stairwellEffect[0]);
		Destroy In-World Text(Global.stairwellEffect[1]);
		Global.stairwellEffect = Empty Array;
		For Global Variable(loopCounter4, 0, Count Of(Global.itemNames), 1);
			If(Global.itemNames[Global.loopCounter4] != Custom String("none") && Global.itemSlots[Global.loopCounter4] != -1);
				If(Global.currentRoom != 3 && Global.currentRoom < 10);
					Small Message(All Players(Team 1), Custom String("sold {0} for {1} gold", Global.itemNames[Global.loopCounter4], Round To Integer(
						Global.itemPowers[Global.loopCounter4], Up)));
					Global.teamGold += Round To Integer(Global.itemPowers[Global.loopCounter4], Up);
				End;
				Destroy Effect(Global.itemEffects[Global.loopCounter4]);
				Destroy Effect(Global.extraItemEffects[Global.loopCounter4]);
				Destroy In-World Text(Global.itemTexts[Global.loopCounter4]);
			End;
			Wait(0.016, Ignore Condition);
		End;
		Global.currentRoom = 0;
		"[changed:q] guaranteed all shop effects are removed."
		While(Count Of(Global.shopEffects) > 0);
			Destroy Effect(Global.shopEffects[0]);
			Destroy In-World Text(Global.shopEffects[0]);
			Modify Global Variable(shopEffects, Remove From Array By Index, 0);
			Wait(0.016, Ignore Condition);
		End;
		Wait(0.050, Ignore Condition);
		Global.itemNames = Empty Array;
		Global.itemPositions = Empty Array;
		Global.itemSlots = Empty Array;
		Global.itemSubtypes = Empty Array;
		Global.itemEffects = Empty Array;
		Global.itemTexts = Empty Array;
		Global.itemPowers = Empty Array;
		Global.itemRarities = Empty Array;
		Wait(0.016, Ignore Condition);
		Global.itemProperties = Empty Array;
		Global.itemPropertyValue = Empty Array;
		Global.extraItemEffects = Empty Array;
		Global.itemUnique = Empty Array;
		Global.teamGold += Global.manipGold;
		Global.manipGold = 0;
		Global.manipSuccessRate = 0;
		Global.currentTextID = Random Integer(0, Count Of(Global.flavorTexts) - 1);
		Global.deathsThisRoom = 0;
		Call Subroutine(EvaluateHallChance);
		Global.specialHallType = 0;
		Global.teamLuck = (Global.teamGoldSacrificed / 5000) ^ 0.500;
		Destroy In-World Text(Global.eventInfoText);
		Global.eventInfoText = 0;
		Global.bossRushCounter = 1;
	}
}

rule("destroy damage text")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.damageTextTimer == 0;
	}

	actions
	{
		Destroy In-World Text(Event Player.damageText);
		Event Player.damageText = 0;
	}
}

rule("treasure room")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 2;
	}

	actions
	{
		If(Count Of(Global.treasureEffect) == 0);
			Create Effect(All Players(All Teams), Orb, Color(Orange), Vector(0, 2, 0), 1, Visible To Position and Radius);
			Global.treasureEffect = Array(Last Created Entity);
			Create Effect(All Players(All Teams), Sparkles, Color(Orange), Vector(0, 2, 0), 2, Visible To Position and Radius);
			Modify Global Variable(treasureEffect, Append To Array, Last Created Entity);
			Create Effect(All Players(All Teams), Good Aura, Color(Orange), Vector(0, 2, 0), 2, Visible To Position and Radius);
			Modify Global Variable(treasureEffect, Append To Array, Last Created Entity);
		End;
	}
}

rule("[changed:p]opening a treasure")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 2;
		Is True For Any(All Players(Team 1), Is Button Held(Current Array Element, Button(Interact)) && Distance Between(
			Current Array Element, Vector(0, 2, 0)) <= 3) == True;
	}

	actions
	{
		Global.randomRoll = Random Real(0, 100);
		If(Global.randomRoll < 12 - Global.teamLuck);
			Create Dummy Bot(Hero(D.Va), Team 2, -1, Vector(0, 2, 0), Vector(0, 0, 0));
			Global.alexBot = Last Created Entity;
			Start Forcing Dummy Bot Name(Global.alexBot, Custom String("Enoch"));
			Start Scaling Player(Global.alexBot, 2.500, False);
			Start Modifying Hero Voice Lines(Global.alexBot, 0.500, False);
			Start Damage Modification(Evaluate Once(Global.alexBot), All Players(Team 1), 12, Receivers Damagers and Damage Percent);
			Wait(0.200, Ignore Condition);
			Heal(Global.alexBot, Null, Max Health(Global.alexBot) * 4);
			Wait Until(Number Of Players(Team 2) == 0, 99999);
		End;
		Destroy Effect(Global.treasureEffect[0]);
		Destroy Effect(Global.treasureEffect[1]);
		Destroy Effect(Global.treasureEffect[2]);
		Global.temp = Global.roomType[Global.roomPositionX];
		Global.temp[Global.roomPositionY] = 0;
		Global.roomType[Global.roomPositionX] = Global.temp;
		Global.currentRoom = 0;
		Call Subroutine(TreasureDrop);
	}
}

rule("[changed:q]shop")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 3;
	}

	actions
	{
		"[changed:q]make the shop generating code shorter"
		Create In-World Text(All Players(All Teams), Custom String("next item costs {0} gold", Round To Integer(
			50 * 1.300 ^ Global.shopPurchases, Up)), Vector(0, 3, 0), 1.750, Do Not Clip, Visible To Position and String, Color(Orange),
			Default Visibility);
		Modify Global Variable(shopEffects, Append To Array, Last Text ID);
		For Global Variable(loopCounter1, 0, Count Of(Global.shopPos), 1);
			Create Effect(All Players(All Teams), Ring, Color(Orange), Global.shopPos[Global.loopCounter1], 1.500, Visible To);
			Modify Global Variable(shopEffects, Append To Array, Last Created Entity);
			Create In-World Text(All Players(All Teams), Global.shopText[Evaluate Once(Global.loopCounter1)], Global.shopPos[Evaluate Once(
				Global.loopCounter1)] + Vector(0, 1, 0), 1.200, Do Not Clip, Visible To Position and String, Color(Orange),
				Default Visibility);
			Modify Global Variable(shopEffects, Append To Array, Last Text ID);
		End;
	}
}

rule("[changed:p]SpawnItemForSlot")
{
	event
	{
		Subroutine;
		SpawnItemForSlot;
	}

	actions
	{
		Abort If(Global.floorNumber >= 666);
		Global.itemExtraEffect = -1;
		Modify Global Variable(itemPositions, Append To Array, Global.newItemPos);
		Modify Global Variable(itemSlots, Append To Array, Global.newItemSlot);
		Modify Global Variable(itemSubtypes, Append To Array, Global.newItemSubtype);
		If(Global.newItemSlot == 0);
			Global.newItemName = Global.heroWeaponNames[1][Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]];
		Else If(Global.newItemSlot == 1);
			Global.newItemName = Custom String("{0}", Array(Custom String("light robe"), Custom String("leather chestplate"), Custom String(
				"plate metal breastplate"))[Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]]);
		Else If(Global.newItemSlot == 2);
			Global.newItemName = Custom String("{0}", Array(Custom String("cloth hood"), Custom String("leather helmet"), Custom String(
				"steel helmet"))[Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]]);
		Else If(Global.newItemSlot == 3);
			Global.newItemName = Custom String("{0}", Array(Custom String("cloth boots"), Custom String("leather boots"), Custom String(
				"steel boots"))[Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]]);
		Else If(Global.newItemSlot == 4);
			Global.newItemName = Custom String("{0} necklace", Array(Custom String("ruby"), Custom String("amber"), Custom String("topaz"),
				Custom String("emerald"), Custom String("diamond"), Custom String("sapphire"), Custom String("amethyst"), Custom String(
				"onyx"))[Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]]);
		Else If(Global.newItemSlot == 5);
			Global.newItemName = Array(Custom String("healing potion"), Custom String("regeneration potion"), Custom String("strength potion"),
				Custom String("defense potion"), Custom String("agility potion"), Custom String("awareness potion"), Custom String(
				"aegis potion"), Custom String("luck potion"), Custom String("white blood"), Custom String("essence of chaos"), Custom String(
				"violence milk"), Custom String("lemegeton essence"), Custom String("Soul of Petra"), Custom String("Soul of Diablo"),
				Custom String("Soul of Mithrix"))[Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]];
			Global.newItemRarity = 1;
		End;
		Global.rarityRoll = Random Real(0, 1000);
		If(Global.uniqueItemSpawn);
			Global.isUniqueItem = True;
			If(Global.rarityRoll <= 200 * (Global.teamLuck + 1));
				Global.newItemRarity = 8;
				Global.newItemAffixes = 3;
			Else;
				Global.newItemRarity = 7;
				Global.newItemAffixes = 2;
			End;
		Else If(Global.newItemRarity == 0);
			"0.4% mythical"
			If(Global.rarityRoll <= 4 * (Global.teamLuck + 1));
				Global.newItemRarity = 6;
				Global.newItemAffixes = 3;
				If(Global.activeCurse != 3);
					Create Effect(All Players(All Teams), Light Shaft, Color(Red), Global.newItemPos, 0.200, Visible To);
					Global.itemExtraEffect = Last Created Entity;
				End;
				Global.randomRoll = Random Real(0, 100);
				If(Global.randomRoll <= 20 + Global.teamLuck * 10);
					Global.isUniqueItem = True;
					Global.newItemRarity += 2;
				Else;
					Global.isUniqueItem = False;
				End;
			"2% legendary"
			Else If(Global.rarityRoll <= 24 * (Global.teamLuck + 1));
				Global.newItemRarity = 5;
				Global.newItemAffixes = 2;
				If(Global.activeCurse != 3);
					Create Effect(All Players(All Teams), Light Shaft, Color(Yellow), Global.newItemPos, 0.200, Visible To);
					Global.itemExtraEffect = Last Created Entity;
				End;
				Global.randomRoll = Random Real(0, 100);
				If(Global.randomRoll <= 20 + Global.teamLuck * 10);
					Global.isUniqueItem = True;
					Global.newItemRarity += 2;
				Else;
					Global.isUniqueItem = False;
				End;
			"4% epic"
			Else If(Global.rarityRoll <= 64 * (Global.teamLuck + 1));
				Global.newItemRarity = 4;
				Global.newItemAffixes = 1;
				Global.isUniqueItem = False;
			"10% rare"
			Else If(Global.rarityRoll <= 164 * (Global.teamLuck + 1));
				Global.newItemRarity = 3;
				Global.newItemAffixes = 1;
				Global.isUniqueItem = False;
			"25% uncommon"
			Else If(Global.rarityRoll <= 416 * (Global.teamLuck + 1));
				Global.newItemRarity = 2;
				Global.newItemAffixes = 0;
				Global.isUniqueItem = False;
			"58.4% common"
			Else;
				Global.newItemRarity = 1;
				Global.newItemAffixes = 0;
				Global.isUniqueItem = False;
			End;
		Else;
			Global.newItemAffixes = Array(0, 0, 1, 1, 2, 3, 2, 3)[Global.newItemRarity - 1];
			Global.isUniqueItem = Global.newItemRarity >= 7;
		End;
		Modify Global Variable(itemRarities, Append To Array, Global.newItemRarity);
		Global.rarityRoll = Random Real(0, 100);
		"[changed:p] team luck has influence on the enhance level"
		If(Global.rarityRoll <= 4 + Global.teamLuck);
			Global.newItemEnhance = Global.floorNumber * 2 + (Global.newItemRarity - (Global.isUniqueItem ? 2 : 0)) * 2 - 1 + Random Integer(0,
				Global.teamLuck);
		Else If(Global.rarityRoll <= 27 + Global.teamLuck * 2);
			Global.newItemEnhance = Global.floorNumber * 2 + (Global.newItemRarity - (Global.isUniqueItem ? 2 : 0)) * 2 - 2 + Random Integer(0,
				Global.teamLuck / 2);
		Else;
			Global.newItemEnhance = Global.floorNumber * 2 + (Global.newItemRarity - (Global.isUniqueItem ? 2 : 0)) * 2 - 2;
		End;
		Global.itemRolledAffixes = Empty Array;
		For Global Variable(loopCounter1, 0, Global.newItemAffixes, 1);
			Modify Global Variable(itemRolledAffixes, Append To Array, Random Value In Array(Remove From Array(
				Global.newItemSlot == 0 && Array Contains(Array(Hero(D.Va), Hero(Moira), Hero(Hanzo), Hero(Bastion), Hero(Brigitte), Hero(
				Sigma), Hero(Reinhardt)), Global.heroWeaponNames[0][Global.newItemSubtype]) ? Array(0, 1, 2, 4) : Array(0, 1, 2, 3, 4),
				Global.itemRolledAffixes)));
			Global.newItemName = String Replace(Global.stringsAffix[Global.newItemSlot][Global.itemRolledAffixes[Global.loopCounter1]],
				Custom String("{x}"), Global.newItemName);
		End;
		Modify Global Variable(itemProperties, Append To Array, Array(Global.itemRolledAffixes));
		Global.itemRolledAffixes = Empty Array;
		"[changed:p] luck matters"
		For Global Variable(loopCounter1, 0, Global.newItemAffixes, 1);
			If(Global.newItemSlot == 0 && Global.itemProperties[Count Of(Global.itemProperties) - 1][Global.loopCounter1] == 3);
				Modify Global Variable(itemRolledAffixes, Append To Array, Random Real(40, 55 + Global.teamLuck * 2));
			Else If(Global.newItemSlot == 4 && Global.itemProperties[Count Of(Global.itemProperties) - 1][Global.loopCounter1] == 3);
				Modify Global Variable(itemRolledAffixes, Append To Array, Random Real(25, 32 + Global.teamLuck * 1.500));
			Else;
				Modify Global Variable(itemRolledAffixes, Append To Array, Random Real(8, 18 + Global.teamLuck));
			End;
		End;
		Modify Global Variable(itemPropertyValue, Append To Array, Array(Global.itemRolledAffixes));
		If(Global.isUniqueItem);
			If(Global.newItemSlot == 0);
				If(Global.itemUniqueID == 0);
					Global.itemUniqueID = Random Integer(1, 6);
				End;
				Global.newItemName = Custom String("{0} {1}", Array(Custom String("flaming"), Custom String("freezing"), Custom String("shocking"),
					Custom String("corrosive"), Custom String("volatile"), Custom String("radiant"))[Global.itemUniqueID - 1],
					Global.uniqueWeaponNames[1][Global.newItemSubtype]);
			Else If(Global.newItemSlot == 1);
				If(Global.itemUniqueID == 0);
					Global.itemUniqueID = Random Integer(1, 4);
				End;
				Global.newItemName = Array(Custom String("Nettle Clothing"), Custom String("Star Cloak"), Custom String("Universe"), Custom String(
					"Saving Grace"), Custom String("Glass Cannon"), Custom String("Transcendence"), Custom String("Messenger of Diablo"),
					Custom String("Mystery Swap"), Custom String("Dark Knight"), Custom String("Stronghold"), Custom String("Mega Sized"),
					Custom String("Malice"))[Global.newItemSubtype * 4 + Global.itemUniqueID - 1];
			Else If(Global.newItemSlot == 2);
				If(Global.itemUniqueID == 0);
					Global.itemUniqueID = Random Integer(1, 4);
				End;
				Global.newItemName = Array(Custom String("Guiding Light"), Custom String("Brittle Crown"), Custom String("Black Candle"),
					Custom String("Gup Hat"), Custom String("Marksman"), Custom String("Blood Soul Stone"), Custom String("Dominance"),
					Custom String("Red Rose"), Custom String("Overseer"), Custom String("Mask of Infamy"), Custom String("Aries"), Custom String(
					"Regret"))[Global.newItemSubtype * 4 + Global.itemUniqueID - 1];
			Else If(Global.newItemSlot == 3);
				If(Global.itemUniqueID == 0);
					Global.itemUniqueID = Random Integer(1, 4);
				End;
				Global.newItemName = Array(Custom String("Path to Ascension"), Custom String("Angelic Flight"), Custom String("Divine Grace"),
					Custom String("Absolution"), Custom String("Strides of Heresy"), Custom String("Blazing Speed"), Custom String("Traveller"),
					Custom String("Path of Exile"), Custom String("Headstompers"), Custom String("Thunder Thighs"), Custom String("Earthquake"),
					Custom String("Tread of Terror"))[Global.newItemSubtype * 4 + Global.itemUniqueID - 1];
			Else;
				If(Global.currentRoom == 9);
					If(Global.itemUniqueID == 0);
						Global.itemUniqueID = Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1] + 1 + 8 * Random Integer(0,
							Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1] == 0 ? 2 : 1);
					End;
				Else;
					If(Global.itemUniqueID == 0);
						Global.itemUniqueID = Random Integer(1, 17);
					End;
					Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1] = (Global.itemUniqueID - 1) % 8;
				End;
				Global.newItemName = Array(Custom String("Voidsent Flame"), Custom String("Thunderbolt in a Jar"), Custom String(
					"Best Friend Alux"), Custom String("Genesis Loop"), Custom String("Ancestral Hourglass"), Custom String("Silver Flower"),
					Custom String("Old Seer's Lenses"), Custom String("Dancing Shadowflame"), Custom String("Mark of Sin"), Custom String(
					"Heart of Fear"), Custom String("Alchemist's Pouch"), Custom String("Planula"), Custom String("Loaded Dice"), Custom String(
					"Holy Mantle"), Custom String("Essence of Hatred"), Custom String("Royal Raven's Feather"), Custom String("The Community"))
					[Global.itemUniqueID - 1];
			End;
			Modify Global Variable(itemUnique, Append To Array, Global.itemUniqueID);
		Else;
			Modify Global Variable(itemUnique, Append To Array, 0);
		End;
		"[changed:p] rarity matters, and equipments are more different across roles"
		If(Global.newItemSlot == 0);
			Modify Global Variable(itemPowers, Append To Array, Random Real(10, 20) + Global.newItemEnhance * ((Global.newItemRarity - (
				Global.isUniqueItem ? 2 : 0)) / 12 + 1) * 12);
		Else If(Global.newItemSlot == 3);
			Modify Global Variable(itemPowers, Append To Array, (1 - 0.990 ^ (Global.newItemEnhance * ((Global.newItemRarity - (
				Global.isUniqueItem ? 2 : 0)) / 12 + 1)) * Random Real(0.925, 0.975) * 0.920 ^ Global.itemSubtypes[Count Of(
				Global.itemSubtypes) - 1]) * 100);
		Else If(Global.newItemSlot == 2);
			Modify Global Variable(itemPowers, Append To Array, Random Real(5, 15) + Global.newItemEnhance * ((Global.newItemRarity - (
				Global.isUniqueItem ? 2 : 0)) / 12 + 1) * (8 + (2 - Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]) * 5));
		Else If(Global.newItemSlot == 1);
			Modify Global Variable(itemPowers, Append To Array, Random Real(5, 15) + Global.newItemEnhance * ((Global.newItemRarity - (
				Global.isUniqueItem ? 2 : 0)) / 12 + 1) * (6 + Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1] * 4));
		Else If(Global.newItemSlot == 4 && Array Contains(Array(4, 5, 7), Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1]));
			Modify Global Variable(itemPowers, Append To Array, (1 - 0.985 ^ (Global.newItemEnhance * ((Global.newItemRarity - (
				Global.isUniqueItem ? 2 : 0)) / 12 + 1)) * Random Real(0.850, 0.950)) * 100);
		Else If(Global.newItemSlot == 4 && Global.itemSubtypes[Count Of(Global.itemSubtypes) - 1] == 1);
			Modify Global Variable(itemPowers, Append To Array, Random Real(3, 6) + Global.newItemEnhance * ((Global.newItemRarity - (
				Global.isUniqueItem ? 2 : 0)) / 12 + 1) * 4);
		Else;
			Modify Global Variable(itemPowers, Append To Array, Random Real(10, 20) + Global.newItemEnhance * ((Global.newItemRarity - (
				Global.isUniqueItem ? 2 : 0)) / 12 + 1) * 12);
		End;
		Modify Global Variable(itemNames, Append To Array, Custom String("{0}{1}",
			Global.newItemEnhance > 0 && Global.newItemSlot != 5 ? Custom String("+{0} ", Global.newItemEnhance) : Custom String(""),
			Global.newItemName));
		Create Effect(All Players(All Teams), Orb, Global.activeCurse == 3 ? Color(Black) : (Global.itemSlots[Evaluate Once(Count Of(
			Global.itemRarities) - 1)] == 5 ? (Global.newItemSubtype >= 12 ? Color(Violet) : Color(Aqua))
			: Global.rarityColors[Global.itemRarities[Evaluate Once(Count Of(Global.itemRarities) - 1)]]), Evaluate Once(
			Global.newItemPos), 1, Visible To Position Radius and Color);
		Modify Global Variable(itemEffects, Append To Array, Last Created Entity);
		Create In-World Text(All Players(All Teams), Global.activeCurse == 3 ? Custom String("???") : Custom String("{0}\r\n{1}",
			Global.itemNames[Evaluate Once(Count Of(Global.itemNames) - 1)], Global.itemSlots[Evaluate Once(Count Of(Global.itemNames) - 1)
			] == 5 ? Custom String(" ") : Custom String("{0}% power", Global.itemPowers[Evaluate Once(Count Of(Global.itemPowers) - 1)])),
			Evaluate Once(Global.newItemPos), 1, Clip Against Surfaces, Visible To Position String and Color,
			Global.activeCurse == 3 ? Color(Black) : (Global.itemSlots[Evaluate Once(Count Of(Global.itemRarities) - 1)] == 5 ? (
			Global.newItemSubtype >= 12 ? Color(Violet) : Color(Aqua)) : Global.rarityColors[Global.itemRarities[Evaluate Once(Count Of(
			Global.itemRarities) - 1)]]), Default Visibility);
		Modify Global Variable(itemTexts, Append To Array, Last Text ID);
		Modify Global Variable(extraItemEffects, Append To Array, Global.itemExtraEffect);
		Global.uniqueItemSpawn = False;
		Global.isUniqueItem = False;
		Global.itemUniqueID = 0;
		Global.newItemRarity = 0;
	}
}

rule("[new:q]general shopping")
{
	event
	{
		Subroutine;
		GeneralShop;
	}

	actions
	{
		If(Global.teamGold < 50 * 1.300 ^ Global.shopPurchases);
			Small Message(Event Player, Custom String("{0} not enough gold.", Icon String(No)));
			Abort;
		End;
		If(Event Player.uniqueHero);
			Small Message(Event Player, Custom String("{0} you can't buy items in the shop.", Icon String(No)));
			Abort;
		End;
		Global.newItemSlot = Global.param1;
		Global.param3 = Array(Custom String("weapon"), Custom String("body armor"), Custom String("headgear"), Custom String("boots"),
			Custom String("accessory"), Custom String("potion"))[Global.param1];
		Wait(0.100, Ignore Condition);
		"Let everyone know who purchased (wasted gold) xD"
		Small Message(All Players(Team 1), Custom String("{0}{1} purchased {2}", Hero Icon String(Hero Of(Event Player)), Event Player,
			Global.param3));
		Global.newItemPos = Direction From Angles(Random Real(0, 360), 0) * 12 + Vector(0, 0.600, 0);
		If(Global.param1 == 0);
			Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Event Player));
		Else If(Global.param1 <= 3);
			Global.newItemSubtype = Event Player.playerRole;
		Else If(Global.param1 == 4);
			Global.newItemSubtype = Event Player.specialGemstoneType;
		Else;
			Event Player.randomRoll = Random Real(0, 1000);
			If(Event Player.randomRoll <= 1);
				Global.newItemSubtype = Max(12 + Random Value In Array(All Players(Team 1)).playerRole, 14);
				Big Message(All Players(All Teams), Custom String("a soul appears?!"));
			Else;
				Global.newItemSubtype = Random Integer(0, 11);
			End;
		End;
		Global.teamGold -= 50 * 1.300 ^ Global.shopPurchases;
		If(Event Player.playerUniqueItems[4] == 13);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll > 50);
				Global.teamGold += 50 * 1.300 ^ Global.shopPurchases;
			End;
		End;
		Event Player.shopCooldown = 2;
		Global.teamLuck += Global.shopPurchases * 0.300;
		Call Subroutine(SpawnItemForSlot);
		Wait(0.100, Ignore Condition);
		Global.teamLuck -= Global.shopPurchases * 0.300;
		Global.shopPurchases += 1;
	}
}

rule("[changed:q]buy")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.currentRoom == 3;
		Is Button Held(Event Player, Button(Interact)) == True;
		"[changed:q]using shopPos array to locate"
		Is True For Any(Global.shopPos, Distance Between(Current Array Element, Event Player) <= 1.500) == True;
		Event Player.shopCooldown == 0;
	}

	actions
	{
		"[changed:q] call GeneralShop subroutine"
		Global.param1 = Index Of Array Value(Global.shopPos, First Of(Sorted Array(Global.shopPos, Distance Between(Current Array Element,
			Event Player))));
		Call Subroutine(GeneralShop);
	}
}

rule("blazing elites ignite on hit")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 1;
		Event Ability != Null;
		Hero Of(Victim) != Hero(Junkrat);
	}

	actions
	{
		Set Status(Victim, Event Player, Burning, 2);
		Start Damage Over Time(Victim, Event Player, 2, Event Damage * 0.250);
		Wait(0.250, Ignore Condition);
	}
}

rule("and damage nearby enemies")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 1;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Damage(Players Within Radius(Event Player, 5, Team 1, Surfaces And All Barriers), Event Player, 25);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("glacial elites can freeze on hit")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 2;
		Has Status(Victim, Frozen) == False;
		Event Ability != Null;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		If(Event Player.randomRoll <= Event Damage / Max Health(Victim) * 200);
			Set Status(Victim, Event Player, Frozen, 1);
		End;
		Wait(0.250, Ignore Condition);
	}
}

rule("and explode on death")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 2;
	}

	actions
	{
		Create Effect(All Players(All Teams), Sphere, Color(Aqua), Event Player, 4, Visible To Position and Radius);
		Event Player.eliteEffect = Last Created Entity;
		Wait(1, Ignore Condition);
		Damage(Players Within Radius(Event Player, 4, Team 1, Surfaces And All Barriers), Event Player, 100);
		Set Status(Players Within Radius(Event Player, 4, Team 1, Surfaces And All Barriers), Event Player, Frozen, 1.250);
		Destroy Effect(Event Player.eliteEffect);
	}
}

rule("overloading elites apply extra delayed damage")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 3;
		Event Ability != Null;
	}

	actions
	{
		Victim.overloadingDamageBuffer += Event Damage * 0.500;
		Wait(0.250, Ignore Condition);
	}
}

rule("and have higher move and projectile speed")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 3;
	}

	actions
	{
		Set Move Speed(Event Player, 140);
		Set Projectile Speed(Event Player, 140);
	}
}

rule("triggering")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.overloadingDamageBuffer > 0;
	}

	actions
	{
		Wait(1.250, Ignore Condition);
		Damage(Event Player, Null, Event Player.overloadingDamageBuffer * (100 / (100 - Event Player.statDefense)));
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(White), Position Of(Event Player), 100);
		Play Effect(All Players(All Teams), Bad Pickup Effect, Color(Blue), Position Of(Event Player), 3);
		Event Player.overloadingDamageBuffer = 0;
		Loop If Condition Is True;
	}
}

rule("[changed:q][changed:p]mending(not blazing) elites heal on hit")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 4;
		Event Ability != Null;
	}

	actions
	{
		Heal(Event Player, Event Player, Event Damage * 0.400);
		Wait(0.250, Ignore Condition);
	}
}

rule("[changed:p]and heal nearby allies")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 4;
		Is Alive(Event Player) == True;
	}

	actions
	{
		"[changed:p] plz nerf mending enemies plz"
		Heal(Filtered Array(Players Within Radius(Event Player, 8, Team 2, Surfaces And All Barriers),
			Current Array Element != Event Player), Event Player, Max Health(Event Player) * 0.050);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("stairwell room")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Array Contains(Array(8, 10, 11), Global.currentRoom) == True;
	}

	actions
	{
		If(Count Of(Global.stairwellEffect) == 0);
			Create Effect(Filtered Array(All Players(All Teams), !Global.battleInProgress), Sphere, Color(Purple), Vector(0, 2, 0), 4,
				Visible To Position and Radius);
			Global.stairwellEffect = Array(Last Created Entity);
			Create In-World Text(Filtered Array(All Players(All Teams), !Global.battleInProgress), Custom String(
				"proceed to next floor\r\neveryone must gather here"), Vector(0, 2, 0), 1.600, Clip Against Surfaces,
				Visible To Position and String, Color(Purple), Default Visibility);
			Modify Global Variable(stairwellEffect, Append To Array, Last Text ID);
		End;
	}
}

rule("proceed to the next floor")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Array Contains(Array(8, 10, 11), Global.currentRoom) == True;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0, 0))
			<= 4) == True;
		Number Of Players(Team 1) > 0;
		Global.battleInProgress == False;
	}

	actions
	{
		Communicate(Filtered Array(All Players(Team 1), Is Dummy Bot(Current Array Element)), Goodbye);
		Wait(0.500, Abort When False);
		Global.floorNumber += 1;
		Big Message(All Players(All Teams), Custom String("floor {0}", Global.floorNumber));
		Call Subroutine(FloorSetup);
		Wait(0.500, Ignore Condition);
		Call Subroutine(OnRoomTransition);
		All Players(All Teams).forceRecalculateStats = True;
	}
}

rule("player downed")
{
	event
	{
		Player Died;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.isDowned == False;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		If(Is Dead(Event Player));
			Event Player.recoveryProgress = Event Player.deathInjury < 0 || Event Player.resAvailable ? 100 : 0;
			Event Player.isDowned = True;
			Resurrect(Event Player);
			Wait(0.100, Ignore Condition);
			If(Event Player.resAvailable);
				Small Message(Event Player, Custom String("not today."));
				Event Player.resAvailable = False;
				Event Player.deathInjury -= 1;
			End;
			If(Event Player.recoveryProgress == 0);
				If(Event Player.isGuest);
					Small Message(All Players(All Teams), Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(Event Player)),
						Global.guestData[Event Player.guestID][0], Event Player.guestVoiceLines[6]));
				Else If(Is True For Any(All Players(Team 1), Current Array Element.isGuest && Current Array Element != Event Player));
					Event Player.tempArray = First Of(Filtered Array(All Players(Team 1),
						Current Array Element.isGuest && Current Array Element != Event Player));
					Small Message(All Players(All Teams), Evaluate Once(Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(
						Event Player.tempArray)), Global.guestData[Event Player.tempArray.guestID][0], Event Player.tempArray.guestVoiceLines[2])));
				End;
				Create Effect(All Players(All Teams), Ring, Color(Yellow), Event Player, 0.050 * (100 - Event Player.recoveryProgress),
					Visible To Position and Radius);
				Event Player.downedHelpIndicator = Last Created Entity;
				Set Status(Event Player, Null, Knocked Down, 9999);
				Wait(0.100, Ignore Condition);
				Set Status(Event Player, Null, Phased Out, 9999);
				Small Message(All Players(All Teams), Custom String("{0} {1} has been downed!", Hero Icon String(Hero Of(Event Player)),
					Event Player));
				Disable Hero HUD(Event Player);
				Start Camera(Event Player, Position Of(Event Player) + Vector(0, 20, 0), Event Player, 0);
			End;
		End;
		If(!Event Player.playerGrace);
			Global.deathsThisFloor += 1;
			Global.deathsThisRoom += 1;
			Call Subroutine(EvaluateHallChance);
		End;
	}
}

rule("recovering")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(Players Within Radius(Event Player, 5, Team 1, Off), !Current Array Element.isDowned)) > 0;
		Event Player.isDowned == True;
		Event Player.recoveryProgress < 100;
	}

	actions
	{
		Event Player.recoveryProgress += 5 / (1 + Event Player.deathInjury) * (Count Of(Filtered Array(Players Within Radius(Event Player,
			5, Team 1, Off), !Current Array Element.isDowned)) + Count Of(Filtered Array(Players Within Radius(Event Player, 5, Team 1,
			Off),
			!Current Array Element.isDowned && Current Array Element.playerRole == 0 && Current Array Element.playerUniqueItems[1] == 4))
			* 3);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("player recovered")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.isDowned == True;
		Event Player.recoveryProgress >= 100;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Clear Status(Event Player, Phased Out);
		Clear Status(Event Player, Knocked Down);
		Destroy Effect(Event Player.downedHelpIndicator);
		Event Player.isDowned = False;
		Stop Camera(Event Player);
		Enable Hero HUD(Event Player);
		Wait(0.100, Ignore Condition);
		Set Status(Event Player, Null, Invincible, 3);
		Communicate(Event Player, Thanks);
		If(Event Player.isGuest);
			Small Message(All Players(All Teams), Custom String("{0} {1}: {2}", Hero Icon String(Hero Of(Event Player)),
				Global.guestData[Event Player.guestID][0], Event Player.guestVoiceLines[7]));
		End;
		If(Hero Of(Event Player) == Hero(D.Va));
			Respawn(Event Player);
		End;
		Event Player.deathInjury += 1;
		Event Player.recoveryProgress = 0;
		Loop If Condition Is True;
		If(Event Player.thirdPersonOn);
			Start Camera(Event Player, Update Every Frame(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * -4, All Players(All Teams), Event Player, False)), Update Every Frame(Eye Position(
				Event Player)), 0);
		End;
	}
}

rule("well, that's an h")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Number Of Players(Team 1) > 0;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Current Array Element.isDowned) == True;
		Global.battleInProgress == True;
	}

	actions
	{
		Wait(3, Abort When False);
		Declare Team Victory(Team 2);
	}
}

rule("fountain room")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 6;
	}

	actions
	{
		If(Count Of(Global.stairwellEffect) == 0);
			Create Effect(All Players(All Teams), Sphere, Color(Green), Vector(0, 2, 0), 6, Visible To Position and Radius);
			Global.stairwellEffect = Array(Last Created Entity);
			Create In-World Text(All Players(All Teams), Custom String(
				"gather here to rest\r\nremoves all {0} death injuries\r\nand refills potions", Icon String(Skull)), Vector(0, 2, 0), 1.600,
				Clip Against Surfaces, Visible To Position and String, Color(Green), Default Visibility);
			Modify Global Variable(stairwellEffect, Append To Array, Last Text ID);
		End;
	}
}

rule("rest")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 6;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0, 0))
			<= 6) == True;
		Number Of Players(Team 1) > 0;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Cancel Primary Action(All Players(Team 1));
		Global.temp = Global.roomType[Global.roomPositionX];
		Global.temp[Global.roomPositionY] = 0;
		Global.roomType[Global.roomPositionX] = Global.temp;
		Global.currentRoom = 0;
		Play Effect(All Players(All Teams), Ana Biotic Grenade Increased Healing Sound, Team 1, Vector(0, 2, 0), 160);
		Play Effect(All Players(All Teams), Hanzo Sonic Arrow Initial Pulse Sound, Team 1, Vector(0, 2, 0), 160);
		Teleport(All Players(Team 1), Vector(0, 0, 0));
		Wait(0.016, Ignore Condition);
		disabled Communicate(All Players(Team 1), Emote Up);
		If(Is True For Any(All Players(Team 1), Current Array Element.deathInjury > 0));
			Filtered Array(All Players(Team 1), Current Array Element.deathInjury > 0).deathInjury = 0;
			Small Message(All Players(All Teams), Custom String("you feel refreshed!"));
		Else;
			All Players(All Teams).deathInjury -= 1;
			Small Message(All Players(All Teams), Custom String("you feel blessed!"));
			Heal(All Players(Team 1), Null, 1000 * 1000);
		End;
		All Players(All Teams).potionUses = 6;
		All Players(All Teams).forceRecalculateStats = True;
	}
}

rule("[changed:p]health regen")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.isDowned == False;
		Event Player.healingNullTime == 0;
		(Event Player.playerUniqueItems[1] == 1 && Event Player.playerRole == 2) == False;
	}

	actions
	{
		Heal(Event Player, Null, Event Player.statHealth / (100 / (100 - Event Player.playerBlackBlood)) * 0.050 * (
			Event Player.statHealing / 100));
		If(Event Player.playerRole == 0 && Event Player.playerUniqueItems[2] == 4);
			Heal(Event Player, Null, Max Health(Event Player) * 0.250);
		End;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("healing text")
{
	event
	{
		Player Dealt Healing;
		Team 1;
		All;
	}

	conditions
	{
		Healee != Event Player;
		Event Ability != Null;
		Event Healing > 0;
	}

	actions
	{
		If(Event Player.healingText != 0);
			Destroy In-World Text(Event Player.healingText);
		End;
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Create In-World Text(Event Player, Custom String("{0}", Round To Integer(Event Healing, Up)), Eye Position(Healee) + Evaluate Once(
			Vector(Random Real(-0.500, 0.500), Random Real(-0.500, 0.500), Random Real(-0.500, 0.500))) + Vector(0, (
			1 - Event Player.healingTextTimer) * 2 - 1, 0), 2.500, Do Not Clip, Visible To Position and Color,
			Event Player.isCritical ? Color(Aqua) : Color(Green), Default Visibility);
		Event Player.healingText = Last Text ID;
		Event Player.healingTextTimer = 1;
		Wait(0.200, Ignore Condition);
	}
}

rule("destroy healing text")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.healingTextTimer == 0;
	}

	actions
	{
		Destroy In-World Text(Event Player.healingText);
		Event Player.healingText = 0;
	}
}

rule("damage reflect")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Array Contains(Event Player.bodyProperties[0], 2) == True;
	}

	actions
	{
		Damage(Attacker, Event Player, Event Damage / (Event Player.statDamage / 100) * (
			Event Player.bodyProperties[1][Index Of Array Value(Event Player.bodyProperties[0], 2)] / 100));
		Wait(0.250, Ignore Condition);
	}
}

rule("widow")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Widowmaker;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Big Message(All Players(All Teams), Custom String("{0} {1} exposes enemy weakpoints! all attacks are critical!", Hero Icon String(
			Hero Of(Event Player)), Event Player));
		Start Damage Modification(All Players(Team 2), All Players(Team 1), 125, Receivers Damagers and Damage Percent);
		Global.widowDamageMod = Last Damage Modification ID;
		Wait Until(!Is Using Ultimate(Event Player), 99999);
		Stop Damage Modification(Global.widowDamageMod);
	}
}

rule("sigma and sombra have been softcapped")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Array Contains(Array(Hero(Sigma), Hero(Sombra)), Hero Of(Event Player)) == True;
	}

	actions
	{
		"[new:p]nerf sigma's ult one shot killing"
		Start Damage Modification(All Players(All Teams), Event Player, 1, Receivers Damagers and Damage Percent);
		Event Player.sigmaDamageMod = Last Damage Modification ID;
		Wait Until(!Is Using Ultimate(Event Player), 99999);
		Stop Damage Modification(Event Player.sigmaDamageMod);
	}
}

rule("mercy")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Mercy;
	}

	conditions
	{
		Event Player.isDowned == False;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Count Of(Filtered Array(Players Within Radius(Event Player, 5, Team 1, Off), Current Array Element.isDowned)) > 0;
	}

	actions
	{
		Small Message(Filtered Array(Players Within Radius(Event Player, 5, Team 1, Off), Current Array Element.isDowned), Custom String(
			"{0} {1} resurrects you!", Hero Icon String(Hero Of(Event Player)), Event Player));
		Filtered Array(Players Within Radius(Event Player, 5, Team 1, Off), Current Array Element.isDowned).recoveryProgress = 420;
		Set Ability Cooldown(Event Player, Button(Ability 2), 120);
	}
}

rule("bruh")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.isDowned == True;
		Has Status(Event Player, Knocked Down) == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Clear Status(Event Player, Phased Out);
		Set Status(Event Player, Null, Knocked Down, 9999);
		Wait(0.100, Ignore Condition);
		If(Event Player.isDowned);
			Set Status(Event Player, Null, Phased Out, 9999);
		End;
		Loop If Condition Is True;
	}
}

rule("updating ult charge")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Set Ultimate Charge(Event Player, Event Player.ultimateAmount);
		Wait(0.500, Abort When False);
		Loop If Condition Is True;
		Event Player.ultimateAmount = Array Contains(Event Player.specialProperties[0], 3)
			? Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 3)] : 0;
		Set Ultimate Charge(Event Player, Event Player.ultimateAmount);
	}
}

rule("[new:p]gain ult on damage")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Victim != Event Player;
		Event Ability != Null;
	}

	actions
	{
		Event Player.ultimateAmount += (Event Damage / Max Health(Victim) * Event Player.statDamage / 12) ^ 0.500;
		If(Event Player.playerUniqueItems[2] == 2 && Event Player.playerRole == 0);
			Event Player.ultimateAmount += 3;
		End;
		Wait(0.250, Ignore Condition);
	}
}

rule("[new:p]gain ult on healing")
{
	event
	{
		Player Dealt Healing;
		Team 1;
		All;
	}

	conditions
	{
		Healee != Event Player;
		Event Ability != Null;
	}

	actions
	{
		"[new:p]also buff healers' ults"
		Event Player.ultimateAmount += (Event Healing / Max Health(Healee) * Event Player.statHealing / 8) ^ 0.500;
		Wait(0.250, Ignore Condition);
	}
}

rule("[changed:p]reset when using ult")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.ultimateAmount = Array Contains(Event Player.specialProperties[0], 3)
			? Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 3)] : 0;
		Set Ultimate Charge(Event Player, Event Player.ultimateAmount);
		"[changed:p] mech dva after ult will lose all ult charge. This adjustment can make dva better."
		Wait Until(!Is Using Ultimate(Event Player), 99999);
		If(Hero Of(Event Player) == Hero(D.Va) && Is In Alternate Form(Event Player));
			Event Player.ultimateAmount = 100;
			Set Ultimate Charge(Event Player, 100);
		End;
	}
}

rule("shrine room")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 7;
	}

	actions
	{
		If(Count Of(Global.stairwellEffect) == 0);
			Create Effect(All Players(All Teams), Sphere, Color(Turquoise), Vector(0, 2, 0), 5, Visible To Position and Radius);
			Global.stairwellEffect = Array(Last Created Entity);
			Create In-World Text(All Players(All Teams), Custom String(
				"hold [{0}] to change hero\r\ngather here to sacrifice\r\nall your gold for luck", Input Binding String(Button(Melee))),
				Vector(0, 2, 0), 1.600, Clip Against Surfaces, Visible To Position and String, Color(Turquoise), Default Visibility);
			Modify Global Variable(stairwellEffect, Append To Array, Last Text ID);
		End;
	}
}

rule("change hero")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.currentRoom == 7;
		Is Button Held(Event Player, Button(Melee)) == True;
	}

	actions
	{
		If(Event Player.uniqueHero);
			Small Message(Event Player, Custom String("you can't change your hero after achieving secret transformation!"));
			Abort;
		End;
		If(Event Player.playerRole == 1 && Event Player.playerUniqueItems[1] == 4);
			Small Message(Event Player, Custom String("mystery swap prevents you from changing heroes"));
			Abort;
		End;
		Small Message(Event Player, Custom String("please note that you'll drop your current weapon"));
		If(Array Contains(All Tank Heroes, Hero Of(Event Player)));
			Event Player.playerRole = 2;
		Else If(Array Contains(All Damage Heroes, Hero Of(Event Player)));
			Event Player.playerRole = 1;
		Else;
			Event Player.playerRole = 0;
		End;
		Wait(1, Abort When False);
		If(Event Player.itemRarity[0] != 0);
			Modify Global Variable(itemPositions, Append To Array, Position Of(Event Player) + Vector(0, 0.600, 0));
			Modify Global Variable(itemSlots, Append To Array, 0);
			Modify Global Variable(itemSubtypes, Append To Array, Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Event Player)));
			Modify Global Variable(itemRarities, Append To Array, Event Player.itemRarity[0]);
			Modify Global Variable(itemProperties, Append To Array, Array(Event Player.weaponProperties[0]));
			Modify Global Variable(itemPropertyValue, Append To Array, Array(Event Player.weaponProperties[1]));
			Modify Global Variable(itemPowers, Append To Array, Event Player.weaponPower);
			Modify Global Variable(itemNames, Append To Array, Event Player.itemNames[0]);
			Modify Global Variable(itemUnique, Append To Array, Event Player.playerUniqueItems[0]);
			Create Effect(All Players(All Teams), Orb, Global.rarityColors[Global.itemRarities[Evaluate Once(Count Of(Global.itemRarities) - 1)
				]], Evaluate Once(Position Of(Event Player) + Vector(0, 0.600, 0)), 1, Visible To Position Radius and Color);
			Modify Global Variable(itemEffects, Append To Array, Last Created Entity);
			Create In-World Text(All Players(All Teams), Custom String("{0}\r\n{1}% power", Global.itemNames[Evaluate Once(Count Of(
				Global.itemNames) - 1)], Global.itemPowers[Evaluate Once(Count Of(Global.itemPowers) - 1)]), Evaluate Once(Position Of(
				Event Player) + Vector(0, 0.600, 0)), 1, Clip Against Surfaces, Visible To Position String and Color,
				Global.rarityColors[Global.itemRarities[Evaluate Once(Count Of(Global.itemRarities) - 1)]], Default Visibility);
			Modify Global Variable(itemTexts, Append To Array, Last Text ID);
			Wait(0.100, Ignore Condition);
			Event Player.weaponProperties = Array(Empty Array, Empty Array);
			Event Player.weaponPower = 0;
			Event Player.itemNames[0] = Custom String("none");
			Event Player.itemRarity[0] = 0;
			Event Player.playerUniqueItems[0] = 0;
			"one day we will get to editing 2d arrays"
			Global.saveItemRarity[Slot Of(Event Player)] = Array(0, Event Player.itemRarity[1], Event Player.itemRarity[2],
				Event Player.itemRarity[3], Event Player.itemRarity[4]);
			Global.saveUniqueItems[Slot Of(Event Player)] = Array(0, Event Player.playerUniqueItems[1], Event Player.playerUniqueItems[2],
				Event Player.playerUniqueItems[3], Event Player.playerUniqueItems[4]);
		End;
		Wait(0.100, Ignore Condition);
		Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
		Wait(0.016, Ignore Condition);
		If(Event Player.playerRole == 2);
			Set Player Allowed Heroes(Event Player, All Tank Heroes);
		Else If(Event Player.playerRole == 1);
			Set Player Allowed Heroes(Event Player, All Damage Heroes);
		Else;
			Set Player Allowed Heroes(Event Player, All Support Heroes);
		End;
		Wait Until(Has Spawned(Event Player), 99999);
		Event Player.maxAmmo = Array(Max Ammo(Event Player, 0), Max Ammo(Event Player, 1));
		Call Subroutine(RecalculateStats);
		Wait(0.100, Ignore Condition);
		Teleport(Event Player, Vector(0, 0, 0));
		Global.saveWeaponType[Slot Of(Event Player)] = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Event Player));
	}
}

rule("offering")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 7;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0, 0))
			<= 5) == True;
		Number Of Players(Team 1) > 0;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Cancel Primary Action(All Players(Team 1));
		Play Effect(All Players(All Teams), Good Explosion, Color(Orange), Vector(0, 2, 0), 10);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Vector(0, 2, 0), 10);
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Orange), Vector(0, 2, 0), 10);
		Small Message(All Players(All Teams), Custom String("you have offered your gold to the shrine, and feel luckier!"));
		Global.teamGoldSacrificed += Global.teamGold;
		Global.teamLuck = (Global.teamGoldSacrificed / 5000) ^ 0.500;
		Global.teamGold = 0;
	}
}

rule("celestine elites can hack on hit")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 6;
		Has Status(Victim, Hacked) == False;
		Event Ability != Null;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		If(Event Player.randomRoll <= Event Damage / Max Health(Victim) * 200);
			Set Status(Victim, Event Player, Hacked, 2);
		End;
		Wait(0.250, Ignore Condition);
	}
}

rule("and make nearby allies invisible")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 6;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Set Invisible(Filtered Array(Players Within Radius(Event Player, 7, Team 2, Off), Current Array Element.eliteIndex != 6), All);
		Set Invisible(Filtered Array(All Players(Team 2), Current Array Element.eliteIndex == 6 || Distance Between(Current Array Element,
			Event Player) > 7), None);
		Wait(0.400, Ignore Condition);
		Loop If Condition Is True;
		Set Invisible(All Players(Team 2), None);
	}
}

rule("malachite elites apply healing null")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 7;
		Event Ability != Null;
	}

	actions
	{
		Victim.healingNullTime = 1;
		Wait(0.250, Ignore Condition);
	}
}

rule("and have much higher health")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 7;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Health, Max Health(Event Player) * 0.500, True, False);
	}
}

disabled rule("void-touched elites can root on hit")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 8;
		Has Status(Victim, Rooted) == False;
		Event Ability != Null;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		If(Event Player.randomRoll <= Event Damage / Max Health(Victim) * 200);
			Set Status(Victim, Event Player, Rooted, 2);
		End;
		Wait(0.250, Ignore Condition);
	}
}

rule("and explode on death")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 8;
	}

	actions
	{
		Create Effect(All Players(All Teams), Sphere, Color(Violet), Event Player, 4, Visible To Position and Radius);
		Event Player.eliteEffect = Last Created Entity;
		Wait(1, Ignore Condition);
		Kill(Players Within Radius(Event Player, 4, All Teams, Surfaces And All Barriers), Event Player);
		Destroy Effect(Event Player.eliteEffect);
	}
}

rule("stalwart elites don't move, but deal more damage")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 9;
	}

	actions
	{
		Set Move Speed(Event Player, 0);
		Start Damage Modification(All Players(Team 1), Event Player, 200, Receivers Damagers and Damage Percent);
		Start Damage Modification(Event Player, All Players(Team 1), 50, Receivers Damagers and Damage Percent);
	}
}

rule("curse of the unknown")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.activeCurse == 4;
		Global.battleInProgress == True;
	}

	actions
	{
		Disable Scoreboard(All Players(Team 1));
		Start Forcing Player Outlines(All Players(All Teams), All Players(Team 1), False, Color(White), Default);
		Disable Nameplates(All Players(All Teams), All Players(Team 1));
		Disable Hero HUD(All Players(Team 1));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Enable Hero HUD(All Players(Team 1));
		Enable Nameplates(All Players(All Teams), All Players(Team 1));
		Enable Scoreboard(All Players(Team 1));
		Stop Forcing Player Outlines(All Players(All Teams), All Players(Team 1));
	}
}

rule("curse of the dark")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.challengeModifier == 5;
		Distance Between(Event Player, First Of(Sorted Array(Filtered Array(All Living Players(Team 1), Has Spawned(
			Current Array Element)), Distance Between(Current Array Element, Event Player)))) > 9;
	}

	actions
	{
		Set Invisible(Event Player, All);
		Wait(1.250, Ignore Condition);
		Loop If Condition Is True;
		Set Invisible(Event Player, None);
		Loop If Condition Is True;
	}
}

rule("[changed:p]boss room")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 5;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element)) == True;
		Number Of Players(Team 1) > 0;
		Global.battleInProgress == False;
	}

	actions
	{
		Global.battleInProgress = True;
		Chase Player Variable At Rate(All Players(Team 1), ultimateAmount, 100, 1, Destination and Rate);
		Create Dummy Bot(Global.enemySpawnPool, Team 2, -1, Vector(0, 0, 0), Vector(0, 0, 0));
		Last Created Entity.isBoss = True;
		Global.torchDifficulty = 5;
		Call Subroutine(GuestSpawns);
	}
}

rule("bosses can use ults")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.isBoss == True;
		Array Contains(Array(Hero(D.Va), Hero(Junkrat), Hero(Winston), Hero(Echo), Hero(Brigitte), Hero(Lúcio), Hero(Zenyatta)), Hero Of(
			Event Player)) == False;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Wait(Random Real(8, 10), Ignore Condition);
		Set Ultimate Charge(Event Player, 100);
		Wait(1, Ignore Condition);
		Wait Until(!Is Using Ultimate(Event Player), 99999);
		Loop If Condition Is True;
	}
}

rule("using ults")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.isBoss == True;
		Ultimate Charge Percent(Event Player) == 100;
		Array Contains(Array(Hero(D.Va), Hero(Junkrat), Hero(Winston), Hero(Echo), Hero(Brigitte), Hero(Lúcio), Hero(Zenyatta)), Hero Of(
			Event Player)) == False;
	}

	actions
	{
		Press Button(Event Player, Button(Ultimate));
		Wait(2, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[changed:q]drop items: slot 0")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(0, Team 1)) == False;
		Global.savePlayerRole[0] != -1;
		Players In Slot(0, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 0;
		Call Subroutine(DropItem);
	}
}

rule("[changed:q]drop items: slot 1")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(1, Team 1)) == False;
		Global.savePlayerRole[1] != -1;
		Players In Slot(1, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 1;
		Call Subroutine(DropItem);
	}
}

rule("[changed:q]drop items: slot 2")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(2, Team 1)) == False;
		Global.savePlayerRole[2] != -1;
		Players In Slot(2, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 2;
		Call Subroutine(DropItem);
	}
}

rule("[changed:q]drop items: slot 3")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(3, Team 1)) == False;
		Global.savePlayerRole[3] != -1;
		Players In Slot(3, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 3;
		Call Subroutine(DropItem);
	}
}

rule("[changed:q]drop items: slot 4")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(4, Team 1)) == False;
		Global.savePlayerRole[4] != -1;
		Players In Slot(4, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 4;
		Call Subroutine(DropItem);
	}
}

rule("[changed:q]drop items: slot 5")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(5, Team 1)) == False;
		Global.savePlayerRole[5] != -1;
		Players In Slot(5, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 5;
		Call Subroutine(DropItem);
	}
}

rule("[changed:q]drop items: slot 6")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(6, Team 1)) == False;
		Global.savePlayerRole[6] != -1;
		Players In Slot(6, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 6;
		Call Subroutine(DropItem);
	}
}

rule("[changed:q]drop items: slot 7")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Has Spawned(Players In Slot(7, Team 1)) == False;
		Global.savePlayerRole[7] != -1;
		Players In Slot(7, Team 1).statDamage == 0;
	}

	actions
	{
		"[changed:q] call a general drop item subroutine"
		Global.param1 = 7;
		Call Subroutine(DropItem);
	}
}

rule("[changed:p]dififculty increases")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		"[changed:p] Hardcore!"
		Global.currentDifficulty >= (Global.activeCurse == 1 ? 7 : 5) - (Global.activeCurse == 6);
		Global.torchDifficulty < 5;
	}

	actions
	{
		Global.torchDifficulty += 1;
		Small Message(All Players(All Teams), Custom String("the torch light is fading..."));
		Global.currentDifficulty = 0;
	}
}

rule("[changed:p]death awaits")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.isEventActive == True;
		Global.eventType == 1;
	}

	actions
	{
		Wait(3, Ignore Condition);
		Big Message(All Players(All Teams), Custom String("{0} death awaits...", Hero Icon String(Hero(Lifeweaver))));
		Wait(3, Ignore Condition);
		Play Effect(All Players(All Teams), Moira Fade Disappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Moira Fade Reappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Orisa Halt Implosion Sound, Color(Violet), Vector(0, 0, 0), 200);
		Create Dummy Bot(Hero(Lifeweaver), Team 1, 5, Vector(0, 0, 0), Vector(0, 0, 0));
		Global.alexBot = Last Created Entity;
		Start Forcing Dummy Bot Name(Global.alexBot, Custom String("Alex Houk"));
		Set Status(Global.alexBot, Null, Phased Out, 9999);
		Wait(2, Ignore Condition);
		Communicate(Global.alexBot, Hello);
		Wait(3, Ignore Condition);
		If(Is True For Any(All Players(Team 1), Custom String("{0}", Current Array Element) == Custom String("AlexHouk")));
			Small Message(All Players(All Teams), Custom String("{0} alex houk: feels like i'm staring at the mirror.", Hero Icon String(Hero(
				Lifeweaver))));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} i find this quite interesting.", Hero Icon String(Hero(Lifeweaver))));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} anyways, i have a deal for you.", Hero Icon String(Hero(Lifeweaver))));
		Else;
			Small Message(All Players(All Teams), Custom String("{0} alex houk: hello, travellers.", Hero Icon String(Hero(Lifeweaver))));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} i see, you're making some good progress.", Hero Icon String(Hero(
				Lifeweaver))));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} i have a deal for you.", Hero Icon String(Hero(Lifeweaver))));
		End;
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("{0} let's have a competition.", Hero Icon String(Hero(Lifeweaver))));
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("{0} if you kill more enemies than me, then i'll gift you.", Hero Icon String(
			Hero(Lifeweaver))));
		Wait(3, Ignore Condition);
		Global.eventTimer = 60;
		Chase Global Variable At Rate(eventTimer, 0, 1, Destination and Rate);
		Start Facing(Global.alexBot, Direction Towards(Eye Position(Global.alexBot), Closest Player To(Global.alexBot, Team 2)), 3600,
			To World, Direction and Turn Rate);
	}
}

rule("enemy spawns")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element)) == True;
		Number Of Players(Team 1) > 0;
		Global.isEventActive == True;
		Global.eventTimer > 0;
		Number Of Players(Team 2) < 8;
		Global.eventType == 1;
	}

	actions
	{
		Wait(Global.eliteEventType != 0 ? 2 : 1, Ignore Condition);
		Create Dummy Bot(Global.enemySpawnPool, Team 2, -1, Vector(Random Real(-18, 18), 0, Random Real(-18, 18)), Vector(0, 0, 0));
		Wait Until(Server Load <= 180, 1);
		Loop If Condition Is True;
	}
}

rule("alex")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Lifeweaver;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Global.eventTimer > 0;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
		Start Throttle In Direction(Event Player, Direction Towards(Event Player, First Of(Sorted Array(All Living Players(Team 2), Health(
			Current Array Element)))), 1, To World, Replace existing throttle, Direction and Magnitude);
		Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(First Of(Sorted Array(All Living Players(
			Team 2), Health(Current Array Element))))), 540, To World, Direction and Turn Rate);
		Set Status(Event Player, Null, Unkillable, 9999);
		Set Status(Event Player, Null, Invincible, 9999);
	}
}

rule("percentage damage")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Event Ability != Null;
	}

	actions
	{
		Damage(Victim, Event Player, Max Health(Victim) * 0.100);
	}
}

rule("fade")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Global.eventTimer > 0;
	}

	actions
	{
		Press Button(Event Player, Button(Ability 1));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule(":o:rb")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Global.eventTimer > 0;
	}

	actions
	{
		Press Button(Event Player, Button(Ability 2));
		Wait(0.400, Ignore Condition);
		Press Button(Event Player, Button(Secondary Fire));
		Wait(0.250, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Ability 2), 5);
		Loop If Condition Is True;
	}
}

rule("ult")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Using Ultimate(Event Player) == False;
		Global.eventTimer > 0;
	}

	actions
	{
		Wait(Random Real(6, 10), Ignore Condition);
		Set Ultimate Charge(Event Player, 100);
		Wait(0.250, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
		Wait(1, Ignore Condition);
		Press Button(Event Player, Button(Primary Fire));
		Wait(0.250, Ignore Condition);
		Start Holding Button(Event Player, Button(Primary Fire));
		Loop If Condition Is True;
	}
}

rule("[changed:p]room cleared")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.eventTimer > 0;
		Global.isEventActive == True;
		Global.eventType == 1;
	}

	actions
	{
		Wait Until(Global.eventTimer == 0, 99999);
		Stop Camera(All Players(All Teams));
		Clear Status(All Players(Team 1), Phased Out);
		Stop Facing(All Players(All Teams));
		Stop Throttle In Direction(All Players(All Teams));
		All Players(All Teams).playerPossessed = False;
		All Players(Team 1).recoveryProgress = 420;
		Kill(All Players(Team 2), Null);
		Stop Throttle In Direction(Global.alexBot);
		Wait(3, Ignore Condition);
		If(Global.eventKills >= Player Stat(Global.alexBot, Final Blows));
			Wait(3, Ignore Condition);
			If(Global.eventKills > Player Stat(Global.alexBot, Final Blows));
				Small Message(All Players(All Teams), Custom String("{0} that was impressive.", Hero Icon String(Hero(Moira))));
			Else;
				Small Message(All Players(All Teams), Custom String("{0} uh... we tied?", Hero Icon String(Hero(Moira))));
				Wait(3, Ignore Condition);
				Small Message(All Players(All Teams), Custom String("{0} well, let's say you won.", Hero Icon String(Hero(Moira))));
			End;
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} here is your reward, as i promised.", Hero Icon String(Hero(Moira))));
			Wait(3, Ignore Condition);
			For Global Variable(loopCounter2, 0, (Number Of Players(Team 1) - 1) * 2, 1);
				Global.newItemPos = Direction From Angles(360 / (2 * (Number Of Players(Team 1) - 1)) * Global.loopCounter2, 0) * 12 + Vector(0,
					0.600, 0);
				Global.newItemSlot = Index Of Array Value(Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element))
					[Global.loopCounter2 % (Number Of Players(Team 1) - 1)].itemRarity, First Of(Sorted Array(Filtered Array(All Players(Team 1),
					!Is Dummy Bot(Current Array Element))[Global.loopCounter2 % (Number Of Players(Team 1) - 1)].itemRarity,
					Current Array Element + (Current Array Index == 5 ? 10 : 0))));
				If(Global.newItemSlot == 0);
					Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Filtered Array(All Players(Team 1), !Is Dummy Bot(
						Current Array Element))[Global.loopCounter2 % (Number Of Players(Team 1) - 1)]));
				Else If(Global.newItemSlot <= 3);
					Global.newItemSubtype = Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element))[Global.loopCounter2 % (
						Number Of Players(Team 1) - 1)].playerRole;
				Else;
					Global.newItemSubtype = Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element))[Global.loopCounter2 % (
						Number Of Players(Team 1) - 1)].specialGemstoneType;
				End;
				Call Subroutine(SpawnItemForSlot);
				Wait(0.250, Ignore Condition);
			End;
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} and now, my biggest gift.", Hero Icon String(Hero(Moira))));
			Wait(3, Ignore Condition);
			Global.alexGiftee = Random Value In Array(Filtered Array(All Players(All Teams), !Is Dummy Bot(Current Array Element)));
			Wait(1, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} to you, {1} {2}.", Hero Icon String(Hero(Moira)), Hero Icon String(
				Hero Of(Global.alexGiftee)), Global.alexGiftee));
			Global.newItemPos = Vector(0, 0.600, 0);
			Global.newItemSlot = Index Of Array Value(Global.alexGiftee.itemRarity, First Of(Sorted Array(Filtered Array(
				Global.alexGiftee.itemRarity, Current Array Index != 5), Current Array Element)));
			If(Global.newItemSlot == 0);
				Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Global.alexGiftee));
			Else If(Global.newItemSlot <= 3);
				Global.newItemSubtype = Global.alexGiftee.playerRole;
			Else;
				Global.newItemSubtype = Global.alexGiftee.specialGemstoneType;
			End;
			Global.uniqueItemSpawn = True;
			Call Subroutine(SpawnItemForSlot);
		Else;
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} well, i've bested you this time.", Hero Icon String(Hero(Moira))));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} don't worry, we will get to see eachother again soon.", Hero Icon String(
				Hero(Moira))));
		End;
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("{0} we will meet again as stars.", Hero Icon String(Hero(Moira))));
		Play Effect(All Players(All Teams), Good Explosion, Color(Violet), Vector(0, 0, 0), 15);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Violet), Vector(0, 0, 0), 15);
		Play Effect(All Players(All Teams), Moira Fade Disappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Moira Fade Reappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Orisa Halt Implosion Sound, Color(Violet), Vector(0, 0, 0), 200);
		Destroy Dummy Bot(Team 1, 5);
		Global.temp = Global.roomType[Global.roomPositionX];
		Global.temp[Global.roomPositionY] = Global.currentRoom == 5 ? 8 : 0;
		Global.roomType[Global.roomPositionX] = Global.temp;
		Global.battleInProgress = False;
		Small Message(All Players(All Teams), Custom String("room cleared"));
		Global.currentRoom = Global.currentRoom == 5 ? 8 : 0;
		Respawn(All Players(Team 1));
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Stop Chasing Player Variable(All Players(Team 1), ultimateAmount);
		Global.roomEliteCount = 0;
		Global.isEventActive = False;
		Global.eventOccured = True;
		Stop Camera(All Players(All Teams));
		Clear Status(All Players(Team 1), Phased Out);
		Global.eventType = 0;
		Start Camera(Filtered Array(All Players(Team 1), Current Array Element.thirdPersonOn), Update Every Frame(Ray Cast Hit Position(
			Eye Position(Local Player), Eye Position(Local Player) + Facing Direction Of(Local Player) * -4, All Players(All Teams),
			Local Player, False)), Update Every Frame(Eye Position(Local Player)), 0);
	}
}

rule("extra ult charge")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Array Contains(Event Player.specialProperties[0], 3) == True;
		Event Player.ultimateAmount < 10;
	}

	actions
	{
		Event Player.ultimateAmount = Array Contains(Event Player.specialProperties[0], 3)
			? Event Player.specialProperties[1][Index Of Array Value(Event Player.specialProperties[0], 3)] : 0;
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[new:q] Special Rooms")
{
	event
	{
		Subroutine;
		SpecialRoom;
	}

	actions
	{
		Global.temp = Random Value In Array(Global.unvisitedRooms);
		Modify Global Variable(unvisitedRooms, Remove From Array By Value, Global.temp);
		Global.roomPositionX = Round To Integer(Global.temp / Global.floorMapSize, Down);
		Global.roomPositionY = Global.temp % Global.floorMapSize;
		Global.temp = Global.roomType[Global.roomPositionX];
		Global.temp[Global.roomPositionY] = Global.param1;
		Global.roomType[Global.roomPositionX] = Global.temp;
	}
}

rule("[new:p] general melee")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Melee));
		Wait(Random Real(0.500, 0.500), Ignore Condition);
		Stop Holding Button(Event Player, Button(Melee));
		Wait(Random Real(5, 10), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[new:p] general interact")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Interact));
		Wait(Random Real(2.500, 5), Ignore Condition);
		Stop Holding Button(Event Player, Button(Interact));
		Wait(Random Real(0.500, 1), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[new:p] general jump+crouch")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Is In Air(Event Player) == False;
	}

	actions
	{
		Press Button(Event Player, Button(Jump));
		Wait(Random Real(0.500, 1), Ignore Condition);
		Start Holding Button(Event Player, Button(Crouch));
		Wait(0.500, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(Random Real(1.500, 3), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("hooko")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Roadhog;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Damage(Victim, Event Player, 200);
	}
}

rule("reset on kill")
{
	event
	{
		Player Earned Elimination;
		Team 1;
		Roadhog;
	}

	actions
	{
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Position Of(Event Player), 140);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
	}
}

rule("sigma balls")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Sigma;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Filtered Array(Players in View Angle(Event Player, Team 2, 45), Is Alive(Current Array Element) && Distance Between(
			Event Player, Current Array Element) <= 20), Vector(0, 0, 0) - Facing Direction Of(Event Player), 16, To World,
			Cancel Contrary Motion);
		Damage(Players Within Radius(Event Player, 4, Team 2, Surfaces And Enemy Barriers), Event Player, 20);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("mmmmmmmmmh monke")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Winston;
	}

	actions
	{
		Start Damage Modification(All Players(Team 2), Event Player, 100 + (Max Ammo(Event Player, 0) - Ammo(Event Player, 0)) * 0.500,
			Receivers Damagers and Damage Percent);
	}
}

rule("ignite on critical hits")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Junkrat;
	}

	conditions
	{
		Event Ability != Null;
		Event Damage > 0;
		Event Player.isCritical == True;
	}

	actions
	{
		Set Status(Victim, Event Player, Burning, 2);
		Start Damage Over Time(Victim, Event Player, 2, Event Damage * (0.250 * Event Player.statCriticalPower / Event Player.statDamage));
		Play Effect(All Players(All Teams), Ashe Dynamite Explosion Effect, Team 1, Position Of(Victim) + Vector(0, 0.800, 0), 1);
	}
}

rule("earrape music")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Lúcio;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Set Move Speed(All Players(Team 2), 100);
		If(Is In Alternate Form(Event Player));
			Set Move Speed(Players Within Radius(Event Player, 11, Team 2, Off), 50);
		Else;
			Damage(Players Within Radius(Event Player, 11, Team 2, Off), Event Player, 0.120 * Event Player.statDamage);
		End;
		Wait(0.400, Ignore Condition);
		Loop If Condition Is True;
		Set Move Speed(All Players(Team 2), 100);
	}
}

rule("malice")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Brigitte;
	}

	conditions
	{
		Event Ability != Null;
	}

	actions
	{
		Start Damage Over Time(Players Within Radius(Event Player, 15, Team 2, Off), Event Player, 3, 0.100 * (
			Event Player.isCritical ? Event Player.statCriticalPower : 100) * (Event Player.statHealing / (Event Player.statDamage / 100)
			^ 2 / 100));
		Wait(1, Ignore Condition);
	}
}

rule("special hero descriptions")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.specialHeroDesc = Array(Array(Hero(Sigma), Hero(Roadhog), Hero(Winston), Hero(Ashe), Hero(Junkrat), Hero(Sombra), Hero(Ana),
			Hero(Brigitte), Hero(Lúcio), Hero(Mercy), Hero(Doomfist), Hero(Widowmaker), Hero(Zenyatta), Hero(Wrecking Ball), Hero(Echo),
			Hero(Reinhardt), Hero(Symmetra), Hero(Orisa), Hero(Bastion), Hero(Moira), Hero(Hanzo), Hero(Genji), Hero(Cassidy), Hero(D.Va),
			Hero(Torbjörn), Hero(Reaper), Hero(Sojourn), Hero(Junker Queen), Hero(Lifeweaver), Hero(Ramattra), Hero(Zarya), Hero(Mei),
			Hero(Soldier: 76), Hero(Tracer), Hero(Pharah), Hero(Baptiste), Hero(Kiriko)), Array(Custom String(
			"Kinetic Grasp pulls enemies towards you\r\nand damages them.\r\nUltimate deals much less damage."), Custom String(
			"Chain Hook deals 150 damage instead of 5.\r\nResets its cooldown on elimitation."), Custom String(
			"Deal +0.5% damage per every ammo spent."), Custom String("Reduce cooldown of Coach Gun and Dynamite by 35%."), Custom String(
			"You are immune to ignite effect from Blazing elites.\r\nCritical attacks ignite enemies."), Custom String(
			"Hacked enemies cannot attack at all.\r\nUltimate deals much less damage."), Custom String(
			"Reduce cooldown of Biotic Grenade and Sleep Dart by 35%."), Custom String(
			"Inspire damages nearby enemies.\r\nThis damage scales of your healing stat."), Custom String(
			"Amp It Up applies reverse effect on enemies in range\r\n(healing = damage, speed = slow)."), Custom String(
			"All damage stat increase is converted into healing."), Custom String("reduce cooldowns of your abilities by 35%/20%/20%."),
			Custom String("all critical chance is converted into critical power.\r\nheadshots are always critical."), Custom String(
			"Orb of Harmony adds extra temporary shields\r\nto allies without shields"), Custom String(
			"Your jump height is greatly increased,\r\nand Piledriver cooldown reduced by 50%."), Custom String(
			"max ammo reduced, cooldowns reduced;\r\nlast shot in magazine fires a powerful beam"), Custom String(
			"you move faster by 15%.\r\nyou are immune to all knockback effects"), Custom String(
			"make your allies immune to all damage\r\nfor 10 seconds when using your ultimate."), Custom String(
			"heal 1.5% of missing hp per second"), Custom String(
			"mode shift cooldown reduced to 1 second\r\nuse ability again while in turret form to cancel it early"), Custom String(
			"attacks damage by extra 1% of target's max health\r\n(effect reduced greatly on elites and bosses)"), Custom String(
			"much higher projectile speed. headshots stun enemies."), Custom String("{0} dash deals extra damage over time.",
			Ability Icon String(Hero(Genji), Button(Ability 1))), Custom String("{0} flashbang knocks enemies away with great force.",
			Ability Icon String(Hero(Cassidy), Button(Ability 2))), Custom String(
			"defense matrix recharges faster.\r\nd.va wasn't meant to be playable,\r\nshe can get multiple death injuries when dying"),
			Custom String("hammer (alt weapon) deals 2x damage\r\nand stuns on hit"), Custom String(
			"on hit, execute all enemies below 20% health\r\n(10% for bosses)"), Custom String(
			"railgun shots deal extra splash damage on hit;\r\narea and damage doubled for headshots"), Custom String(
			"heal 10% health when killing an enemy;\r\nif at full health, gain 10% of *total* hp as overhealth\r\n(has a cap)"),
			Custom String("you can't heal yourself.\r\n{0}dash and {1} platform have almost no cooldown", Ability Icon String(Hero(
			Lifeweaver), Button(Ability 1)), Ability Icon String(Hero(Lifeweaver), Button(Secondary Fire))), Custom String(
			"form change cooldown is reduced to 1 second."), Custom String("cooldown of your barriers is halved."), Custom String(
			"primary fire reaches max damage almost instantly."), Custom String("rockets have no cooldown!"), Custom String(
			"blinks are unaffected by cooldown reduction,\r\nbut give you brief damage immunity on use."), Custom String(
			"flight time is reduced.\r\nconcussive blast knocks enemies down."), Custom String(
			"immortality field is unaffected by cooldown reduction,\r\nbut makes your entire team unkillable for 5 seconds."),
			Custom String("yae miko gifts you with infinite ammo\r\nand reduced cooldown of suzu!")));
		Global.uniqueHeroDescriptions = Array(Custom String("shine the sacred light of hope.\r\nheal 25% max health per second"),
			Custom String("they shall tremble before you!\r\nyou move faster, you are immune to knockback effects"), Custom String(
			"time to purge this world of sin.\r\nimmune to knockback, and deal much more knockback"));
	}
}

rule("stalwart elites don't move, but deal more damage")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 9;
	}

	actions
	{
		Set Move Speed(Event Player, 0);
		Wait(0.500, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("hero weapon names")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.heroWeaponNames = Array(Array(Hero(Mercy), Hero(Moira), Hero(Genji), Hero(D.Va), Hero(Zarya), Hero(Sigma), Hero(Orisa),
			Hero(Reinhardt), Hero(Wrecking Ball), Hero(Winston), Hero(Roadhog), Hero(Bastion), Hero(Reaper), Hero(Junkrat), Hero(Doomfist),
			Hero(Cassidy), Hero(Mei), Hero(Widowmaker), Hero(Symmetra), Hero(Soldier: 76), Hero(Sombra), Hero(Torbjörn), Hero(Tracer),
			Hero(Pharah), Hero(Hanzo), Hero(Echo), Hero(Ashe), Hero(Ana), Hero(Baptiste), Hero(Brigitte), Hero(Zenyatta), Hero(Lúcio),
			Hero(Sojourn), Hero(Junker Queen), Hero(Kiriko), Hero(Ramattra), Hero(Lifeweaver)), Array(Custom String("Caduceus Staff"),
			Custom String("Biotic Grasp"), Custom String("Shurikens and Dragonblade"), Custom String("Atomic Guns"), Custom String(
			"Particle Cannon"), Custom String("Kinetic Orbs"), Custom String("Fusion Gun"), Custom String("Rocket Hammer"), Custom String(
			"Quadshot"), Custom String("Tesla Cannon"), Custom String("Scrap Gun"), Custom String("B54 Siege Weaponry"), Custom String(
			"Hellfire Shotguns"), Custom String("Grenade Launcher"), Custom String("The Gauntlet"), Custom String("Peacemaker"),
			Custom String("Cryo Blaster"), Custom String("Widow's Kiss"), Custom String("Photon Projector"), Custom String(
			"Heavy Pulse Rifle"), Custom String("Uzi"), Custom String("Nail Launcher"), Custom String("Pulse Pistols"), Custom String(
			"Rocket Launcher"), Custom String("Storm Bow"), Custom String("Triple Shot"), Custom String("Viper"), Custom String(
			"Biotic Dart Launcher"), Custom String("Biotic Semi-Auto Gun"), Custom String("Rocket Flail"), Custom String(
			"Orbs of Destruction"), Custom String("Sound Amplifier"), Custom String("Heavy Railgun"), Custom String("Shotgun and Dagger"),
			Custom String("Ofuda and Kunais"), Custom String("Void Staff"), Custom String("Blossom of Thorns")));
	}
}

rule("unique weapon names")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.uniqueWeaponNames = Array(Array(Hero(Mercy), Hero(Moira), Hero(Genji), Hero(D.Va), Hero(Zarya), Hero(Sigma), Hero(Orisa),
			Hero(Reinhardt), Hero(Wrecking Ball), Hero(Winston), Hero(Roadhog), Hero(Bastion), Hero(Reaper), Hero(Junkrat), Hero(Doomfist),
			Hero(Cassidy), Hero(Mei), Hero(Widowmaker), Hero(Symmetra), Hero(Soldier: 76), Hero(Sombra), Hero(Torbjörn), Hero(Tracer),
			Hero(Pharah), Hero(Hanzo), Hero(Echo), Hero(Ashe), Hero(Ana), Hero(Baptiste), Hero(Brigitte), Hero(Zenyatta), Hero(Lúcio),
			Hero(Sojourn), Hero(Junker Queen), Hero(Kiriko), Hero(Ramattra), Hero(Lifeweaver)), Array(Custom String("Courage to Defend"),
			Custom String("Realized Potential"), Custom String("Broken Resolve"), Custom String("Super Star"), Custom String(
			"Tobelstein's Generator"), Custom String("Gravity Master"), Custom String("Defender of Numbani"), Custom String(
			"Balderich's Heritage"), Custom String("Champion's Honor"), Custom String("To the Space"), Custom String("The Angler"),
			Custom String("N7 Enforced Siege Weaponry"), Custom String("Reaper's Scythe"), Custom String("The Demolitionist"),
			Custom String("Conflict's Evolution"), Custom String("The Law"), Custom String("Absolute Zero"), Custom String(
			"Life and Death"), Custom String("Our Reality"), Custom String("Grizzled Veteran"), Custom String("æųğĥ"), Custom String(
			"Hellforge"), Custom String("Time Bender"), Custom String("Rocket Queen"), Custom String("Three Dragons"), Custom String(
			"Duplicator"), Custom String("Ol' Reliable"), Custom String("The Shrike"), Custom String("Remembrance"), Custom String(
			"Team Spirit"), Custom String("Absolute Harmony"), Custom String("Tempestous Danza"), Custom String("Risk of Pain"),
			Custom String("Sole Solution"), Custom String("Blessing of Guuji Yae"), Custom String("Supreme Annihilation"), Custom String(
			"Silver Branch of Irminsul")));
		Global.itemUniqueProperties = Array(Array(Custom String(
			"attacks ignite on hit\r\nfire multiple small projectiles along with your attacks"), Custom String(
			"attacks have a chance to freeze on hit\r\nfire fast and powerful icicles along with your attacks"), Custom String(
			"attacks chain damage to another nearby enemy\r\nfire lightning along with your attacks"), Custom String(
			"attacks have a chance to hack on hit\r\nfire small homing projectiles along with your attacks"), Custom String(
			"attacks deal extra splash damage\r\nfire bouncing explosive projectiles along with your attacks"), Custom String(
			"attacks heal most injured ally based on healing stat\r\nsummon three orbs that attack your enemies")), Array(Custom String(
			"When you take damage, heal you and nearby allies based on your healing stat"), Custom String(
			"Stars will rain on the battlefield, healing allies and damaging enemies"), Custom String(
			"Enemies are pushed away from you and take damage scaling with your Healing"), Custom String(
			"You recover your allies 4x faster"), Custom String("Reduce Defense by -50%. Double all damage dealt"), Custom String(
			"Convert ALL of your Health into regenerating Shields.\r\nIncrease Max Health by 50%"), Custom String(
			"Deal 2.5% more damage per 1% Black Blood.\r\nIf you have less than 50% Black Blood, gain 2% per room."), Custom String(
			"Your hero changes occasionally, but your ultimate charge persists.\r\nIncrease all stats by 25%."), Custom String(
			"Damage nearby enemies by your Health Regen. You no longer regen Health passively"), Custom String(
			"Allies in 6m range get half of your Defense as bonus"), Custom String(
			"Increase your size based on your Max Health.\r\nIncrease Max Health by 50%."), Custom String(
			"Damage nearby enemies when you take damage, scaling with health lost"), Null), Array(Custom String(
			"At the beginning of each encounter, give Guiding Light to a random ally"), Custom String(
			"Gain Ultimate charge when attacking enemies.\r\nLose Ultimate charge when you take damage"), Custom String(
			"Remove all of the curses"), Custom String("Heal 25% of Max Health per second"), Custom String(
			"Headshots deal x2 more damage"), Custom String(
			"Increase Damage, Health, Critical Chance and Critical Power by 50%\r\nSometimes Diablo will take you under control"),
			Custom String("Deal 1% more damage per 1% of your current hp (up to +100%)"), Custom String(
			"Deal 10% more damage per every enemy in the room"), Custom String(
			"Allies in 6m range around you deal more damage, scaling with your own damage stat"), Custom String(
			"Increase Dodge Chance by 25%, after all other modifiers"), Custom String(
			"You deal contact damage to enemies, scaling with your Defense"), Custom String(
			"gain ultimate charge when you take damage, scaling with damage taken")), Array(Custom String(
			"Heal nearby allies when you're moving, based on your move speed.\r\nIncrease Move Speed by 30%"), Custom String(
			"Gain unlimited flight. Hold [Space] to rise, hold [L. Ctrl] to descend"), Custom String(
			"Charge Ultimate of nearby allies and yourself 3x faster"), Custom String("Heal 25% more per every Life Blessing"),
			Custom String(
			"Double-tap jump to Dash, allowing you to move through enemies,\r\nand making you invincible for a brief moment"),
			Custom String("Increase Move Speed by 50%. You deal more damage the faster you're moving"), Custom String(
			"Move 2.5% faster and get 1% Defense per every room explored on this floor"), Custom String(
			"Mark a random room at the start of the floor.\r\nVisit marked room to obtain a powerful item"), Custom String(
			"Increase jump height by a lot. Crouch midair to slam down"), Custom String(
			"Double Max Health and increase Defense by 25%, but halve Move Speed"), Custom String(
			"Every 10 seconds launches a quake that knocks down ALL enemies"), Custom String(
			"15% chance that enemies will refuse to fight you")), Array(Custom String("When you kill enemies, they explode"),
			Custom String("Critical attacks fire a lightning bolt at a random enemy, Stunning and damaging them"), Custom String(
			"Once per encounter, revives you for free"), Custom String("When you die or fall below 25% Health, launches a lightning nova"),
			Custom String("You have a 50% chance to reset ability cooldown on use"), Custom String(
			"Take less damage the less Health you have"), Custom String(
			"Your attacks have a 2% chance to instantly kill a non-boss enemy"), Custom String(
			"Damage nearby enemies when dodging an attack"), Custom String("You can take items in Black Hall for free, but..."),
			Custom String("Increase Damage, Health, Defense and Critical Power by 25%.\r\nIf you fall below 35% Health, you explode."),
			Custom String("double maximum amount of potion uses"), Custom String("heal 3% max health when you take damage"), Custom String(
			"50% chance to not spend gold when buying or reforging items"), Custom String(
			"negate the first hit that you take every 10 seconds"), Custom String("attacks deal extra 25% of event damage over 2 seconds"),
			Custom String("Dodge Chance is checked twice"), Custom String(
			"significantly increases chance for guests to show up\r\nguarantees that a guest will appear in boss rooms"), Custom String(
			"Reduce your size based on your Dodge Chance.\r\nIncrease Dodge Chance by 25%.")));
	}
}

rule("heal on taking damage")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 1;
		Event Player.playerRole == 0;
		Event Ability != Null;
	}

	actions
	{
		Heal(Players Within Radius(Event Player, 8, Team 1, Off), Event Player, 20);
	}
}

rule("star storm")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 2;
		Event Player.playerRole == 0;
		Global.battleInProgress == True;
	}

	actions
	{
		Wait(Random Real(0.300, 0.500), Ignore Condition);
		Event Player.targetPosition = Position Of(Random Value In Array(Filtered Array(All Living Players(All Teams), Has Spawned(
			Current Array Element)))) + Direction From Angles(Random Real(0, 360), 0) * Random Real(0, 4);
		Damage(Players Within Radius(Event Player.targetPosition, 4, Team 2, Off), Event Player, 120);
		Heal(Players Within Radius(Event Player.targetPosition, 4, Team 1, Off), Event Player, 480);
		Play Effect(All Players(All Teams), Good Explosion, Color(Aqua), Event Player.targetPosition, 2);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Aqua), Event Player.targetPosition, 25);
		Loop If Condition Is True;
	}
}

rule("regen but reverse")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 1;
		Event Player.playerRole == 2;
		Global.battleInProgress == True;
	}

	actions
	{
		Damage(Players Within Radius(Event Player, 6, Team 2, Off), Event Player, Event Player.statHealth * 0.125 * (
			Event Player.statHealing / Event Player.statDamage));
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("defense")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 2;
		Event Player.playerRole == 2;
	}

	actions
	{
		Start Damage Modification(Remove From Array(Players Within Radius(Event Player, 7, Team 1, Off), Event Player), All Players(
			Team 2), 100 - Event Player.statDefense / 2, Receivers Damagers and Damage Percent);
		Event Player.bodyDamageMod = Last Damage Modification ID;
		Wait Until(Event Player.playerUniqueItems[1] != 2, 99999);
		Stop Damage Modification(Event Player.bodyDamageMod);
	}
}

rule("destroy effect")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.battleInProgress == False;
		Event Player.guidingLightEffect != 0;
	}

	actions
	{
		Destroy Effect(Event Player.guidingLightEffect);
		Event Player.guidingLightEffect = 0;
	}
}

rule("lifesteal")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		(Array Contains(Event Player.weaponProperties[0], 4) || Event Player.guidingLightEffect != 0) == True;
		Event Ability != Null;
	}

	actions
	{
		If(Array Contains(Event Player.weaponProperties[0], 4));
			Heal(Event Player, Null, Event Damage * (Event Player.weaponProperties[1][Index Of Array Value(Event Player.weaponProperties[0], 4)
				] / 50 + (Event Player.guidingLightEffect != 0 ? 0.200 : 0)));
		End;
		Wait(0.250, Ignore Condition);
	}
}

rule("loss")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[2] == 2;
		Event Player.playerRole == 0;
		Event Ability != Null;
	}

	actions
	{
		Event Player.ultimateAmount -= Event Damage / Max Health(Event Player) * 33;
		Wait(0.250, Ignore Condition);
	}
}

rule("headshot")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[2] == 1;
		Event Player.playerRole == 1;
		Event Was Critical Hit == True;
	}

	actions
	{
		Damage(Victim, Event Player, Event Damage / (Event Player.statDamage / 100));
	}
}

rule("possession")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[2] == 2;
		Event Player.playerRole == 1;
		Global.battleInProgress == True;
		Global.isEventActive == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		If(Event Player.randomRoll <= 20 + Global.torchDifficulty * 10);
			Event Player.playerPossessed = True;
			Small Message(Event Player, Custom String("a deep voice is ringing in your head..."));
			Start Throttle In Direction(Event Player, Direction Towards(Event Player, First Of(Sorted Array(All Living Players(Team 2), Health(
				Current Array Element)))), 1, To World, Replace existing throttle, Direction and Magnitude);
			Start Facing(Event Player, Update Every Frame(Direction Towards(Eye Position(Event Player), Eye Position(First Of(Sorted Array(
				All Living Players(Team 2), Health(Current Array Element)))))), 10000, To World, Direction and Turn Rate);
		Else;
			Event Player.playerPossessed = False;
		End;
	}
}

rule("general primary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Primary Fire)) == 0;
		Hero Of(Event Player) != Hero(Moira);
		Event Player.playerPossessed == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Primary Fire));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Primary Fire));
	}
}

rule("[changed:p] general secondary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
		Array Contains(Array(Hero(Bastion), Hero(Reinhardt), Hero(Pharah)), Hero Of(Event Player)) == False;
		Event Player.playerPossessed == True;
	}

	actions
	{
		Wait(Random Real(0.500, 1.500), Ignore Condition);
		Start Holding Button(Event Player, Button(Secondary Fire));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Secondary Fire));
	}
}

rule("general ab1")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Ability Cooldown(Event Player, Button(Ability 1)) == 0 || Ability Charge(Event Player, Button(Ability 1)) > 0) == True;
		Hero Of(Event Player) != Hero(Bastion);
		Event Player.playerPossessed == True;
	}

	actions
	{
		Wait(Random Real(0.500, 1.500), Ignore Condition);
		Start Holding Button(Event Player, Button(Ability 1));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Ability 1));
	}
}

rule("general ab2")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Ability Cooldown(Event Player, Button(Ability 2)) == 0 || Ability Charge(Event Player, Button(Ability 2)) > 0) == True;
		Event Player.playerPossessed == True;
	}

	actions
	{
		Wait(Random Real(0.500, 1.500), Ignore Condition);
		Start Holding Button(Event Player, Button(Ability 2));
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Stop Holding Button(Event Player, Button(Ability 2));
	}
}

rule("damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[2] == 1;
		Event Player.playerRole == 2;
	}

	actions
	{
		Start Damage Modification(All Players(Team 2), Remove From Array(Players Within Radius(Event Player, 7, Team 1, Off),
			Event Player), 100 + Event Player.statDamage / 10, Receivers Damagers and Damage Percent);
		Event Player.headDamageMod = Last Damage Modification ID;
		Wait Until(Event Player.playerUniqueItems[2] != 1, 99999);
		Stop Damage Modification(Event Player.headDamageMod);
	}
}

rule("updating dodge")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Ability != Null;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isDodging = Event Player.randomRoll <= (Event Player.playerUniqueItems[4] == 16 ? 100 - ((
			100 - Event Player.statDodgeChance) / 100) ^ 2 * 100 : Event Player.statDodgeChance);
		Wait(0.250, Ignore Condition);
		If(Event Player.playerUniqueItems[4] == 8 && Event Player.isDodging);
			Damage(Players Within Radius(Event Player, 5, Team 2, Off), Event Player, 60 * (100 / Event Player.statDamage));
		End;
	}
}

rule("dodge")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Start Damage Modification(Filtered Array(All Players(Team 1), Current Array Element.isDodging), All Players(Team 2), 0.001,
			Receivers Damagers and Damage Percent);
	}
}

rule("heal when moving")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[3] == 1;
		Event Player.playerRole == 0;
		Is Moving(Event Player) == True;
	}

	actions
	{
		Heal(Players Within Radius(Event Player, 5, Team 1, Off), Event Player, 10 * Horizontal Speed Of(Event Player));
		Wait(0.400, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("flight")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[3] == 2;
		Event Player.playerRole == 0;
		(Magnitude Of(Throttle Of(Event Player)) > 0 || Is Button Held(Event Player, Button(Crouch)) || Is Button Held(Event Player,
			Button(Jump))) == True;
	}

	actions
	{
		Set Gravity(Event Player, 0);
		Start Accelerating(Event Player, Is Button Held(Event Player, Button(Crouch)) ? Down : (Is Button Held(Event Player, Button(Jump))
			? Up : Throttle Of(Event Player)), 100, 5, To Player, Direction Rate and Max Speed);
		Wait Until(Event Player.playerUniqueItems[3] != 2 || (!Is Button Held(Event Player, Button(Jump)) && !Is Button Held(Event Player,
			Button(Jump)) && Magnitude Of(Throttle Of(Event Player)) == 0), 99999);
		Set Gravity(Event Player, 100);
		Stop Accelerating(Event Player);
	}
}

rule("dash")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[3] == 1;
		Event Player.playerRole == 1;
		Is Button Held(Event Player, Button(Jump)) == True;
		Event Player.isDowned == False;
	}

	actions
	{
		If(Event Player.jumpBuffer);
			Apply Impulse(Event Player, Magnitude Of(Throttle Of(Event Player)) == 0 ? Forward : Throttle Of(Event Player), 30, To Player,
				Cancel Contrary Motion);
			Set Status(Event Player, Null, Invincible, 0.300);
			Event Player.jumpBuffer = False;
			Wait(2, Ignore Condition);
		End;
		Event Player.jumpBuffer = True;
	}
}

rule("reset buffer")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.jumpBuffer == True;
	}

	actions
	{
		Wait(0.225, Abort When False);
		Event Player.jumpBuffer = False;
	}
}

rule("damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[3] == 2;
		Event Player.playerRole == 1;
	}

	actions
	{
		Start Damage Modification(All Players(Team 2), Event Player, 100 + Horizontal Speed Of(Event Player),
			Receivers Damagers and Damage Percent);
		Event Player.feetDamageMod = Last Damage Modification ID;
		Wait Until(Event Player.playerUniqueItems[3] != 2, 99999);
		Stop Damage Modification(Event Player.feetDamageMod);
	}
}

rule("stomp")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[3] == 1;
		Event Player.playerRole == 2;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is In Air(Event Player) == True;
	}

	actions
	{
		Apply Impulse(Event Player, Down, 70, To Player, Cancel Contrary Motion);
		Wait Until(Altitude Of(Event Player) <= 0.500, 99999);
		Play Effect(All Players(All Teams), Junkrat RIP Tire Explosion Effect, Team 1, Position Of(Event Player), 1);
		Play Effect(All Players(All Teams), Junkrat RIP Tire Explosion Sound, Team 1, Position Of(Event Player), 160);
		Damage(Players Within Radius(Event Player, 6, Team 2, Off), Event Player, 200);
		Set Status(Players Within Radius(Event Player, 6, Team 2, Off), Event Player, Knocked Down, 1.250);
		Wait(7, Ignore Condition);
	}
}

rule("h")
{
	event
	{
		Player Dealt Final Blow;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 1;
	}

	actions
	{
		Damage(Players Within Radius(Victim, 5, Team 2, Off), Event Player, 300);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Position Of(Victim), 1);
		Play Effect(All Players(All Teams), Junkrat Concussion Mine Explosion Effect, Team 1, Position Of(Victim), 1);
		Play Effect(All Players(All Teams), Junkrat Concussion Mine Explosion Sound, Color(Red), Position Of(Victim), 110);
	}
}

rule("bolt")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Ability != Null;
		Event Player.playerUniqueItems[4] == 2;
		Event Player.isCritical == True;
	}

	actions
	{
		Event Player.boltTarget = Random Value In Array(All Living Players(Team 2));
		Damage(Event Player.boltTarget, Event Player, Event Damage * (100 / Event Player.statDamage));
		Set Status(Event Player.boltTarget, Event Player, Stunned, 0.250);
		Create Beam Effect(All Players(All Teams), Bad Beam, Eye Position(Event Player), Position Of(Victim) + Vector(0, 0.800, 0), Color(
			Blue), Visible To Position and Radius);
		Event Player.boltEffect = Last Created Entity;
		Wait(0.250, Ignore Condition);
		Destroy Effect(Event Player.boltEffect);
	}
}

rule("restore res")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 3;
		Global.battleInProgress == True;
	}

	actions
	{
		Event Player.resAvailable = True;
	}
}

rule("h")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 4;
		Normalized Health(Event Player) <= 0.250;
	}

	actions
	{
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Effect, Team 1, Position Of(Event Player), 1);
		Play Effect(All Players(All Teams), Bad Explosion, Team 1, Position Of(Event Player), 25);
		Play Effect(All Players(All Teams), Good Explosion, Team 1, Position Of(Event Player), 25);
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Team 1, Position Of(Event Player), 200);
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Team 2, Position Of(Event Player), 200);
		Damage(All Players(Team 2), Event Player, Max Health(Event Player));
		Wait(15, Ignore Condition);
	}
}

rule("damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 6;
	}

	actions
	{
		Start Damage Modification(Event Player, All Players(Team 2), 100 - Normalized Health(Event Player) * 60,
			Receivers Damagers and Damage Percent);
		Event Player.specialDamageMod = Last Damage Modification ID;
		Wait Until(Event Player.playerUniqueItems[4] != 6, 99999);
		Stop Damage Modification(Event Player.specialDamageMod);
	}
}

rule("[changed:q]manipulator")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 9;
	}

	actions
	{
		"[changed:q]make the shop generating code shorter"
		Create In-World Text(All Players(All Teams), Custom String("ancient manipulator - {0} gold used", Round To Integer(
			Global.manipGold, Up)), Vector(0, 3, 0), 1.750, Do Not Clip, Visible To Position and String, Color(Rose), Default Visibility);
		Modify Global Variable(shopEffects, Append To Array, Last Text ID);
		For Global Variable(loopCounter1, 0, 5, 1);
			Create Effect(All Players(All Teams), Ring, Color(Rose), Global.shopPos[Global.loopCounter1], 1.500, Visible To);
			Modify Global Variable(shopEffects, Append To Array, Last Created Entity);
			Create In-World Text(All Players(All Teams), Global.manipText[Global.loopCounter1], Global.shopPos[Global.loopCounter1] + Vector(0,
				1, 0), 1.200, Do Not Clip, Visible To, Color(Rose), Default Visibility);
			Modify Global Variable(shopEffects, Append To Array, Last Text ID);
		End;
		Create Effect(All Players(All Teams), Ring, Color(Rose), Vector(0, 0, 4), 1.500, None);
		Modify Global Variable(shopEffects, Append To Array, Last Created Entity);
		Create In-World Text(All Players(All Teams), Custom String("hold [{0}] to add gold\r\nhold [{1}] to remove gold",
			Input Binding String(Button(Interact)), Input Binding String(Button(Crouch))), Vector(0, 1, 4), 1.200, Do Not Clip,
			Visible To Position and String, Color(Rose), Default Visibility);
		Modify Global Variable(shopEffects, Append To Array, Last Text ID);
		Create In-World Text(All Players(All Teams), Custom String("current success rate: {0}%", Min(Global.manipSuccessRate, 100)),
			Vector(0, 2.200, 0), 1.500, Do Not Clip, Visible To Position String and Color, Global.manipSuccessRate <= 25 ? Color(Red) : (
			Global.manipSuccessRate <= 50 ? Color(Orange) : (Global.manipSuccessRate <= 75 ? Color(Yellow) : Color(Green))),
			Default Visibility);
		Modify Global Variable(shopEffects, Append To Array, Last Text ID);
		Create In-World Text(All Players(All Teams), Custom String("stable upgrade chance: {0}%", Round To Integer(100 * (
			Global.manipSuccessRate / 200) ^ 2, Down)), Vector(0, 1.900, 0), 1.500, Do Not Clip, Visible To Position and String, Color(
			Aqua), Default Visibility);
		Modify Global Variable(shopEffects, Append To Array, Last Text ID);
	}
}

rule("add gold")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.currentRoom == 9;
		Is Button Held(Event Player, Button(Interact)) == True;
		Distance Between(Event Player, Vector(0, 0, 4)) <= 1.500;
		Is Button Held(Event Player, Button(Crouch)) == False;
		Global.teamGold > 0;
		Global.manipSuccessRate < 200;
		Global.manipBusy == False;
	}

	actions
	{
		Global.manipGold += Min(Global.teamGold, (Global.floorNumber + 1) * 50);
		Global.teamGold -= Min(Global.teamGold, (Global.floorNumber + 1) * 50);
		Global.manipSuccessRate = Round To Integer(Min(200, (Global.manipGold / (Global.floorNumber + 1) / 500) ^ 0.500 * 100), Up);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("remove gold")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.currentRoom == 9;
		Is Button Held(Event Player, Button(Interact)) == False;
		Distance Between(Event Player, Vector(0, 0, 4)) <= 1.500;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Global.manipGold > 0;
		Global.manipBusy == False;
	}

	actions
	{
		Global.teamGold += Min(Global.manipGold, (Global.floorNumber + 1) * 50);
		Global.manipGold -= Min(Global.manipGold, (Global.floorNumber + 1) * 50);
		Global.manipSuccessRate = Round To Integer(Min(200, (Global.manipGold / (Global.floorNumber + 1) / 500) ^ 0.500 * 100), Up);
		Wait(0.100, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("manipulating")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.currentRoom == 9;
		Is Button Held(Event Player, Button(Interact)) == True;
		"[changed:q]using shopPos array to locate"
		Is True For Any(Array Slice(Global.shopPos, 0, 5), Distance Between(Current Array Element, Event Player) <= 1.500) == True;
		Event Player.shopCooldown == 0;
		Global.manipBusy == False;
		Global.manipSuccessRate > 0;
	}

	actions
	{
		Global.param1 = Index Of Array Value(Global.shopPos, First Of(Sorted Array(Array Slice(Global.shopPos, 0, 5), Distance Between(
			Current Array Element, Event Player))));
		Event Player.savedItemID = Event Player.playerUniqueItems[Global.param1];
		Call Subroutine(Manipulator);
	}
}

rule("shields")
{
	event
	{
		Player Dealt Healing;
		Team 1;
		Zenyatta;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
		Health Of Type(Healee, Shields) == 0;
	}

	actions
	{
		Add Health Pool To Player(Healee, Shields, Event Player.statHealing * 0.500, False, False);
		Wait(3, Ignore Condition);
	}
}

rule("bem")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Echo;
	}

	conditions
	{
		Ammo(Event Player, 0) == 0;
	}

	actions
	{
		Create Beam Effect(All Players(All Teams), Omnic Slicer Beam, Eye Position(Event Player), Ray Cast Hit Position(Eye Position(
			Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 50, All Players(All Teams), Event Player,
			True), Team 1, Visible To);
		Event Player.echoBeamEffect = Last Created Entity;
		Damage(Players in View Angle(Event Player, Team 2, 7), Event Player, 60);
		Play Effect(All Players(All Teams), Echo Sticky Bomb Explosion Sound, Team 1, Eye Position(Event Player), 90);
		Wait(0.400, Ignore Condition);
		Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
		Destroy Effect(Event Player.echoBeamEffect);
	}
}

rule("orisa")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Orisa;
	}

	conditions
	{
		Normalized Health(Event Player) <= 1;
	}

	actions
	{
		Heal(Event Player, Null, (1 - Normalized Health(Event Player)) * Max Health(Event Player) * 0.015);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("wall")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Symmetra;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Set Status(All Players(Team 1), Event Player, Invincible, 10);
		Big Message(All Players(All Teams), Custom String("{0} {1} creates the barrier! you're immune to all damage!", Hero Icon String(
			Hero(Symmetra)), Event Player));
	}
}

rule("enter the black hall")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 8;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0, 8))
			<= 5) == True;
		Number Of Players(Team 1) > 0;
		Global.specialHallType == 1;
		Global.battleInProgress == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Global.roomPositionX -= 1;
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Set Facing(All Players(Team 1), Right, To World);
		Call Subroutine(OnRoomTransition);
		Wait(0.500, Ignore Condition);
		Global.currentRoom = 10;
		Global.guaranteedWhiteHall = False;
	}
}

rule("black hall")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 10;
	}

	actions
	{
		Global.lockedItems = True;
		For Global Variable(loopCounter5, 0, 7, 1);
			Global.newItemPos = Vector(0, 0.600, 0) + Direction From Angles(50 * Global.loopCounter5, 0) * 12;
			Global.newItemSlot = Random Integer(0, 4);
			If(Global.newItemSlot == 0);
				Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Random Value In Array(All Players(Team 1))));
				Create In-World Text(All Players(All Teams), Custom String("weapon | {0} only", Hero Icon String(
					Global.heroWeaponNames[0][Global.newItemSubtype])), Direction From Angles(Global.loopCounter5 * 50, 0) * 12 + Vector(0, 1.100,
					0), 1.500, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
			Else If(Global.newItemSlot <= 3);
				Global.newItemSubtype = Random Value In Array(Array(0, 1, 1, 1, 2));
				Create In-World Text(All Players(All Teams), Custom String("{1} | {0} only", Array(Custom String("supports"), Custom String("dps"),
					Custom String("tanks"))[Global.newItemSubtype], Array(Custom String("body armor"), Custom String("headgear"), Custom String(
					"boots"))[Global.newItemSlot - 1]), Direction From Angles(Global.loopCounter5 * 50, 0) * 12 + Vector(0, 1.100, 0), 1.500,
					Clip Against Surfaces, Visible To, Color(White), Default Visibility);
			Else;
				Global.newItemSubtype = Random Integer(0, 7);
				Create In-World Text(All Players(All Teams), Custom String("accessory | any hero"), Direction From Angles(Global.loopCounter5 * 50,
					0) * 12 + Vector(0, 1.100, 0), 1.500, Clip Against Surfaces, Visible To, Color(White), Default Visibility);
			End;
			Global.uniqueItemSpawn = True;
			Call Subroutine(SpawnItemForSlot);
			Wait(0.250, Ignore Condition);
		End;
		If(!Is True For Any(All Players(Team 1), Current Array Element.playerRole == 1 && Current Array Element.uniqueHero));
			Create Dummy Bot(Hero(Reinhardt), Team 1, 5, Vector(0, 0, 0), Vector(0, 0, 0));
			Disable Movement Collision With Players(Last Created Entity);
			Start Forcing Player Outlines(Evaluate Once(Last Created Entity), All Players(All Teams), True, Color(Red), Always);
			Start Forcing Dummy Bot Name(Last Created Entity, Custom String("Diablo"));
			Wait(1, Ignore Condition);
			Communicate(Last Created Entity, Hello);
		End;
	}
}

rule("respawn")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.battleInProgress == False;
	}

	actions
	{
		Wait(0.100, Ignore Condition);
		Call Subroutine(RecalculateStats);
	}
}

rule("enter the white hall")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 8;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0, 8))
			<= 5) == True;
		Number Of Players(Team 1) > 0;
		Global.specialHallType == 2;
		Global.battleInProgress == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Global.roomPositionX -= 1;
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Set Facing(All Players(Team 1), Right, To World);
		Call Subroutine(OnRoomTransition);
		Wait(0.500, Ignore Condition);
		Global.currentRoom = 11;
		Global.guaranteedWhiteHall = False;
		Global.torchDifficulty = 0;
	}
}

rule("white hall")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 11;
	}

	actions
	{
		For Global Variable(loopCounter5, 0, 5, 1);
			Global.newItemPos = Vector(0, 0.600, 0) + Direction From Angles(72 * Global.loopCounter5, 0) * 12;
			Global.newItemSlot = Random Integer(0, 4);
			If(Global.newItemSlot == 0);
				Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Random Value In Array(All Players(Team 1))));
			Else If(Global.newItemSlot <= 3);
				Global.newItemSubtype = Random Integer(0, 2);
			Else;
				Global.newItemSubtype = Random Integer(0, 7);
			End;
			Global.uniqueItemSpawn = True;
			Call Subroutine(SpawnItemForSlot);
			Wait(0.250, Ignore Condition);
		End;
		If(!Is True For Any(All Players(Team 1), Current Array Element.playerRole == 0 && Current Array Element.uniqueHero));
			Create Dummy Bot(Hero(Ana), Team 1, 5, Vector(0, 0, 0), Vector(0, 0, 0));
			Disable Movement Collision With Players(Last Created Entity);
			Start Forcing Player Outlines(Evaluate Once(Last Created Entity), All Players(All Teams), True, Color(White), Always);
			Start Forcing Dummy Bot Name(Last Created Entity, Custom String("Petra"));
			Wait(1, Ignore Condition);
			Communicate(Last Created Entity, Hello);
		End;
	}
}

rule("uh please, can you stop possessing ppl")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerPossessed == True;
		Global.battleInProgress == False;
	}

	actions
	{
		Event Player.playerPossessed = False;
	}
}

rule("dmg")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[2] == 3;
		Event Player.playerRole == 1;
	}

	actions
	{
		Start Damage Modification(All Players(Team 2), Event Player, 100 + Normalized Health(Event Player) * 100,
			Receivers Damagers and Damage Percent);
		Event Player.headDamageMod = Last Damage Modification ID;
		Wait Until(Event Player.playerUniqueItems[2] != 3, 99999);
		Stop Damage Modification(Event Player.headDamageMod);
	}
}

rule("dmg^2")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[2] == 4;
		Event Player.playerRole == 1;
	}

	actions
	{
		Start Damage Modification(All Players(Team 2), Event Player, 100 + Number Of Players(Team 2) * 10,
			Receivers Damagers and Damage Percent);
		Event Player.headDamageMod = Last Damage Modification ID;
		Wait Until(Event Player.playerUniqueItems[2] != 4, 99999);
		Stop Damage Modification(Event Player.headDamageMod);
	}
}

rule("regen but reverse")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[2] == 3;
		Event Player.playerRole == 2;
		Global.battleInProgress == True;
	}

	actions
	{
		Damage(Players Within Radius(Event Player, 2.500, Team 2, Off), Event Player, 50 * (100 / (100 - Event Player.statDefense)) * (
			100 / Event Player.statDamage));
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("defense")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Ability != Null;
		Event Player.playerUniqueItems[2] == 4;
		Event Player.playerRole == 2;
	}

	actions
	{
		Event Player.ultimateAmount += Event Damage / Max Health(Event Player) * 100;
		Wait(0.500, Ignore Condition);
	}
}

rule("regen but reverse")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 3;
		Event Player.playerRole == 0;
		Global.battleInProgress == True;
	}

	actions
	{
		Damage(Players Within Radius(Event Player, 10, Team 2, Off), Event Player, 60 * (
			Event Player.statHealing / Event Player.statDamage));
		Apply Impulse(Players Within Radius(Event Player, 10, Team 2, Off), Up, 15, To World, Cancel Contrary Motion);
		Wait(2, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("mystery swap")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 4;
		Event Player.playerRole == 1;
		Global.battleInProgress == True;
	}

	actions
	{
		Event Player.maxAmmo = Array(1000, 1000);
		Wait(Random Real(20, 30), Abort When False);
		Start Forcing Player To Be Hero(Event Player, Random Value In Array(Remove From Array(All Damage Heroes, Array(Hero Of(
			Event Player), Hero(Echo)))));
		Loop If Condition Is True;
	}
}

rule("oh lawd he comin")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 3;
		Event Player.playerRole == 2;
	}

	actions
	{
		Start Scaling Player(Event Player, (Event Player.statHealth / 100) ^ 0.500, True);
		Start Modifying Hero Voice Lines(Event Player, 1 - (Event Player.statHealth / 100) ^ 0.500 * 0.100, True);
		Wait Until(Event Player.playerUniqueItems[1] != 3, 99999);
		Stop Scaling Player(Event Player);
		Stop Modifying Hero Voice Lines(Event Player);
	}
}

rule("damage reflect")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[1] == 4;
		Event Player.playerRole == 2;
		Event Ability != Null;
	}

	actions
	{
		Damage(Attacker, Event Player, Event Damage * (200 / Event Player.statDamage) * (100 / (100 - Event Player.statDefense)));
		Wait(0.250, Ignore Condition);
	}
}

rule("ults")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[3] == 3;
		Event Player.playerRole == 0;
		Global.battleInProgress == True;
	}

	actions
	{
		Players Within Radius(Event Player, 6, Team 1, Off).ultimateAmount += 4;
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("healing")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		(Event Player.playerUniqueItems[3] == 4 || Event Player.uniqueHero) == True;
		Event Player.playerRole == 0;
	}

	actions
	{
		Start Healing Modification(All Players(Team 1), Event Player, 100 + -25 * Min(Event Player.deathInjury, 0),
			Receivers Healers and Healing Percent);
		Event Player.feetDamageMod = Last Healing Modification ID;
		Wait Until(Event Player.playerUniqueItems[3] != 4, 99999);
		Stop Healing Modification(Event Player.feetDamageMod);
	}
}

rule("marked room")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.markedRoom != 0;
		Global.roomPositionX == Round To Integer((Global.markedRoom - 1) / Global.floorMapSize, Down);
		Global.roomPositionY == Round To Integer((Global.markedRoom - 1) % Global.floorMapSize, Down);
	}

	actions
	{
		Wait(1.250, Abort When False);
		Global.markedRoom = 0;
		For Global Variable(loopCounter5, 0, Count Of(Filtered Array(All Players(Team 1),
			Current Array Element.playerRole == 1 && Current Array Element.playerUniqueItems[3] == 4)), 1);
			Global.newItemPos = Vector(0, 0.600, 0) + Direction From Angles(60 * Global.loopCounter5, 0) * 12;
			Global.newItemSlot = Random Integer(0, 4);
			If(Global.newItemSlot == 0);
				Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Random Value In Array(All Players(Team 1))));
			Else If(Global.newItemSlot <= 3);
				Global.newItemSubtype = Random Integer(0, 2);
			Else;
				Global.newItemSubtype = Random Integer(0, 7);
			End;
			Global.uniqueItemSpawn = True;
			Call Subroutine(SpawnItemForSlot);
			Wait(0.250, Ignore Condition);
		End;
	}
}

rule("regen but reverse")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[3] == 3;
		Event Player.playerRole == 2;
		Global.battleInProgress == True;
	}

	actions
	{
		Wait(10, Ignore Condition);
		Damage(All Players(Team 2), Event Player, 200);
		Set Status(All Players(Team 2), Event Player, Knocked Down, 3);
		Loop If Condition Is True;
	}
}

rule("uh oh")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Count Of(Filtered Array(All Players(Team 1),
			Current Array Element.playerRole == 2 && Current Array Element.playerUniqueItems[3] == 4)) > 0;
	}

	actions
	{
		Wait(0.500, Ignore Condition);
		Event Player.randomRoll = Random Real(0, 100);
		If(Event Player.randomRoll <= 100 - 0.850 ^ Count Of(Filtered Array(All Players(Team 1),
			Current Array Element.playerRole == 2 && Current Array Element.playerUniqueItems[3] == 4)) * 100);
			Communicate(Event Player, Goodbye);
			Wait(1, Ignore Condition);
			Kill(Event Player, Null);
		End;
	}
}

rule("black candle.")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.activeCurse != 0;
		Is True For Any(All Players(Team 1), Current Array Element.playerRole == 0 && Current Array Element.playerUniqueItems[2] == 3)
			== True;
	}

	actions
	{
		Global.activeCurse = 0;
	}
}

rule("bulwark elites knock back and stun on hit")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 5;
		Event Ability != Null;
		Hero Of(Victim) != Hero(Junkrat);
		Hero Of(Victim) != Hero(Reinhardt);
	}

	actions
	{
		Apply Impulse(Victim, Direction Towards(Event Player, Victim) + Vector(0, 0.100, 0), Event Damage / Max Health(Victim) * 27,
			To World, Cancel Contrary Motion);
		Set Status(Victim, Event Player, Stunned, 0.125);
		Wait(1.250, Ignore Condition);
	}
}

rule("and knock up nearby enemies")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 5;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(2, Ignore Condition);
		Apply Impulse(Filtered Array(Players Within Radius(Event Player, 6, Team 1, Surfaces And Enemy Barriers), Hero Of(
			Current Array Element) != Hero(Reinhardt)), Up, 15, To World, Cancel Contrary Motion);
		Loop If Condition Is True;
	}
}

rule("tainted elites have no cooldowns xD")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Event Player.eliteIndex == 10;
		Is Alive(Event Player) == True;
	}

	actions
	{
		Wait(1, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
		Set Ability Cooldown(Event Player, Button(Ability 1), 0);
		Set Ability Cooldown(Event Player, Button(Ability 2), 0);
		Loop If Condition Is True;
	}
}

rule("new event xD")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.isEventActive == True;
		Global.eventType == 2;
	}

	actions
	{
		Wait(3, Ignore Condition);
		Big Message(All Players(All Teams), Custom String("{0} the air smells of sweet strawberries...", Hero Icon String(Hero(Mercy))));
		Wait(3, Ignore Condition);
		Play Effect(All Players(All Teams), Moira Fade Disappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Moira Fade Reappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Orisa Halt Implosion Sound, Color(Violet), Vector(0, 0, 0), 200);
		Create Dummy Bot(Hero(Brigitte), Team 1, 5, Vector(0, 0, 0), Vector(0, 0, 0));
		Global.alexBot = Last Created Entity;
		Start Forcing Dummy Bot Name(Global.alexBot, Custom String("Madeline"));
		Set Status(Global.alexBot, Null, Phased Out, 9999);
		Wait(2, Abort When False);
		Communicate(Global.alexBot, Hello);
		Wait(3, Abort When False);
		If(Is True For Any(All Players(Team 1), Custom String("{0}", Current Array Element) == Custom String("AlexHouk")));
			Small Message(All Players(All Teams), Custom String("madeline: wait, alex?"));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("i didn't know you were going to visit us."));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("damn, i'm so confused now..."));
		Else;
			Small Message(All Players(All Teams), Custom String("madeline: oh hi here."));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("it's nice and chill in here, isn't it?"));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("i want to aid you in your adventure."));
		End;
		Wait(3, Abort When False);
		Small Message(All Players(All Teams), Custom String("so, i have something special for you."));
		Wait(3, Abort When False);
		Small Message(All Players(All Teams), Custom String("one of you, step closer."));
		Wait(3, Abort When False);
		Wait Until(Is True For Any(All Players(Team 1), Distance Between(Current Array Element, Global.alexBot) <= 3 && Is Button Held(
			Current Array Element, Button(Interact))), 99999);
		Global.alexGiftee = First Of(Sorted Array(Filtered Array(All Players(Team 1), Distance Between(Current Array Element,
			Global.alexBot) <= 3 && Is Button Held(Current Array Element, Button(Interact))), Distance Between(Current Array Element,
			Global.alexBot)));
		"mfs skipping event be like"
		If(Global.alexGiftee != 0 && Global.eventType == 2);
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("{0} let's dance, {1} {2}!", Hero Icon String(Hero(Mercy)), Hero Icon String(
				Hero Of(Global.alexGiftee)), Global.alexGiftee));
			Wait(3, Ignore Condition);
			Global.eventKills = 0;
			Global.eventTimer = 60.600;
			Create In-World Text(Filtered Array(All Players(All Teams), Global.currentInput != 0), Custom String("press [{0}]",
				Input Binding String(Array(Button(Primary Fire), Button(Secondary Fire), Button(Ability 1), Button(Ability 2), Button(Jump))
				[Global.currentInput - 1])), Vector(0, 3, 0), 2.500, Clip Against Surfaces, Visible To Position and String, Color(White),
				Default Visibility);
			Global.eventInfoText = Last Text ID;
			Start Camera(Global.alexGiftee, Vector(0, 25, 0), Vector(0, 0, 0), 0);
			Chase Global Variable At Rate(eventTimer, 0, 1, Destination and Rate);
		End;
	}
}

rule("updating target")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.eventType == 2;
		Global.isEventActive == True;
		Global.eventTimer > 0;
	}

	actions
	{
		Global.currentInput = Random Integer(1, 5);
		Wait(0.600, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("input")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player == Global.alexGiftee;
		Global.eventType == 2;
		Global.isEventActive == True;
		Global.eventTimer > 0;
		(Is Button Held(Event Player, Button(Primary Fire)) || Is Button Held(Event Player, Button(Secondary Fire)) || Is Button Held(
			Event Player, Button(Ability 1)) || Is Button Held(Event Player, Button(Ability 2)) || Is Button Held(Event Player, Button(
			Jump))) == True;
		Global.currentInput > 0;
	}

	actions
	{
		If(Is Button Held(Event Player, Array(Button(Primary Fire), Button(Secondary Fire), Button(Ability 1), Button(Ability 2), Button(
			Jump))[Global.currentInput - 1]) && Is True For All(Array(Button(Primary Fire), Button(Secondary Fire), Button(Ability 1),
			Button(Ability 2), Button(Jump)), !Is Button Held(Event Player, Current Array Element)
			|| Current Array Index == Global.currentInput - 1));
			Global.eventKills += 1;
			Play Effect(All Players(All Teams), Good Explosion, Array(Color(Red), Color(Blue), Color(Green), Color(Yellow), Color(Purple))
				[Global.currentInput - 1], Array(Vector(-12, 3, 0), Vector(12, 3, 0), Vector(0, 3, -12), Vector(0, 3, 12), Vector(0, 12, 0))
				[Global.currentInput - 1], 4);
			Play Effect(All Players(All Teams), Bad Explosion, Array(Color(Red), Color(Blue), Color(Green), Color(Yellow), Color(Purple))
				[Global.currentInput - 1], Array(Vector(-12, 3, 0), Vector(12, 3, 0), Vector(0, 3, -12), Vector(0, 3, 12), Vector(0, 12, 0))
				[Global.currentInput - 1], 4);
			Play Effect(All Players(All Teams), Buff Impact Sound, Array(Color(Red), Color(Blue), Color(Green), Color(Yellow), Color(Purple))
				[Global.currentInput - 1], Array(Vector(-12, 3, 0), Vector(12, 3, 0), Vector(0, 3, -12), Vector(0, 3, 12), Vector(0, 12, 0))
				[Global.currentInput - 1], 125);
			Play Effect(All Players(All Teams), Debuff Impact Sound, Array(Color(Red), Color(Blue), Color(Green), Color(Yellow), Color(Purple))
				[Global.currentInput - 1], Array(Vector(-12, 3, 0), Vector(12, 3, 0), Vector(0, 3, -12), Vector(0, 3, 12), Vector(0, 12, 0))
				[Global.currentInput - 1], 125);
		End;
		Global.currentInput = 0;
		Wait(0.250, Ignore Condition);
	}
}

rule("end")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.eventType == 2;
		Global.isEventActive == True;
		Global.eventTimer == 0;
		Global.eventInfoText != 0;
		Global.alexGiftee != 0;
	}

	actions
	{
		Wait(2, Abort When False);
		If(Global.alexGiftee.thirdPersonOn);
			Start Camera(Global.alexGiftee, Update Every Frame(Ray Cast Hit Position(Eye Position(Evaluate Once(Global.alexGiftee)),
				Eye Position(Evaluate Once(Global.alexGiftee)) + Facing Direction Of(Evaluate Once(Global.alexGiftee)) * -4, All Players(
				All Teams), Evaluate Once(Global.alexGiftee), False)), Update Every Frame(Eye Position(Evaluate Once(Global.alexGiftee))), 0);
		Else;
			Stop Camera(Global.alexGiftee);
		End;
		Wait(3, Ignore Condition);
		If(Global.eventKills < 25);
			Small Message(All Players(All Teams), Custom String("damn, you missed all of the notes."));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("don't worry, you'll perform better next time!"));
			Wait(3, Ignore Condition);
		Else If(Global.eventKills < 50);
			Small Message(All Players(All Teams), Custom String("Very good, but still far from perfection."));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("keep on trying!"));
			Wait(3, Ignore Condition);
		Else If(Global.eventKills < 75);
			Small Message(All Players(All Teams), Custom String("that was impressive!"));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("i always have fun dancing with people like you!"));
			Wait(3, Ignore Condition);
		Else If(Global.eventKills < 100);
			Small Message(All Players(All Teams), Custom String("wow, such moves!"));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("you sure hit it quite hard!"));
			Wait(3, Ignore Condition);
		Else;
			Small Message(All Players(All Teams), Custom String("absolutely impressive!"));
			Wait(3, Ignore Condition);
			Small Message(All Players(All Teams), Custom String("you hit every single measure!"));
			Wait(3, Ignore Condition);
		End;
		Small Message(All Players(All Teams), Custom String("anyway, here's your reward!"));
		Wait(3, Ignore Condition);
		Global.teamLuck += Round To Integer(Global.eventKills / 25, Down) / 2;
		For Global Variable(loopCounter2, 0, Number Of Players(Team 1) - 1, 1);
			Global.newItemPos = Direction From Angles(360 / (Number Of Players(Team 1) - 1) * Global.loopCounter2, 0) * 12 + Vector(0, 0.600,
				0);
			Global.newItemSlot = Index Of Array Value(Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element))
				[Global.loopCounter2 % (Number Of Players(Team 1) - 1)].itemRarity, First Of(Sorted Array(Filtered Array(All Players(Team 1),
				!Is Dummy Bot(Current Array Element))[Global.loopCounter2 % (Number Of Players(Team 1) - 1)].itemRarity,
				Current Array Element + (Current Array Index == 5 ? 10 : 0))));
			If(Global.newItemSlot == 0);
				Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Filtered Array(All Players(Team 1), !Is Dummy Bot(
					Current Array Element))[Global.loopCounter2 % (Number Of Players(Team 1) - 1)]));
			Else If(Global.newItemSlot <= 3);
				Global.newItemSubtype = Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element))[Global.loopCounter2 % (
					Number Of Players(Team 1) - 1)].playerRole;
			Else;
				Global.newItemSubtype = Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element))[Global.loopCounter2 % (
					Number Of Players(Team 1) - 1)].specialGemstoneType;
			End;
			If(Global.eventKills == 100);
				Global.uniqueItemSpawn = True;
			End;
			Call Subroutine(SpawnItemForSlot);
			Wait(0.250, Ignore Condition);
		End;
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("and now it's time for your reward!"));
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("good job, {1} {2}!", Hero Icon String(Hero Of(Global.alexGiftee)),
			Global.alexGiftee));
		Global.newItemPos = Vector(0, 0.600, 0);
		Global.newItemSlot = Index Of Array Value(Global.alexGiftee.itemRarity, First Of(Sorted Array(Global.alexGiftee.itemRarity,
			Current Array Element + (Current Array Index == 5 ? 10 : 0))));
		If(Global.newItemSlot == 0);
			Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Global.alexGiftee));
		Else If(Global.newItemSlot <= 3);
			Global.newItemSubtype = Global.alexGiftee.playerRole;
		Else;
			Global.newItemSubtype = Global.alexGiftee.specialGemstoneType;
		End;
		If(Global.eventKills < 25);
			Global.newItemRarity = 3;
		Else If(Global.eventKills < 50);
			Global.newItemRarity = 4;
		Else If(Global.eventKills < 75);
			Global.newItemRarity = 7;
		Else;
			Global.newItemRarity = 8;
		End;
		Call Subroutine(SpawnItemForSlot);
		Wait(3, Ignore Condition);
		Global.teamLuck -= Round To Integer(Global.eventKills / 25, Down) / 2;
		Small Message(All Players(All Teams), Custom String("see you!"));
		Play Effect(All Players(All Teams), Moira Fade Disappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Moira Fade Reappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Orisa Halt Implosion Sound, Color(Violet), Vector(0, 0, 0), 200);
		Destroy Dummy Bot(Team 1, 5);
		Global.temp = Global.roomType[Global.roomPositionX];
		Global.temp[Global.roomPositionY] = Global.currentRoom == 5 ? 8 : 0;
		Global.roomType[Global.roomPositionX] = Global.temp;
		Global.battleInProgress = False;
		Small Message(All Players(All Teams), Custom String("room cleared"));
		Global.currentRoom = Global.currentRoom == 5 ? 8 : 0;
		Respawn(All Players(Team 1));
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Stop Chasing Player Variable(All Players(Team 1), ultimateAmount);
		Global.roomEliteCount = 0;
		Global.eventKills = 0;
		Global.isEventActive = False;
		Global.eventOccured = True;
		Clear Status(All Players(Team 1), Phased Out);
		Global.eventType = 0;
		Global.alexGiftee = 0;
		Destroy In-World Text(Global.eventInfoText);
		Global.eventInfoText = 0;
	}
}

rule("info")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.eventType == 2;
		Distance Between(Event Player, Global.alexBot) <= 3;
		Has Spawned(Global.alexBot) == True;
	}

	actions
	{
		Small Message(Event Player, Custom String("press [{0}] to start", Input Binding String(Button(Interact))));
	}
}

rule("percentage damage")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Moira;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == False;
		Event Ability != Null;
	}

	actions
	{
		Damage(Victim, Event Player, Max Health(Victim) * (1 / Event Player.statDamage));
		Wait(0.250, Ignore Condition);
	}
}

rule("dot")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Genji;
	}

	conditions
	{
		Event Ability == Button(Ability 1);
	}

	actions
	{
		Start Damage Over Time(Victim, Event Player, 2, Event Damage * (20 / Event Player.statDamage));
		Wait(0.250, Ignore Condition);
	}
}

rule("stun")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Hanzo;
	}

	conditions
	{
		Event Ability == Button(Primary Fire);
		Event Was Critical Hit == True;
	}

	actions
	{
		Set Status(Victim, Event Player, Stunned, 0.600);
		Wait(0.250, Ignore Condition);
	}
}

rule("bonk")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Cassidy;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
	}

	actions
	{
		Apply Impulse(Victim, Direction Towards(Event Player, Victim) + Vector(0, 0.100, 0), 32, To World, Cancel Contrary Motion);
	}
}

rule("oh wow")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 10;
		Normalized Health(Event Player) <= 0.350;
		Global.battleInProgress == True;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Play Effect(All Players(All Teams), Junkrat RIP Tire Explosion Effect, Team 2, Position Of(Event Player), 1);
		Play Effect(All Players(All Teams), Wrecking Ball Piledriver Impact Effect, Team 2, Position Of(Event Player), 1);
		Play Effect(All Players(All Teams), Winston Jump Pack Landing Sound, Team 2, Position Of(Event Player), 1);
		Play Effect(All Players(All Teams), Junkrat RIP Tire Explosion Sound, Team 2, Position Of(Event Player), 175);
		Play Effect(All Players(All Teams), Wrecking Ball Piledriver Impact Sound, Team 2, Position Of(Event Player), 175);
		Kill(Event Player, Null);
	}
}

rule("transformations")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		((((Event Player.playerRole == 0 && Global.currentRoom == 11) || (Event Player.playerRole == 1 && Global.currentRoom == 10))
			&& Event Player.transformationItemCount >= 3) || (Event Player.potionType == 12 + Event Player.playerRole)) == True;
		(Is True For All(All Players(Team 1),
			Current Array Element.playerRole != Event Player.playerRole || !Current Array Element.uniqueHero) || Workshop Setting Toggle(
			Custom String("cursed"), Custom String("allow multiple transformations"), False, 4)) == True;
		Event Player.uniqueHero == False;
	}

	actions
	{
		Event Player.uniqueHero = True;
		Event Player.itemRarity = Array(8, 0, 0, 0, 0);
		Event Player.playerUniqueItems = Array(0, 0, 0, 0, 0);
		Event Player.weaponPower = 0;
		Event Player.bodyPower = 0;
		Event Player.headPower = 0;
		Event Player.legsPower = 0;
		Event Player.specialPower = 0;
		Event Player.specialGemstoneType = 0;
		Event Player.weaponProperties = Array(Empty Array, Empty Array);
		Event Player.bodyProperties = Array(Empty Array, Empty Array);
		Event Player.headProperties = Array(Empty Array, Empty Array);
		Event Player.legsProperties = Array(Empty Array, Empty Array);
		Event Player.specialProperties = Array(Empty Array, Empty Array);
		Global.savePowers[Slot Of(Event Player)] = Empty Array;
		Global.saveItemNames[Slot Of(Event Player)] = 0;
		Global.saveWeaponProperties[Slot Of(Event Player)] = 0;
		Global.saveBodyProperties[Slot Of(Event Player)] = 0;
		Global.saveHeadProperties[Slot Of(Event Player)] = 0;
		Global.saveLegsProperties[Slot Of(Event Player)] = 0;
		Global.saveSpecialProperties[Slot Of(Event Player)] = 0;
		Global.saveItemRarity[Slot Of(Event Player)] = Array(8, 0, 0, 0, 0);
		Global.saveUniqueItems[Slot Of(Event Player)] = Array(0, 0, 0, 0, 0);
		Global.saveSpecialGemstoneType[Slot Of(Event Player)] = 0;
		If(Event Player.playerRole == 0);
			Event Player.weaponPower = 888;
			Event Player.itemNames = Array(Custom String("+888 hope of the new world"), Custom String("none"), Custom String("none"),
				Custom String("none"), Custom String("none"));
			Wait(0.250, Ignore Condition);
			Big Message(All Players(All Teams), Custom String("the beam of light shines on you..."));
			Start Modifying Hero Voice Lines(Event Player, 0.900, False);
			Set Primary Fire Enabled(Event Player, False);
			Start Scaling Player(Event Player, 1.250, False);
		Else If(Event Player.playerRole == 1);
			Event Player.weaponPower = 666;
			Event Player.itemNames = Array(Custom String("+666 savagery"), Custom String("none"), Custom String("none"), Custom String("none"),
				Custom String("none"));
			Wait(0.250, Ignore Condition);
			Big Message(All Players(All Teams), Custom String("the ground shakes!.."));
			Start Modifying Hero Voice Lines(Event Player, 0.700, False);
			Start Scaling Player(Event Player, 2.250, False);
		Else If(Event Player.playerRole == 2);
			Event Player.weaponPower = 420;
			Event Player.itemNames = Array(Custom String("+420 lunaris"), Custom String("none"), Custom String("none"), Custom String("none"),
				Custom String("none"));
			Wait(0.250, Ignore Condition);
			Big Message(All Players(All Teams), Custom String("the king of nothing descends his lunar throne."));
			Start Modifying Hero Voice Lines(Event Player, 0.500, False);
			Start Scaling Player(Event Player, 1.400, False);
		End;
		Call Subroutine(RecalculateStats);
		Event Player.playerBlackBlood = 0;
		Chase Player Variable At Rate(Event Player, playerRage, 100, Global.battleInProgress ? 2 : 0, Destination and Rate);
		Global.saveUniqueHero[Slot Of(Event Player)] = True;
	}
}

rule("primary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 1;
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		Wait(4, Ignore Condition);
		Set Ultimate Ability Enabled(Event Player, True);
		Wait(0.016, Ignore Condition);
		Set Ultimate Charge(Event Player, 100);
		Wait(0.016, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
		Wait(0.016, Ignore Condition);
		Set Ultimate Ability Enabled(Event Player, False);
		Event Player.primaryComboCount = 0;
		End;
		Loop If Condition Is True;
	}
}

rule("right click")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 1;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
		Event Player.isDowned == False;
		Count Of(Filtered Array(Players Within Radius(Event Player, 4, All Teams, Off), Is Alive(Current Array Element)
			&& !Current Array Element.isDowned && Current Array Element != Event Player)) > 0;
		Event Player.usingAbility1 == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Event Player.abilityTarget = First Of(Sorted Array(Filtered Array(Players Within Radius(Event Player, 4, All Teams, Off),
			Current Array Element != Event Player && !Current Array Element.isDowned), Angle Between Vectors(Facing Direction Of(
			Event Player), Direction Towards(Eye Position(Event Player), Eye Position(Current Array Element)))));
		Set Status(Event Player.abilityTarget, Event Player, Knocked Down, 3.750);
		Attach Players(Event Player.abilityTarget, Event Player, Vector(0, 5, 0));
		Wait(0.500, Ignore Condition);
		Wait Until(Is Button Held(Event Player, Button(Secondary Fire)), 2);
		Detach Players(Event Player.abilityTarget);
		Wait(0.016, Ignore Condition);
		Apply Impulse(Event Player.abilityTarget, Facing Direction Of(Event Player) + Vector(0, 0.100, 0), 65, To World,
			Cancel Contrary Motion);
		Wait(0.100, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Secondary Fire), 5);
		Wait Until(Is On Ground(Event Player.abilityTarget) || Magnitude Of(Velocity Of(Event Player)) <= 2, 99999);
		If(Team Of(Event Player.abilityTarget) != Team 1);
			Damage(Event Player.abilityTarget, Event Player, 25);
		End;
		Damage(Players Within Radius(Event Player.abilityTarget, 8, Team 2, Off), Event Player, 25);
		Clear Status(Event Player.abilityTarget, Knocked Down);
	}
}

rule("shift")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 1;
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Event Player.isDowned == False;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Event Player.usingAbility1 = True;
		Apply Impulse(Event Player, Direction From Angles(Horizontal Facing Angle Of(Event Player), -2.500), 65, To World,
			Cancel Contrary Motion);
		For Player Variable(Event Player, loopCounter, 0, 10, 1);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Position Of(Event Player), 3);
			Play Effect(All Players(All Teams), Good Explosion, Color(Black), Position Of(Event Player), 3);
			Play Effect(All Players(All Teams), Reinhardt Fire Strike Target Impact Sound, Team 2, Position Of(Event Player), 75);
			Damage(Players Within Radius(Event Player, 3, Team 2, Off), Event Player, 15);
			Wait(0.067, Ignore Condition);
		End;
		Set Ability Cooldown(Event Player, Button(Ability 1), 6);
		Event Player.usingAbility1 = False;
	}
}

rule("e")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 1;
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.isDowned == False;
		Event Player.usingAbility1 == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Set Status(Event Player, Null, Rooted, 2.600);
		Wait(0.600, Ignore Condition);
		For Player Variable(Event Player, loopCounter, 0, 20, 1);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Eye Position(Event Player) + Direction From Angles(
				Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player) + Random Real(-15, 15))
				* Random Real(2, 15), 0.600);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Eye Position(Event Player) + Direction From Angles(
				Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player) + Random Real(-15, 15))
				* Random Real(2, 15), 0.600);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Eye Position(Event Player) + Direction From Angles(
				Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player) + Random Real(-15, 15))
				* Random Real(2, 15), 0.600);
			Play Effect(All Players(All Teams), Good Explosion, Color(Blue), Eye Position(Event Player) + Direction From Angles(
				Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player) + Random Real(-15, 15))
				* Random Real(2, 15), 0.600);
			Damage(Filtered Array(Players in View Angle(Event Player, Team 2, 40), Distance Between(Current Array Element, Event Player)
				<= 15), Event Player, 50);
			Wait(0.100, Ignore Condition);
		End;
		Clear Status(Event Player, Rooted);
		Set Ability Cooldown(Event Player, Button(Ability 2), 13);
	}
}

rule("ult")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 1;
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Event Player.playerRage >= 100;
		Event Player.isDowned == False;
		Event Player.usingAbility1 == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Big Message(All Players(All Teams), Custom String("{0} now you'll know my wrath!", Hero Icon String(Hero Of(Event Player))));
		Event Player.abilityEffects = Empty Array;
		For Player Variable(Event Player, loopCounter2, 0, 5, 1);
			Create Beam Effect(All Players(All Teams), Moira Coalescence Beam, Direction From Angles(Event Player.loopCounter2 * 216 % 360, 0)
				* 15, Direction From Angles((Event Player.loopCounter2 + 1) * 216 % 360, 0) * 15, Team 2, Visible To);
			Modify Player Variable(Event Player, abilityEffects, Append To Array, Last Created Entity);
			Wait(1, Ignore Condition);
		End;
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Team 2, Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Effect, Team 2, Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Team 2, Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Junkrat RIP Tire Explosion Sound, Team 2, Vector(0, 0, 0), 200);
		Damage(All Players(Team 2), Event Player, 6666);
		Set Status(All Players(Team 2), Event Player, Knocked Down, 6.666);
		Destroy Effect(Event Player.abilityEffects[0]);
		Destroy Effect(Event Player.abilityEffects[1]);
		Destroy Effect(Event Player.abilityEffects[2]);
		Destroy Effect(Event Player.abilityEffects[3]);
		Destroy Effect(Event Player.abilityEffects[4]);
		Event Player.playerRage = 0;
	}
}

rule("unique ability info")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Global.uniqueAbilityNames = Array(Array(Custom String("revelation"), Custom String("bless"), Custom String("teleport"),
			Custom String("hope shield"), Custom String("genesis")), Array(Custom String("savagery"), Custom String("overpower"),
			Custom String("shadow charge"), Custom String("lightning breath"), Custom String("apocalypse")), Array(Custom String(
			"lunaris"), Custom String("beam of disintegration"), Custom String("quickstep"), Custom String("king's descent"),
			Custom String("spin to win")));
		Global.uniqueAbilityInfo = Array(Array(Custom String(
			"channel a continuous beam of light,\r\nthat heals allies or damages enemies that it hits."), Custom String(
			"heal ally you're looking at\r\nand reset cooldowns for all of their abilities"), Custom String(
			"teleport to the point you're looking at,\r\npush away and stun nearby enemies"), Custom String(
			"cover your ally with a shield,\r\ncompletely protecting them from any harm"), Custom String(
			"summons beams of light to punish your foes.\r\nresurrects yoour whole team.\r\nrequires full rage. hold button to use.")),
			Array(Custom String(
			"devastate enemies with your empowered weapon.\r\nevery fourth attack, show them no mercy, displaying your form of true power."),
			Custom String("grab ally or enemy and throw them!\r\npress button again to release"), Custom String(
			"dash forwards, damaging enemies in front of you"), Custom String(
			"deals huge damage to enemies in front of you.\r\ncan't move while channeling"), Custom String(
			"erase all enemies in sight.\r\nrequires full rage. hold button to use.")), Array(Custom String(
			"damage enemies in sight.\r\nuse after quickstep to unleash your power"), Custom String(
			"fire a beam that continuously damages enemies"), Custom String(
			"dash in your movement direction,\r\ngaining brief invincibility"), Custom String(
			"soar into the air, then slam down,\r\nstunning and damaging all enemies"), Custom String(
			"start spinning quickly, releasing beams\r\nof energy that obliterate anyone\r\nrequires full rage. hold button to use")));
	}
}

rule("transformation effect")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Has Spawned(Event Player.transformationEffect) == False;
	}

	actions
	{
		If(Event Player.playerRole == 1);
			Create Effect(All Players(All Teams), Reaper Wraith Form Effect, Team 2, Event Player, 1, Visible To Position and Radius);
		Else If(Event Player.playerRole == 2);
			Create Effect(All Players(All Teams), Echo Cloning Effect, Team 1, Event Player, 1, Visible To Position and Radius);
		End;
		Event Player.transformationEffect = Last Created Entity;
	}
}

rule("force recalcualte stats")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.forceRecalculateStats == True;
	}

	actions
	{
		Call Subroutine(RecalculateStats);
		Event Player.forceRecalculateStats = False;
		Wait(0.600, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("using potions")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
		Event Player.potionTimeLeft == 0;
		Event Player.potionUses > 0;
		Event Player.isDowned == False;
		Event Player.itemRarity[5] != 0;
	}

	actions
	{
		Wait(0.600, Abort When False);
		Event Player.potionUses -= 1;
		If(Event Player.potionType == 0);
			Heal(Event Player, Null, Max Health(Event Player) * 2.400);
		Else If(Event Player.potionType == 1);
			Start Heal Over Time(Event Player, Null, 15, Max Health(Event Player) * 0.600);
			Event Player.potionTimeLeft = 15;
		Else If(Event Player.potionType == 2);
			Start Damage Modification(All Players(Team 2), Event Player, 100 + 3.333 * Event Player.potionTimeLeft,
				Receivers Damagers and Damage Percent);
			Event Player.potionMod = Last Damage Modification ID;
			Event Player.potionTimeLeft = 30;
			Wait(30, Ignore Condition);
			Stop Damage Modification(Event Player.potionMod);
		Else If(Event Player.potionType == 3);
			Start Damage Modification(Event Player, All Players(Team 2), 25 + 5 * Event Player.potionTimeLeft,
				Receivers Damagers and Damage Percent);
			Event Player.potionMod = Last Damage Modification ID;
			Event Player.potionTimeLeft = 15;
			Wait(15, Ignore Condition);
			Stop Damage Modification(Event Player.potionMod);
		Else If(Event Player.potionType == 4);
			Event Player.potionTimeLeft = 10;
			For Player Variable(Event Player, loopCounter2, 0, 5, 1);
				Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
				Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
				Set Ability Cooldown(Event Player, Button(Ability 1), 0);
				Set Ability Cooldown(Event Player, Button(Ability 2), 0);
				Wait(2, Ignore Condition);
			End;
		Else If(Event Player.potionType == 5);
			Event Player.potionTimeLeft = 15;
		Else If(Event Player.potionType == 6);
			Set Status(Event Player, Null, Phased Out, 2);
			Event Player.potionTimeLeft = 2.250;
		Else If(Event Player.potionType == 7);
			Global.teamLuck += 0.500;
		Else If(Event Player.potionType == 8);
			Event Player.playerBlackBlood -= Min(Event Player.playerBlackBlood, Random Real(25, 50));
			Call Subroutine(RecalculateStats);
		Else If(Event Player.potionType == 9);
			Event Player.ultimateAmount = 100;
		Else If(Event Player.potionType == 10);
			Event Player.statCriticalPower *= 2;
			Event Player.potionTimeLeft = 20;
			Wait(20, Ignore Condition);
			Event Player.statCriticalPower /= 2;
		Else If(Event Player.potionType == 11);
			Global.newItemPos = Nearest Walkable Position(Position Of(Event Player)) + Vector(0, 0.600, 0);
			Call Subroutine(SpawnItem);
		End;
	}
}

rule("heal on damage")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 12;
		Event Ability != Null;
	}

	actions
	{
		Heal(Event Player, Null, Max Health(Event Player) * 0.120);
		Wait(0.400, Ignore Condition);
	}
}

rule("updating dodge")
{
	event
	{
		Player Took Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 14;
		Event Player.playerHolyMantle == True;
	}

	actions
	{
		Event Player.playerHolyMantle = False;
		Set Status(Event Player, Null, Invincible, 0.500);
		Play Effect(Event Player, Buff Explosion Sound, Color(White), Position Of(Event Player), 125);
		Play Effect(Event Player, Ana Biotic Grenade Explosion Sound, Color(White), Position Of(Event Player), 125);
		Play Effect(Event Player, Good Pickup Effect, Color(White), Position Of(Event Player), 3);
	}
}

rule("dodge")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 14;
	}

	actions
	{
		Event Player.playerHolyMantle = True;
		Start Damage Modification(Event Player, All Players(Team 2), Event Player.playerHolyMantle ? 0.001 : 100,
			Receivers Damagers and Damage Percent);
		Event Player.specialDamageMod = Last Damage Modification ID;
		Wait Until(Event Player.playerUniqueItems[4] != 14, 99999);
		Stop Damage Modification(Event Player.specialDamageMod);
	}
}

rule("restore dodge")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 14;
		Event Player.playerHolyMantle == False;
	}

	actions
	{
		Wait(10, Ignore Condition);
		Event Player.playerHolyMantle = True;
	}
}

rule("dot")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[4] == 15;
		Event Ability != Null;
	}

	actions
	{
		Start Damage Over Time(Victim, Event Player, 2, Event Damage * (12.500 / Event Player.statDamage));
		Wait(0.400, Ignore Condition);
	}
}

rule("reset combo")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.primaryComboCount > 0;
	}

	actions
	{
		Wait(3.500, Abort When False);
		Event Player.primaryComboCount = 0;
	}
}

rule("leave")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.eventType == 2;
		Is True For All(Filtered Array(All Players(Team 1), !Is Dummy Bot(Current Array Element)), Is Button Held(Current Array Element,
			Button(Crouch))) == True;
		Has Spawned(Global.alexBot) == True;
	}

	actions
	{
		Wait(0.600, Abort When False);
		Destroy In-World Text(Global.eventInfoText);
		Global.eventInfoText = 0;
		Small Message(All Players(All Teams), Custom String("aw, i thought you wanted to dance with me..."));
		Wait(3, Ignore Condition);
		Destroy Dummy Bot(Team 1, 5);
		Global.temp = Global.roomType[Global.roomPositionX];
		Global.temp[Global.roomPositionY] = Global.currentRoom == 5 ? 8 : 0;
		Global.roomType[Global.roomPositionX] = Global.temp;
		Global.battleInProgress = False;
		Small Message(All Players(All Teams), Custom String("room cleared"));
		Global.currentRoom = Global.currentRoom == 5 ? 8 : 0;
		Respawn(All Players(Team 1));
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Stop Chasing Player Variable(All Players(Team 1), ultimateAmount);
		Global.roomEliteCount = 0;
		Global.eventKills = 0;
		Global.isEventActive = False;
		Global.eventOccured = True;
		Stop Camera(All Players(All Teams));
		Clear Status(All Players(Team 1), Phased Out);
		Global.eventType = 0;
		Global.alexGiftee = 0;
		Start Camera(Filtered Array(All Players(Team 1), Current Array Element.thirdPersonOn), Update Every Frame(Ray Cast Hit Position(
			Eye Position(Local Player), Eye Position(Local Player) + Facing Direction Of(Local Player) * -4, All Players(All Teams),
			Local Player, False)), Update Every Frame(Eye Position(Local Player)), 0);
	}
}

rule("more cursed")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Is True For Any(All Players(Team 1), Has Spawned(Current Array Element)) == True;
		Workshop Setting Toggle(Custom String("cursed"), Custom String("transformation items on run start"), False, 1) == True;
	}

	actions
	{
		For Global Variable(loopCounter4, 0, 3, 1);
			For Global Variable(loopCounter5, 0, Number Of Players(Team 1), 1);
				Global.param2 = Vector(Global.loopCounter5 * 2, 0.600, -2 + Global.loopCounter4 * 2);
				Global.param1 = Global.loopCounter4;
				Call Subroutine(SpawnSoul);
				Wait(0.200, Ignore Condition);
			End;
		End;
	}
}

rule("primary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 0;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Event Player.isDowned == False;
	}

	actions
	{
		Create Beam Effect(All Players(All Teams), Mercy Heal Beam, Update Every Frame(Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 1.200 + Vector(0, -0.400, 0)), Update Every Frame(Ray Cast Hit Position(Eye Position(Event Player),
			Eye Position(Event Player) + Facing Direction Of(Event Player) * 100, All Players(All Teams), Event Player, True)), Team 1,
			Visible To Position and Radius);
		Event Player.primaryEffect = Last Created Entity;
		Wait Until(!Is Button Held(Event Player, Button(Primary Fire)), 99999);
		Destroy Effect(Event Player.primaryEffect);
	}
}

rule("damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 0;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Event Player.isDowned == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Event Player.abilityTarget = Ray Cast Hit Player(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 100, All Players(All Teams), Event Player, True);
		If(Team Of(Event Player.abilityTarget) == Team 1);
			Heal(Event Player.abilityTarget, Event Player, 100);
			Play Effect(All Players(All Teams), Good Explosion, Color(Green), Event Player.abilityTarget, 1);
		Else If(Team Of(Event Player.abilityTarget) == Team 2);
			Damage(Event Player.abilityTarget, Event Player, 20);
			Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Event Player.abilityTarget, 1);
		End;
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("right click")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 0;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.isDowned == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Event Player.abilityTarget = Player Closest To Reticle(Event Player, Team 1);
		If(Event Player.abilityTarget != Null && Array Contains(Players in View Angle(Event Player, Team 1, 30),
			Event Player.abilityTarget));
			Heal(Event Player.abilityTarget, Event Player, 200);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Impact Effect, Team 1, Event Player.abilityTarget, 1);
			Play Effect(All Players(All Teams), Brigitte Repair Pack Armor Effect, Team 1, Event Player.abilityTarget, 1);
			Clear Status(Event Player.abilityTarget, Stunned);
			Clear Status(Event Player.abilityTarget, Frozen);
			Clear Status(Event Player.abilityTarget, Asleep);
			Clear Status(Event Player.abilityTarget, Rooted);
			Clear Status(Event Player.abilityTarget, Hacked);
			Clear Status(Event Player.abilityTarget, Knocked Down);
			Event Player.abilityTarget.recoveryProgress += 50;
			Wait(0.100, Ignore Condition);
			Set Ability Cooldown(Event Player.abilityTarget, Button(Primary Fire), 0);
			Set Ability Cooldown(Event Player.abilityTarget, Button(Secondary Fire), 0);
			Set Ability Cooldown(Event Player.abilityTarget, Button(Ability 1), 0);
			Set Ability Cooldown(Event Player.abilityTarget, Button(Ability 2), 0);
			Set Ability Cooldown(Event Player.abilityTarget, Button(Jump), 0);
			Set Ability Cooldown(Event Player.abilityTarget, Button(Crouch), 0);
			Wait(6 * ((100 - Event Player.statCooldown) / 100), Ignore Condition);
			Loop If Condition Is True;
		End;
	}
}

rule("shift")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 0;
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Event Player.isDowned == False;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Play Effect(All Players(All Teams), Bad Explosion, Color(Aqua), Position Of(Event Player), 7);
		Teleport(Event Player, Nearest Walkable Position(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 100, All Players(All Teams), Event Player, True)));
		Event Player.abilityTarget = Players Within Radius(Event Player, 5, Team 2, Off);
		For Player Variable(Event Player, loopCounter, 0, Count Of(Event Player.abilityTarget), 1);
			Apply Impulse(Event Player.abilityTarget[Event Player.loopCounter], Direction Towards(Event Player,
				Event Player.abilityTarget[Event Player.loopCounter]) + Vector(0, 0.100, 0), 25, To World, Cancel Contrary Motion);
			Damage(Event Player.abilityTarget[Event Player.loopCounter], Event Player, 50);
			Wait(0.016, Ignore Condition);
		End;
		Set Ability Cooldown(Event Player, Button(Ability 1), 7);
	}
}

rule("e")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 0;
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.isDowned == False;
	}

	actions
	{
		Event Player.abilityTarget = Player Closest To Reticle(Event Player, Team 1);
		If(Event Player.abilityTarget != Null && Array Contains(Players in View Angle(Event Player, Team 1, 30),
			Event Player.abilityTarget));
			Set Status(Event Player.abilityTarget, Event Player, Phased Out, 2);
			Set Status(Event Player.abilityTarget, Event Player, Unkillable, 2);
			Create Effect(All Players(All Teams), Sphere, Color(Yellow), Update Every Frame(Position Of(Evaluate Once(
				Event Player.abilityTarget)) + Vector(0, 1, 0)), 2, Visible To Position and Radius);
			Event Player.secondaryEffect = Last Created Entity;
			Wait(2, Ignore Condition);
			Destroy Effect(Event Player.secondaryEffect);
			Set Ability Cooldown(Event Player, Button(Ability 2), 12);
		End;
	}
}

rule("ult")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 0;
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Event Player.playerRage >= 100;
		Event Player.isDowned == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Big Message(All Players(All Teams), Custom String("{0} crack the sky, restore the light!", Hero Icon String(Hero Of(
			Event Player))));
		Create Beam Effect(All Players(All Teams), Symmetra Projector Beam, Event Player.targetPosition,
			Event Player.targetPosition + Vector(0, 50, 0), Team 1, Visible To Position and Radius);
		Event Player.abilityEffects = Last Created Entity;
		All Players(Team 1).recoveryProgress = 420;
		For Player Variable(Event Player, loopCounter2, 0, 88, 1);
			Event Player.targetPosition = Position Of(Random Value In Array(All Living Players(Team 2)));
			Damage(Players Within Radius(Event Player.targetPosition, 4, Team 2, Off), Event Player, 40);
			Play Effect(All Players(All Teams), Ana Biotic Grenade Explosion Effect, Team 1, Event Player.targetPosition, 1);
			Play Effect(All Players(All Teams), Ana Biotic Grenade Explosion Sound, Team 1, Event Player.targetPosition, 150);
			Wait(0.067, Ignore Condition);
		End;
		Destroy Effect(Event Player.abilityEffects);
		Event Player.playerRage = 0;
	}
}

rule("Manipulator")
{
	event
	{
		Subroutine;
		Manipulator;
	}

	actions
	{
		If(Event Player.uniqueHero);
			Small Message(Event Player, Custom String("you can't reforge your items."));
			Abort;
		End;
		Event Player.shopCooldown = 5;
		Global.manipBusy = True;
		If(Event Player.itemRarity[Global.param1] == 0);
			Small Message(Event Player, Custom String("bruh you need an item first"));
			Global.manipBusy = False;
			Abort;
		End;
		Big Message(All Players(All Teams), Custom String("manipulator is working"));
		Wait(3, Ignore Condition);
		Event Player.randomRoll = Random Real(0, 100);
		If(Event Player.randomRoll <= Global.manipSuccessRate);
			"[changed:q] call GeneralShop subroutine"
			Global.newItemSlot = Global.param1;
			Global.newItemPos = Direction From Angles(Random Real(0, 360), 0) * 12 + Vector(0, 0.600, 0);
			If(Global.param1 == 0);
				Global.newItemSubtype = Index Of Array Value(Global.heroWeaponNames[0], Hero Of(Event Player));
			Else If(Global.param1 <= 3);
				Global.newItemSubtype = Event Player.playerRole;
			Else;
				Global.newItemSubtype = Event Player.specialGemstoneType;
			End;
			If(Event Player.itemRarity[Global.param1] < 5 || Event Player.itemRarity[Global.param1] == 7);
				Global.newItemRarity = Event Player.itemRarity[Global.param1] + 1;
			Else If(Event Player.itemRarity[Global.param1] < 7);
				Global.newItemRarity = Event Player.itemRarity[Global.param1] + 2;
			Else;
				Global.newItemRarity = Event Player.itemRarity[Global.param1];
			End;
			Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Effect, Team 1, Vector(0, 0, 0), 1);
			Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Team 1, Vector(0, 0, 0), 150);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= 100 * (Global.manipSuccessRate / 200) ^ 0.500);
				Global.itemUniqueID = Event Player.savedItemID;
				Big Message(All Players(All Teams), Custom String("stable upgrade!"));
			End;
			Call Subroutine(SpawnItemForSlot);
			Wait(0.100, Ignore Condition);
		Else;
			Play Effect(All Players(All Teams), DVa Self Destruct Explosion Effect, Team 1, Vector(0, 0, 0), 1);
			Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Team 1, Vector(0, 0, 0), 150);
			Big Message(All Players(All Teams), Custom String("bruh momento"));
		End;
		If(Global.param1 == 0);
			Event Player.weaponProperties = Array(Empty Array, Empty Array);
			Event Player.weaponPower = 0;
		Else If(Global.param1 == 1);
			Event Player.bodyProperties = Array(Empty Array, Empty Array);
			Event Player.bodyPower = 0;
		Else If(Global.param1 == 2);
			Event Player.headProperties = Array(Empty Array, Empty Array);
			Event Player.headPower = 0;
		Else If(Global.param1 == 3);
			Event Player.legsProperties = Array(Empty Array, Empty Array);
			Event Player.legsPower = 0;
		Else;
			Event Player.specialProperties = Array(Empty Array, Empty Array);
			Event Player.specialPower = 0;
		End;
		Event Player.itemNames[Global.param1] = Custom String("none");
		Event Player.itemRarity[Global.param1] = 0;
		Event Player.playerUniqueItems[Global.param1] = 0;
		"one day we will get to editing 2d arrays"
		Global.temp = Global.saveItemRarity[Slot Of(Event Player)];
		Global.temp[Global.param1] = 0;
		Global.saveItemRarity[Slot Of(Event Player)] = Global.temp;
		Global.temp = Global.saveUniqueItems[Slot Of(Event Player)];
		Global.temp[Global.param1] = 0;
		Global.saveUniqueItems[Slot Of(Event Player)] = Global.temp;
		Call Subroutine(RecalculateStats);
		Global.manipBusy = False;
		If(Event Player.playerUniqueItems[4] == 13);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll > 50);
				Global.teamGold += Global.manipGold;
			End;
		End;
		Global.manipGold = 0;
		Global.manipSuccessRate = 0;
	}
}

rule("sacrifice room")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 12;
	}

	actions
	{
		If(Count Of(Global.stairwellEffect) == 0);
			Create Effect(Filtered Array(All Players(All Teams), !Global.battleInProgress), Sphere, Color(Black), Vector(0, 0, 0), 4,
				Visible To Position and Radius);
			Global.stairwellEffect = Array(Last Created Entity);
			Create In-World Text(Filtered Array(All Players(All Teams), !Global.battleInProgress), Custom String(
				"{0} are you ready to make a sacrifice?\r\nsacrifices: {1}/12", Icon String(Skull), Global.sacrificeRoomUses), Vector(0, 2, 0),
				1.600, Clip Against Surfaces, Visible To Position and String, Color(Black), Default Visibility);
			Modify Global Variable(stairwellEffect, Append To Array, Last Text ID);
		End;
	}
}

rule("TreasureDrop")
{
	event
	{
		Subroutine;
		TreasureDrop;
	}

	actions
	{
		Play Effect(All Players(All Teams), Good Explosion, Color(Orange), Vector(0, 2, 0), 10);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Vector(0, 2, 0), 10);
		Play Effect(All Players(All Teams), Good Pickup Effect, Color(Orange), Vector(0, 2, 0), 10);
		Play Effect(All Players(All Teams), Ana Biotic Grenade Explosion Sound, Team 1, Vector(0, 2, 0), 160);
		Play Effect(All Players(All Teams), Lúcio Sound Barrier Cast Sound, Team 1, Vector(0, 2, 0), 160);
		Wait(1, Ignore Condition);
		Global.randomRoll = Random Real(0, 100);
		"1% legendary chest"
		If(Global.randomRoll <= 2 * (Global.teamLuck + 1));
			Global.specialTreasureType = 2;
			For Global Variable(loopCounter2, 0, 5, 1);
				Play Effect(All Players(All Teams), Ana Biotic Grenade Explosion Sound, Team 1, Direction From Angles(72 * Global.loopCounter2, 0)
					* 10 + Vector(0, 5, 0), 200);
				Play Effect(All Players(All Teams), Good Explosion, Random Value In Array(Array(Color(Red), Color(Orange), Color(Yellow))),
					Direction From Angles(72 * Global.loopCounter2, 0) * 10 + Vector(0, 5, 0), 5);
				Play Effect(All Players(All Teams), Bad Explosion, Random Value In Array(Array(Color(Red), Color(Orange), Color(Yellow))),
					Direction From Angles(72 * Global.loopCounter2, 0) * 10 + Vector(0, 5, 0), 5);
				Wait(0.375, Ignore Condition);
			End;
			Create Effect(All Players(All Teams), Light Shaft, Custom Color(255, Sine From Degrees(Total Time Elapsed * 180) * 255, 0, 255),
				Vector(0, 0, 0), 5, Visible To Position Radius and Color);
			Global.treasureOpenEffect = Last Created Entity;
			Global.treasureItems = Random Integer(5, 6) + Number Of Players(Team 1) * 2;
			Global.treasureOrbs = Empty Array;
			For Global Variable(loopCounter2, 0, Round To Integer(Global.treasureItems / 2, Down), 1);
				Create Effect(All Players(All Teams), Orb, Custom Color(255, Sine From Degrees(Total Time Elapsed * 180) * 255, 0, 255),
					Direction From Angles((Total Time Elapsed * 360 + 360 / Round To Integer(Global.treasureItems / 2, Down) * Evaluate Once(
					Global.loopCounter2)) % 360, 0) * (8 + Sine From Degrees(Total Time Elapsed * 180 % 360) * 2) + Vector(0, 2, 0), 1,
					Visible To Position Radius and Color);
				Modify Global Variable(treasureOrbs, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
			Wait(2, Ignore Condition);
			For Global Variable(loopCounter2, 0, Global.treasureItems - Round To Integer(Global.treasureItems / 2, Down), 1);
				Create Effect(All Players(All Teams), Orb, Custom Color(255, Total Time Elapsed * 180 % 255, 0, 255), Direction From Angles(((
					360 - Total Time Elapsed) * 360 + 360 / (Global.treasureItems - Round To Integer(Global.treasureItems / 2, Down))
					* Evaluate Once(Global.loopCounter2)) % 360, 0) * (13 + Sine From Degrees(Total Time Elapsed * 180 % 360) * 2) + Vector(0, 2,
					0), 1, Visible To Position Radius and Color);
				Modify Global Variable(treasureOrbs, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
			Wait(2, Ignore Condition);
		"15% big chest"
		Else If(Global.randomRoll <= 20 * (Global.teamLuck + 1));
			Global.specialTreasureType = 1;
			Create Effect(All Players(All Teams), Light Shaft, Color(Purple), Vector(0, 0, 0), 3, Visible To Position and Radius);
			Global.treasureOpenEffect = Last Created Entity;
			Global.treasureItems = Random Integer(3, 4) + Round To Integer(Number Of Players(Team 1) * 1.500, Down);
			Global.treasureOrbs = Empty Array;
			For Global Variable(loopCounter2, 0, Global.treasureItems, 1);
				Create Effect(All Players(All Teams), Orb, Evaluate Once(Random Value In Array(Array(Color(Blue), Color(Violet), Color(Purple)))),
					Direction From Angles((Total Time Elapsed * 240 + 360 / Global.treasureItems * Evaluate Once(Global.loopCounter2)) % 360, 0)
					* (8 + Sine From Degrees(Total Time Elapsed * 120 % 360) * 2) + Vector(0, 2, 0), 1, Visible To Position Radius and Color);
				Modify Global Variable(treasureOrbs, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
			Wait(2, Ignore Condition);
		"84.5% small chest"
		Else;
			Global.specialTreasureType = 0;
			Create Effect(All Players(All Teams), Light Shaft, Color(Blue), Vector(0, 0, 0), 1, Visible To Position and Radius);
			Global.treasureOpenEffect = Last Created Entity;
			Global.treasureItems = Random Integer(1, 2) + Number Of Players(Team 1);
			Global.treasureOrbs = Empty Array;
			For Global Variable(loopCounter2, 0, Global.treasureItems, 1);
				Create Effect(All Players(All Teams), Orb, Evaluate Once(Random Value In Array(Array(Color(White), Color(Aqua), Color(Blue)))),
					Direction From Angles((Total Time Elapsed * 180 + 360 / Global.treasureItems * Evaluate Once(Global.loopCounter2)) % 360, 0)
					* (8 + Sine From Degrees(Total Time Elapsed * 90 % 360) * 2) + Vector(0, 2, 0), 1, Visible To Position Radius and Color);
				Modify Global Variable(treasureOrbs, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
			Wait(2, Ignore Condition);
		End;
		Global.teamLuck += Global.specialTreasureType;
		For Global Variable(loopCounter2, 0, Global.treasureItems, 1);
			Destroy Effect(Global.treasureOrbs[Global.loopCounter2]);
			Global.newItemPos = Direction From Angles(360 / Global.treasureItems * Global.loopCounter2, 0) * Random Real(6, 10) + Vector(0,
				0.600, 0);
			Call Subroutine(SpawnItem);
			Wait(0.333, Ignore Condition);
		End;
		Global.teamLuck -= Global.specialTreasureType;
		Destroy Effect(Global.treasureOpenEffect);
	}
}

rule("enter the hall of legends")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 8;
		Is True For All(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0,
			-8)) <= 5) == True;
		Number Of Players(Team 1) > 0;
		Total Time Elapsed <= 3600;
		Global.floorNumber == 6;
		Global.bossRushCounter == 0;
	}

	actions
	{
		Global.param1 = Array(0, 0, 0, 0, -3, 3, -4, -5, -6, -10, -5, -4, -4, 0, -4, -5, 4, 5, 6, 10, 5, 4, 4, 0, 4, 5, 0, 3, 0, -3, 3, 0,
			-3, 0);
		Global.param2 = Array(16, 2, -2, -16, 6, 6, 4, 0, 0, 0, 0, -4, -4, -6, -4, -5, 4, 0, 0, 0, 0, -4, -4, -6, -4, -5, 2, 0, 2, 0, 0,
			-2, 0, -2);
		Global.sigmaDamageMod = Empty Array;
		For Global Variable(loopCounter4, 0, 17, 1);
			Create Beam Effect(All Players(All Teams), Bad Beam, Vector(Global.param1[Global.loopCounter4 * 2],
				20 + Global.param2[Global.loopCounter4 * 2], 19.250), Vector(Global.param1[1 + Global.loopCounter4 * 2],
				20 + Global.param2[1 + Global.loopCounter4 * 2], 19.250), Color(White), Visible To);
			Modify Global Variable(sigmaDamageMod, Append To Array, Last Created Entity);
		End;
		Global.torchDifficulty = 0;
		For Global Variable(loopCounter4, 0, Count Of(Global.itemNames), 1);
			If(Global.itemNames[Global.loopCounter4] != Custom String("none") && Global.itemSlots[Global.loopCounter4] != -1);
				Destroy Effect(Global.itemEffects[Global.loopCounter4]);
				Destroy Effect(Global.extraItemEffects[Global.loopCounter4]);
				Destroy In-World Text(Global.itemTexts[Global.loopCounter4]);
			End;
			Wait(0.016, Ignore Condition);
		End;
		Wait(0.050, Ignore Condition);
		Global.itemNames = Empty Array;
		Global.itemPositions = Empty Array;
		Global.itemSlots = Empty Array;
		Global.itemSubtypes = Empty Array;
		Global.itemEffects = Empty Array;
		Global.itemTexts = Empty Array;
		Global.itemPowers = Empty Array;
		Global.itemRarities = Empty Array;
		Wait(0.016, Ignore Condition);
		Global.itemProperties = Empty Array;
		Global.itemPropertyValue = Empty Array;
		Global.extraItemEffects = Empty Array;
		Global.itemUnique = Empty Array;
		Global.eventInfoText = Randomized Array(Remove From Array(All Heroes, Array(Hero(D.Va), Hero(Zarya), Hero(Moira))));
		Global.battleInProgress = True;
		Chase Player Variable At Rate(All Players(Team 1), ultimateAmount, 100, 1, Destination and Rate);
		While(Global.bossRushCounter < 15);
			Big Message(All Players(All Teams), Custom String("Wave {0}/15", Global.bossRushCounter + 1));
			Create Dummy Bot(Global.eventInfoText[Global.bossRushCounter * 2], Team 2, -1, Vector(8, 0, 0), Vector(0, 0, 0));
			Last Created Entity.isBoss = True;
			Wait(0.500, Ignore Condition);
			Create Dummy Bot(Global.eventInfoText[Global.bossRushCounter * 2 + 1], Team 2, -1, Vector(-8, 0, 0), Vector(0, 0, 0));
			Last Created Entity.isBoss = True;
			Wait Until(Number Of Players(Team 2) == 0, 99999);
			Global.bossRushCounter += 1;
			All Players(Team 1).recoveryProgress = 420;
		End;
		Wait(2, Ignore Condition);
		For Global Variable(loopCounter4, 0, 11, 1);
			Global.newItemPos = Direction From Angles(360 / 11 * Global.loopCounter4, 0) * 12 + Vector(0, 0.600, 0);
			Global.uniqueItemSpawn = True;
			Global.newItemRarity = 8;
			Call Subroutine(SpawnItem);
			Wait(0.250, Ignore Condition);
		End;
		For Global Variable(loopCounter4, 0, 17, 1);
			Destroy Effect(Global.sigmaDamageMod[Global.loopCounter4]);
		End;
		Global.hallBeaten = True;
		If(Is True For Any(All Players(Team 1), Current Array Element.playerRole == 2));
			Global.param2 = Vector(4, 0.600, 4);
			Global.param1 = 2;
			Call Subroutine(SpawnSoul);
		End;
	}
}

rule("EvaluateHallChances")
{
	event
	{
		Subroutine;
		EvaluateHallChance;
	}

	actions
	{
		If(Global.floorNumber > 0);
			If(Global.guaranteedWhiteHall);
				Global.hallChances = Array(0, Min((Global.deathsThisFloor == 0 ? 100 : (Global.deathsThisRoom == 0 ? 36 : 1))
					* 0.500 ^ Global.specialHallCooldown + 25 * Last Of(Sorted Array(All Players(Team 1),
					Current Array Element.transformationItemCount)).transformationItemCount, 100));
			Else If(Global.floorNumber == 1 || Global.usedBlackHall);
				Global.hallChances = Array(Min((Global.deathsThisFloor == 0 ? 100 : (Global.deathsThisRoom == 0 ? 36 : 1))
					* 0.500 ^ Global.specialHallCooldown + 25 * Last Of(Sorted Array(All Players(Team 1),
					Current Array Element.transformationItemCount)).transformationItemCount, 100), 0);
			Else;
				Global.hallChances = Array(Min((Global.deathsThisFloor == 0 ? 50 : (Global.deathsThisRoom == 0 ? 18 : 1))
					* 0.500 ^ Global.specialHallCooldown + 12.500 * Last Of(Sorted Array(All Players(Team 1),
					Current Array Element.transformationItemCount)).transformationItemCount, 50), Min((Global.deathsThisFloor == 0 ? 50 : (
					Global.deathsThisRoom == 0 ? 18 : 1)) * 0.500 ^ Global.specialHallCooldown + 12.500 * Last Of(Sorted Array(All Players(Team 1),
					Current Array Element.transformationItemCount)).transformationItemCount, 50));
			End;
		End;
	}
}

rule("restn't")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.currentRoom == 12;
		((Global.sacrificeRoomUses < 11 && Is True For Any(All Players(Team 1), Has Spawned(Current Array Element) && Distance Between(
			Current Array Element, Vector(0, 0, 0)) <= 2)) || (Global.sacrificeRoomUses >= 11 && Is True For All(All Players(Team 1),
			Has Spawned(Current Array Element) && Distance Between(Current Array Element, Vector(0, 0, 0)) <= 3))) == True;
		Number Of Players(Team 1) > 0;
		Global.battleInProgress == False;
	}

	actions
	{
		Global.temp = Closest Player To(Vector(0, 0, 0), Team 1);
		Set Status(Global.temp, Null, Knocked Down, 1);
		Set Player Health(Global.temp, 1);
		Global.temp.deathInjury += 2;
		Global.sacrificeRoomUses += 1;
		Wait(1, Ignore Condition);
		If(Global.sacrificeRoomUses == 1);
			Global.randomRoll = Random Real(0, 100);
			If(Global.randomRoll <= 50);
				Global.teamGold += 100 * (Global.floorNumber + 1);
				Small Message(All Players(Team 1), Custom String("+{0} gold!", 100 * (Global.floorNumber + 1)));
			End;
			If(Global.hallBeaten);
				Global.newItemSlot = 5;
				Global.newItemPos = Direction From Angles(Random Real(0, 360), 0) * 12 + Vector(0, 0.600, 0);
				Global.newItemSubtype = Max(12 + Random Value In Array(All Players(Team 1)).playerRole, 14);
				Big Message(All Players(All Teams), Custom String("a soul appears?!"));
				Call Subroutine(SpawnItemForSlot);
			End;
		Else If(Global.sacrificeRoomUses == 2);
			Global.teamGold += 100 * (Global.floorNumber + 1);
			Small Message(All Players(Team 1), Custom String("+{0} gold!", 100 * (Global.floorNumber + 1)));
		Else If(Global.sacrificeRoomUses == 3);
			Global.randomRoll = Random Real(0, 100);
			If(Global.randomRoll <= 67);
				If(Global.usedBlackHall);
					Global.usedBlackHall = False;
					Big Message(All Players(All Teams), Custom String("{0} white hall is open again now!.. {0}", Ability Icon String(Hero(Mercy),
						Button(Ability 2))));
				Else;
					Global.guaranteedWhiteHall = True;
					Big Message(All Players(All Teams), Custom String("{0} heavens smile on you! {0}", Ability Icon String(Hero(Mercy), Button(
						Ability 2))));
				End;
			End;
		Else If(Global.sacrificeRoomUses == 4);
			Global.randomRoll = Random Real(0, 100);
			If(Global.randomRoll <= 50);
				Call Subroutine(TreasureDrop);
			End;
		Else If(Global.sacrificeRoomUses == 5);
			Global.randomRoll = Random Real(0, 100);
			If(Global.randomRoll <= 67);
				If(Global.usedBlackHall);
					Global.usedBlackHall = False;
					Big Message(All Players(All Teams), Custom String("{0} white hall is open again now!.. {0}", Ability Icon String(Hero(Mercy),
						Button(Ability 2))));
				Else;
					Global.guaranteedWhiteHall = True;
					Big Message(All Players(All Teams), Custom String("{0} heavens smile on you! {0}", Ability Icon String(Hero(Mercy), Button(
						Ability 2))));
				End;
			Else;
				Global.teamGold += 300 * (Global.floorNumber + 1);
				Small Message(All Players(Team 1), Custom String("+{0} gold!", 300 * (Global.floorNumber + 1)));
			End;
		Else If(Global.sacrificeRoomUses == 6);
			Global.randomRoll = Random Real(0, 100);
			If(Global.randomRoll <= 50);
				Global.newItemPos = Direction From Angles(Random Real(0, 360), 0) * 12 + Vector(0, 0.600, 0);
				Global.uniqueItemSpawn = True;
				Call Subroutine(SpawnItem);
			Else;
				Call Subroutine(TreasureDrop);
			End;
		Else If(Global.sacrificeRoomUses == 7);
			Global.randomRoll = Random Real(0, 100);
			If(Global.randomRoll <= 33);
				For Global Variable(loopCounter5, 0, Number Of Players(Team 1), 1);
					Global.newItemPos = Direction From Angles(Random Real(0, 360), 0) * 12 + Vector(0, 0.600, 0);
					Global.uniqueItemSpawn = True;
					Call Subroutine(SpawnItem);
					Wait(0.250, Ignore Condition);
				End;
			Else;
				Remove From Array(All Players(Team 1), Global.temp).deathInjury -= 1;
				Small Message(All Players(Team 1), Custom String("you feel blessed!"));
			End;
		Else If(Global.sacrificeRoomUses == 8);
			Global.battleInProgress = True;
			Chase Player Variable At Rate(All Players(Team 1), ultimateAmount, 100, 1, Destination and Rate);
			For Global Variable(loopCounter3, 0, Count Of(Filtered Array(All Players(Team 1),
				Current Array Element.playerUniqueItems[2] == 1 && Current Array Element.playerRole == 0)), 1);
				Global.targetPlayer = Random Value In Array(Filtered Array(All Players(Team 1), Current Array Element.guidingLightEffect == 0));
				Create Effect(All Players(All Teams), Good Aura, Color(Yellow), Evaluate Once(Global.targetPlayer), 2,
					Visible To Position and Radius);
				Global.targetPlayer.guidingLightEffect = Last Created Entity;
			End;
			For Global Variable(loopCounter3, 0, 7, 1);
				Create Dummy Bot(Global.enemySpawnPool, Team 2, -1, Vector(Random Real(-18, 18), 0, Random Real(-18, 18)), Vector(0, 0, 0));
				Wait(0.750, Ignore Condition);
				Wait Until(Server Load <= 180, 1);
			End;
		Else If(Global.sacrificeRoomUses == 9);
			Global.battleInProgress = True;
			Chase Player Variable At Rate(All Players(Team 1), ultimateAmount, 100, 1, Destination and Rate);
			Create Dummy Bot(Global.enemySpawnPool, Team 2, -1, Vector(0, 0, 0), Vector(0, 0, 0));
			Last Created Entity.isBoss = True;
		Else If(Global.sacrificeRoomUses == 10);
			Global.randomRoll = Random Real(0, 100);
			If(Global.randomRoll <= 33);
				Global.teamGold += 3000 * (Global.floorNumber + 1);
			Else;
				Remove From Array(All Players(Team 1), Global.temp).deathInjury -= 7;
				Small Message(All Players(Team 1), Custom String("you feel overly blessed!"));
			End;
		Else If(Global.sacrificeRoomUses == 11);
			Global.battleInProgress = True;
			Chase Player Variable At Rate(All Players(Team 1), ultimateAmount, 100, 1, Destination and Rate);
			Create Dummy Bot(Global.enemySpawnPool, Team 2, -1, Vector(0, 0, 0), Vector(0, 0, 0));
			Last Created Entity.isBoss = True;
			Wait(0.500, Ignore Condition);
			Create Dummy Bot(Global.enemySpawnPool, Team 2, -1, Vector(0, 0, 0), Vector(0, 0, 0));
			Last Created Entity.isBoss = True;
		Else;
			Big Message(All Players(All Teams), Custom String("{0} something terrible this way comes! {0}", Icon String(Exclamation Mark)));
			Wait(0.500, Ignore Condition);
			Global.floorNumber = 666;
			Big Message(All Players(All Teams), Custom String("floor {0}", Global.floorNumber));
			Call Subroutine(FloorSetup);
			Wait(0.500, Ignore Condition);
			Call Subroutine(OnRoomTransition);
			All Players(All Teams).forceRecalculateStats = True;
		End;
		Call Subroutine(EvaluateHallChance);
		Wait(1, Ignore Condition);
	}
}

disabled rule("d.va ded")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Event Player.isDowned == False;
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Wait(1, Abort When False);
		Kill(Event Player, Null);
		Loop If Condition Is True;
	}
}

rule("shift")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 2;
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Event Player.isDowned == False;
		Has Status(Event Player, Rooted) == False;
	}

	actions
	{
		Apply Impulse(Event Player, Throttle Of(Event Player) + Vector(0, 0.050, 0), 70, To Player, Cancel Contrary Motion);
		Play Effect(All Players(All Teams), Sigma Accretion Impact Sound, Team 2, Position Of(Event Player), 150);
		Play Effect(All Players(All Teams), Sigma Hypersphere Implosion Sound, Team 1, Position Of(Event Player), 140);
		Set Status(Event Player, Null, Invincible, 0.300);
		Event Player.usingAbility1 = True;
		Set Ability Cooldown(Event Player, Button(Ability 1), 5);
		Wait(0.600, Ignore Condition);
		Event Player.usingAbility1 = False;
	}
}

rule("primary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 2;
		Is Firing Primary(Event Player) == True;
		Event Player.usingAbility1 == True;
	}

	actions
	{
		Wait(0.600, Ignore Condition);
		Set Ultimate Ability Enabled(Event Player, True);
		Wait(0.016, Ignore Condition);
		Set Ultimate Charge(Event Player, 100);
		Wait(0.016, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
		Wait(0.016, Ignore Condition);
		Set Ultimate Ability Enabled(Event Player, False);
	}
}

rule("primary")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 2;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.isDowned == False;
	}

	actions
	{
		Create Beam Effect(All Players(All Teams), Symmetra Projector Beam, Update Every Frame(Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 1.200 + Vector(0, -0.400, 0)), Update Every Frame(Ray Cast Hit Position(Eye Position(
			Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 100, All Players(All Teams), Event Player,
			True)), Team 1, Visible To Position and Radius);
		Event Player.primaryEffect = Last Created Entity;
		Wait Until(!Is Button Held(Event Player, Button(Secondary Fire)), 99999);
		Destroy Effect(Event Player.primaryEffect);
	}
}

rule("damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 2;
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.isDowned == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Event Player.abilityTarget = Ray Cast Hit Player(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 100, All Players(Team 2), Event Player, True);
		Damage(Event Player.abilityTarget, Event Player, 15);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Blue), Event Player.abilityTarget, 1);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("e")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 2;
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.isDowned == False;
		Event Player.usingAbility1 == False;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Start Forcing Player Position(Event Player, Vector(0, 38, 0), False);
		Set Status(Event Player, Null, Invincible, 3);
		Start Facing(Event Player, Down, 3600, To Player, Direction and Turn Rate);
		Wait(3, Ignore Condition);
		Stop Forcing Player Position(Event Player);
		Wait(0.016, Ignore Condition);
		Teleport(Event Player, Vector(0, 0, 0));
		Damage(All Players(Team 2), Event Player, 150);
		Set Status(All Players(Team 2), Event Player, Knocked Down, 2);
		Clear Status(Event Player, Invincible);
		Stop Facing(Event Player);
		Set Ability Cooldown(Event Player, Button(Ability 2), 15);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Effect, Team 1, Position Of(Event Player), 2);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Sound, Team 1, Position Of(Event Player), 200);
	}
}

rule("ult")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.uniqueHero == True;
		Event Player.playerRole == 2;
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Event Player.playerRage >= 100;
		Event Player.isDowned == False;
		Event Player.usingAbility1 == False;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Big Message(All Players(All Teams), Custom String("{0} goodbye.", Hero Icon String(Hero Of(Event Player))));
		Event Player.abilityEffects = Empty Array;
		For Player Variable(Event Player, loopCounter2, 0, 8, 1);
			Create Beam Effect(All Players(All Teams), Symmetra Projector Beam, Position Of(Event Player) + Vector(0, 0.200, 0),
				Update Every Frame(Position Of(Event Player) + Vector(0, 0.200, 0) + Direction From Angles((Evaluate Once(
				45 * Event Player.loopCounter2) + Total Time Elapsed * 30 % 360) % 360, 0) * 50), Team 1, Visible To Position and Radius);
			Modify Player Variable(Event Player, abilityEffects, Append To Array, Last Created Entity);
			Wait(0.050, Ignore Condition);
		End;
		Set Status(Event Player, Null, Rooted, 5);
		For Player Variable(Event Player, loopCounter2, 0, 5, 1);
			Wait(1, Ignore Condition);
			Damage(Filtered Array(All Players(Team 2), (Angle Between Vectors(Direction From Angles(Total Time Elapsed * 30 % 360, 0),
				Direction Towards(Current Array Element, Event Player)) + 22.500) % 45 <= 10), Event Player, 108);
			Play Effect(All Players(All Teams), Ana Biotic Grenade Explosion Sound, Team 1, Position Of(Event Player), 175);
			Play Effect(All Players(All Teams), DVa Self Destruct Explosion Sound, Team 2, Position Of(Event Player), 175);
		End;
		For Player Variable(Event Player, loopCounter2, 0, 8, 1);
			Destroy Effect(Event Player.abilityEffects[Event Player.loopCounter2]);
		End;
		Event Player.playerRage = 0;
	}
}

rule("torb bonks")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Torbjörn;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Event Ability == Button(Primary Fire);
	}

	actions
	{
		Damage(Victim, Event Player, Event Damage);
		Set Status(Victim, Event Player, Knocked Down, 0.600);
		Wait(1, Ignore Condition);
	}
}

rule("third person")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
	}

	actions
	{
		Event Player.thirdPersonOn = !Event Player.thirdPersonOn;
		If(Event Player.thirdPersonOn);
			Start Camera(Event Player, Update Every Frame(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * -4, All Players(All Teams), Event Player, False)), Update Every Frame(Eye Position(
				Event Player)), 0);
		Else;
			Stop Camera(Event Player);
		End;
	}
}

rule("the real end")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.floorNumber == 667;
	}

	actions
	{
		Wait(3, Ignore Condition);
		Destroy All Dummy Bots;
		Destroy All Effects;
		Destroy All HUD Text;
		Destroy All Icons;
		Destroy All In-World Text;
		Destroy All Progress Bar HUD Text;
		Destroy All Progress Bar In-World Text;
		Teleport(All Players(Team 1), Vector(0, 50, 0));
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("turns out this dungeon is not so endless..."));
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("at last, you've made it out of here."));
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("with the new power at your possession, your life will never be the same."));
		Wait(3, Ignore Condition);
		Communicate(All Players(All Teams), Emote Up);
		Communicate(All Players(All Teams), Goodbye);
		Wait(3, Ignore Condition);
		Declare Team Victory(Team 1);
	}
}

rule("reapurr")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Reaper;
	}

	conditions
	{
		Event Ability != Null;
		Normalized Health(Victim) <= (Victim.isBoss ? 0.100 : 0.200);
	}

	actions
	{
		Kill(Victim, Event Player);
	}
}

rule("elite enemies")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.roomEliteCount < 8;
		Hero Of(Event Player) != Hero(D.Va);
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Wait(0.100, Ignore Condition);
		If((Event Player.isBoss && Global.floorNumber >= 6) || (!Event Player.isBoss && (
			Global.currentRoom == 12 || Global.eliteEventType != 0 || Event Player.randomRoll <= (
			Global.currentRoom == 4 ? 30 + Global.torchDifficulty * 6 : 6 + Global.torchDifficulty * 1.200))));
			Event Player.eliteIndex = Global.eliteEventType != 0 ? Global.eliteEventType : (Global.floorNumber >= 3 ? Random Integer(1, 10)
				: Random Integer(1, 5));
			Global.roomEliteCount += 1;
			Set Damage Received(Event Player, Event Player.isBoss ? 12 : 30);
			If(!Event Player.isBoss);
				Create Progress Bar In-World Text(All Players(All Teams), Normalized Health(Event Player) * 100, Custom String("{0} {1}",
					Global.eliteNames[Event Player.eliteIndex - 1], Hero Of(Event Player)), Event Player, 0.650, Clip Against Surfaces,
					Global.eliteColors[Event Player.eliteIndex - 1], Color(White), Visible To Position Values and Color, Default Visibility);
				Event Player.eliteBossBar = Last Text ID;
			End;
			Wait(0.100, Ignore Condition);
			If(Event Player.eliteIndex == 1);
				Create Effect(All Players(All Teams), Ashe Dynamite Burning Material Effect, Team 2, Event Player, 1,
					Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 2);
				Create Effect(All Players(All Teams), Mei Frozen Effect, Team 2, Event Player, 1, Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 3);
				Create Effect(All Players(All Teams), Ana Nano Boosted Effect, Team 2, Event Player, 1, Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 4);
				Create Effect(All Players(All Teams), Lúcio Sound Barrier Protected Effect, Team 2, Event Player, 1,
					Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 5);
				Create Effect(All Players(All Teams), Torbjörn Overloading Effect, Team 2, Event Player, 1, Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 6);
				Create Effect(All Players(All Teams), Wrecking Ball Adaptive Shield Target Effect, Team 2, Event Player, 1,
					Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 7);
				Create Effect(All Players(All Teams), Echo Cloning Effect, Team 2, Event Player, 1, Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 8);
				Create Effect(All Players(All Teams), Reaper Wraith Form Effect, Team 2, Event Player, 1, Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 9);
				Create Effect(All Players(All Teams), Baptiste Immortality Field Protected Effect, Team 2, Event Player, 1,
					Visible To Position and Radius);
			Else If(Event Player.eliteIndex == 10);
				Create Effect(All Players(All Teams), Winston Primal Rage Effect, Team 2, Event Player, 1, Visible To Position and Radius);
			End;
			Event Player.eliteEffect = Last Created Entity;
		End;
	}
}

rule("[new:q]drop items on leave")
{
	event
	{
		Subroutine;
		DropItem;
	}

	actions
	{
		Global.param2 = Vector(Random Real(-8, 8), 0, Random Real(-8, 8));
		If(Global.saveUniqueHero[Global.param1]);
			Modify Global Variable(itemPositions, Append To Array, Global.param2 + Vector(0, 0.600, 0));
			Modify Global Variable(itemSlots, Append To Array, 5);
			Modify Global Variable(itemSubtypes, Append To Array, 12 + Global.savePlayerRole[Global.param1]);
			Modify Global Variable(itemRarities, Append To Array, 1);
			Modify Global Variable(itemProperties, Append To Array, Empty Array);
			Modify Global Variable(itemPropertyValue, Append To Array, Empty Array);
			Modify Global Variable(itemUnique, Append To Array, 0);
			Modify Global Variable(itemPowers, Append To Array, 0);
			Modify Global Variable(itemNames, Append To Array, Array(Custom String("soul of petra"), Custom String("soul of diablo"),
				Custom String("soul of mithrix"))[Global.savePlayerRole[Global.param1]]);
			Create Effect(All Players(All Teams), Orb, Color(Violet), Evaluate Once(Global.param2 + Vector(0, 0.600, 0)), 1,
				Visible To Position Radius and Color);
			Modify Global Variable(itemEffects, Append To Array, Last Created Entity);
			Create In-World Text(All Players(All Teams), Global.activeCurse == 3 ? Custom String("???") : Custom String("{0}\r\n{1}",
				Global.itemNames[Evaluate Once(Count Of(Global.itemNames) - 1)], Global.itemSlots[Evaluate Once(Count Of(Global.itemNames) - 1)
				] == 5 ? Custom String(" ") : Custom String("{0}% power", Global.itemPowers[Evaluate Once(Count Of(Global.itemPowers) - 1)])),
				Evaluate Once(Global.param2 + Vector(0, 0.600, 0)), 1, Clip Against Surfaces, Visible To Position String and Color, Color(
				Violet), Default Visibility);
			Modify Global Variable(itemTexts, Append To Array, Last Text ID);
			Modify Global Variable(extraItemEffects, Append To Array, -1);
			Global.saveUniqueHero[Global.param1] = False;
		Else;
			For Global Variable(param3, 0, 5, 1);
				If(Global.saveItemRarity[Global.param1][Global.param3] != 0);
					Modify Global Variable(itemPositions, Append To Array, Global.param2 + Direction From Angles(Global.param3 * 72, 0));
					Modify Global Variable(itemSlots, Append To Array, Global.param3);
					Modify Global Variable(itemSubtypes, Append To Array, Global.param3 == 0 ? Global.saveWeaponType[Global.param1] : (
						Global.param3 < 4 ? Global.savePlayerRole[Global.param1] : Global.saveSpecialGemstoneType[Global.param1]));
					Modify Global Variable(itemRarities, Append To Array, Global.saveItemRarity[Global.param1][Global.param3]);
					Modify Global Variable(itemProperties, Append To Array, Array(
						Global.param3 == 0 ? Global.saveWeaponProperties[Global.param1][0] : (
						Global.param3 == 1 ? Global.saveBodyProperties[Global.param1][0] : (
						Global.param3 == 2 ? Global.saveHeadProperties[Global.param1][0] : (
						Global.param3 == 3 ? Global.saveLegsProperties[Global.param1][0] : Global.saveSpecialProperties[Global.param1][0])))));
					Modify Global Variable(itemPropertyValue, Append To Array, Array(
						Global.param3 == 0 ? Global.saveWeaponProperties[Global.param1][1] : (
						Global.param3 == 1 ? Global.saveBodyProperties[Global.param1][1] : (
						Global.param3 == 2 ? Global.saveHeadProperties[Global.param1][1] : (
						Global.param3 == 3 ? Global.saveLegsProperties[Global.param1][1] : Global.saveSpecialProperties[Global.param1][1])))));
					Modify Global Variable(itemPowers, Append To Array, Array(Global.savePowers[Global.param1][Global.param3]));
					Modify Global Variable(itemNames, Append To Array, Global.saveItemNames[Global.param1][Global.param3]);
					Modify Global Variable(itemUnique, Append To Array, Global.saveUniqueItems[Global.param1][Global.param3]);
					Create Effect(All Players(All Teams), Orb, Global.rarityColors[Global.itemRarities[Evaluate Once(Count Of(Global.itemRarities) - 1)
						]], Evaluate Once(Global.param2 + Direction From Angles(Global.param3 * 72, 0)), 1, Visible To Position Radius and Color);
					Modify Global Variable(itemEffects, Append To Array, Last Created Entity);
					Create In-World Text(All Players(All Teams), Custom String("{0}\r\n{1}% power", Global.itemNames[Evaluate Once(Count Of(
						Global.itemNames) - 1)], Global.itemPowers[Evaluate Once(Count Of(Global.itemPowers) - 1)]), Evaluate Once(
						Global.param2 + Direction From Angles(Global.param3 * 72, 0)), 1, Do Not Clip, Visible To Position String and Color,
						Global.rarityColors[Global.itemRarities[Evaluate Once(Count Of(Global.itemRarities) - 1)]], Default Visibility);
					Modify Global Variable(itemTexts, Append To Array, Last Text ID);
				End;
			End;
			If(Global.saveBlackBlood[Global.param1] > 0);
				All Players(Team 1).playerBlackBlood += Global.saveBlackBlood[Global.param1] / Number Of Players(Team 1);
				Small Message(All Players(Team 1), Custom String("through success of one, comes suffering of others."));
			End;
		End;
		Global.savePlayerRole[Global.param1] = -1;
	}
}

rule("unique weapons behaviour")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[0] != 0;
	}

	actions
	{
		If(Event Player.playerUniqueItems[0] == 1 && !Has Status(Victim, Burning));
			Set Status(Victim, Event Player, Burning, 2);
			Start Damage Over Time(Victim, Event Player, 2, Event Damage * (50 / Event Player.statDamage / (
				Event Player.isCritical ? Event Player.statCriticalPower / 100 : 1)));
		Else If(Event Player.playerUniqueItems[0] == 2);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= 25);
				Set Status(Victim, Event Player, Frozen, 1);
			End;
		Else If(Event Player.playerUniqueItems[0] == 3);
			Damage(Random Value In Array(Remove From Array(Players Within Radius(Victim, 12, Team 2, Off), Victim)), Event Player,
				Event Damage * (50 / Event Player.statDamage / (Event Player.isCritical ? Event Player.statCriticalPower / 100 : 1)));
		Else If(Event Player.playerUniqueItems[0] == 4);
			Event Player.randomRoll = Random Real(0, 100);
			If(Event Player.randomRoll <= 25);
				Set Status(Victim, Event Player, Hacked, 2);
			End;
		Else If(Event Player.playerUniqueItems[0] == 5);
			Damage(Players Within Radius(Victim, 5, Team 2, Off), Event Player, Event Damage * (67 / Event Player.statDamage / (
				Event Player.isCritical ? Event Player.statCriticalPower / 100 : 1)));
		Else;
			Heal(First Of(Sorted Array(Filtered Array(All Living Players(Team 1), Has Spawned(Current Array Element)), Normalized Health(
				Current Array Element))), Event Player, 25);
		End;
		Wait(0.333, Ignore Condition);
	}
}

rule("death explosion")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Global.challengeModifier == 1;
	}

	actions
	{
		Wait(0.400, Ignore Condition);
		Play Effect(All Players(All Teams), Bad Explosion, Color(Orange), Position Of(Event Player), 5);
		Play Effect(All Players(All Teams), Debuff Impact Sound, Color(Orange), Position Of(Event Player), 200);
		Damage(Players Within Radius(Event Player, 5.500, Team 1, Off), Event Player, 100);
		Set Status(Players Within Radius(Event Player, 5.500, Team 1, Off), Event Player, Knocked Down, 1);
	}
}

rule("enhance on death")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Global.challengeModifier == 3;
	}

	actions
	{
		Play Effect(All Players(All Teams), Good Explosion, Color(Green), Position Of(Event Player), 5);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(Orange), Position Of(Event Player), 200);
		Heal(All Players(Team 2), Null, Max Health(Event Player) * 0.500);
	}
}

rule("extra dot")
{
	event
	{
		Player Dealt Damage;
		Team 2;
		All;
	}

	conditions
	{
		Global.challengeModifier == 4;
		Event Ability != Null;
	}

	actions
	{
		Start Damage Over Time(Victim, Null, 2, Max Health(Victim) * 0.005);
	}
}

rule("enhance on death")
{
	event
	{
		Player Died;
		Team 2;
		All;
	}

	conditions
	{
		Global.challengeModifier == 6;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 1);
		If(Event Player.randomRoll < 0.300);
			Create Dummy Bot(Hero Of(Event Player), Team 2, -1, Event Player, Vector(0, 0, 0));
			Set Status(Last Created Entity, Null, Phased Out, 1);
		End;
	}
}

rule("no ults")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.challengeModifier == 7;
		Hero Of(Event Player) != Hero(Echo);
		Event Player.uniqueHero == False;
	}

	actions
	{
		Set Ultimate Ability Enabled(Event Player, False);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
		Set Ultimate Ability Enabled(Event Player, True);
	}
}

rule("dot xD")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Global.challengeModifier == 8;
	}

	actions
	{
		Damage(Event Player, Null, Max Health(Event Player) * 0.020);
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("kazooha makes them go brrrr")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.challengeModifier == 9;
	}

	actions
	{
		Set Move Speed(Event Player, 140);
		Set Projectile Speed(Event Player, 300);
	}
}

rule("haha dash goes brrrrrr")
{
	event
	{
		Ongoing - Each Player;
		Team 2;
		All;
	}

	conditions
	{
		Global.challengeModifier == 10;
	}

	actions
	{
		Wait(Random Real(1, 3), Ignore Condition);
		Apply Impulse(Event Player, Direction From Angles(Random Real(0, 360), -5), 29, To World, Cancel Contrary Motion);
		Loop If Condition Is True;
	}
}

rule("Good Fortunes")
{
	event
	{
		Subroutine;
		GoodFortunes;
	}

	actions
	{
		Global.temp = Array(0, 1, 2, 5, 6);
		If(Global.deathsThisFloor > 0);
			Modify Global Variable(temp, Append To Array, 3);
		End;
		If(Global.activeCurse != 0);
			Modify Global Variable(temp, Append To Array, 4);
		End;
		Global.randomRoll = Random Value In Array(Global.temp);
		If(Global.randomRoll == 0);
			Small Message(All Players(All Teams), Custom String("all challenge rooms removed"));
			For Global Variable(loopCounter1, 0, Global.floorMapSize, 1);
				For Global Variable(loopCounter2, 0, Global.floorMapSize, 1);
					If(Global.roomType[Global.loopCounter1][Global.loopCounter2] == 4);
						Global.temp = Global.roomType[Global.loopCounter1];
						Global.temp[Global.loopCounter2] = 1;
						Global.roomType[Global.loopCounter1] = Global.temp;
					End;
					Wait(0.016, Ignore Condition);
				End;
			End;
		Else If(Global.randomRoll == 1);
			Global.teamGoldSacrificed = 5000 * (Global.teamLuck + 1) ^ 2;
			Global.teamLuck = (Global.teamGoldSacrificed / 5000) ^ 0.500;
			Small Message(All Players(All Teams), Custom String("got +1 luck"));
		Else If(Global.randomRoll == 2);
			Global.teamGold += 1000 * (Global.floorNumber + 1);
			Small Message(All Players(All Teams), Custom String("got extra gold"));
		Else If(Global.randomRoll == 3);
			Global.deathsThisFloor = 0;
			Global.specialHallCooldown = 0;
			Call Subroutine(EvaluateHallChance);
			Small Message(All Players(All Teams), Custom String("hall chances increased"));
		Else If(Global.randomRoll == 4);
			Global.activeCurse = 0;
			Small Message(All Players(All Teams), Custom String("floor curse removed"));
		Else If(Global.randomRoll == 5);
			All Players(Team 1).deathInjury -= 2;
			Small Message(All Players(All Teams), Custom String("received life blessings"));
		Else If(Global.randomRoll == 6);
			Global.newItemPos = Direction From Angles(Random Real(0, 360), 0) * 12 + Vector(0, 0.600, 0);
			Global.uniqueItemSpawn = True;
			Call Subroutine(SpawnItem);
			Small Message(All Players(All Teams), Custom String("got a unique item"));
		End;
	}
}

rule("Bad Fortunes")
{
	event
	{
		Subroutine;
		BadFortunes;
	}

	actions
	{
		Global.temp = Array(0, 5);
		If(Global.teamLuck > 0);
			Modify Global Variable(temp, Append To Array, 1);
		End;
		If(Global.teamGold > 0);
			Modify Global Variable(temp, Append To Array, 2);
		End;
		If(Global.deathsThisFloor == 0 && Global.floorNumber > 0);
			Modify Global Variable(temp, Append To Array, 3);
		End;
		If(Global.activeCurse == 0);
			Modify Global Variable(temp, Append To Array, 4);
		End;
		Global.randomRoll = Random Value In Array(Global.temp);
		If(Global.randomRoll == 0);
			Small Message(All Players(All Teams), Custom String("more challenge rooms appeared"));
			For Global Variable(loopCounter1, 0, Global.floorMapSize, 1);
				For Global Variable(loopCounter2, 0, Global.floorMapSize, 1);
					Global.randomRoll = Random Real(0, 1);
					If(Global.roomType[Global.loopCounter1][Global.loopCounter2] == 1 && Global.randomRoll <= 0.500);
						Global.temp = Global.roomType[Global.loopCounter1];
						Global.temp[Global.loopCounter2] = 4;
						Global.roomType[Global.loopCounter1] = Global.temp;
					End;
					Wait(0.016, Ignore Condition);
				End;
			End;
		Else If(Global.randomRoll == 1);
			Small Message(All Players(All Teams), Custom String("luck reduced"));
			Global.teamGoldSacrificed /= 4;
			Global.teamLuck = (Global.teamGoldSacrificed / 5000) ^ 0.500;
		Else If(Global.randomRoll == 2);
			Small Message(All Players(All Teams), Custom String("lost all gold"));
			Global.teamGold = 0;
		Else If(Global.randomRoll == 3);
			Small Message(All Players(All Teams), Custom String("hall chances reduced"));
			Global.deathsThisFloor += 1;
			Global.specialHallCooldown += 1;
			Call Subroutine(EvaluateHallChance);
		Else If(Global.randomRoll == 4);
			Small Message(All Players(All Teams), Custom String("curse applied"));
			Global.activeCurse = Random Integer(0, 4) + 2;
		Else If(Global.randomRoll == 5);
			Small Message(All Players(All Teams), Custom String("yae miko scratched you"));
			All Players(Team 1).deathInjury += 5;
		End;
	}
}

rule("prepare to get yae-yaed")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Global.isEventActive == True;
		Global.eventType == 3;
	}

	actions
	{
		Wait(3, Ignore Condition);
		Big Message(All Players(All Teams), Custom String("{0} petals of sakura bloom in the air...", Hero Icon String(Hero(Kiriko))));
		Wait(3, Ignore Condition);
		Play Effect(All Players(All Teams), Moira Fade Disappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Moira Fade Reappear Sound, Color(Violet), Vector(0, 0, 0), 200);
		Play Effect(All Players(All Teams), Orisa Halt Implosion Sound, Color(Violet), Vector(0, 0, 0), 200);
		Create Dummy Bot(Hero(Kiriko), Team 1, 5, Vector(0, 0, 0), Vector(0, 0, 0));
		Global.alexBot = Last Created Entity;
		Start Forcing Dummy Bot Name(Global.alexBot, Custom String("Yae Miko"));
		Set Status(Global.alexBot, Null, Phased Out, 9999);
		Wait(2, Ignore Condition);
		Communicate(Global.alexBot, Hello);
		Wait(3, Ignore Condition);
		If(Is True For Any(All Players(Team 1), Custom String("{0}", Current Array Element) == Custom String("AlexHouk")));
			Small Message(All Players(All Teams), Custom String("yae miko: daring today, aren't we?"));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("want your today's fortune?"));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("give me one moment."));
		Else;
			Small Message(All Players(All Teams), Custom String("yae miko: fancy seeing you here."));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("let's hope you'll be having a great time."));
			Wait(3, Abort When False);
			Small Message(All Players(All Teams), Custom String("shall we see what the sacred sakura brings to you today?"));
		End;
		Wait(5, Ignore Condition);
		Global.temp = Random Integer(0, 5);
		Big Message(All Players(All Teams), Array(Custom String("big misfortune"), Custom String("misfortune"), Custom String(
			"future fortune"), Custom String("rising fortune"), Custom String("fortune"), Custom String("great fortune of all world"))
			[Global.temp]);
		Wait(3, Ignore Condition);
		If(Global.temp == 0);
			Small Message(All Players(All Teams), Custom String("have fun."));
			For Global Variable(loopCounter3, 0, 4, 1);
				Call Subroutine(BadFortunes);
				Wait(1, Ignore Condition);
			End;
		Else If(Global.temp == 1);
			Small Message(All Players(All Teams), Custom String("aw, what a shame... a bad one."));
			Call Subroutine(BadFortunes);
		Else If(Global.temp == 2);
			Small Message(All Players(All Teams), Custom String("though your life is momentary, you have to wait sometimes."));
			Global.futureFortune = True;
		Else If(Global.temp == 3);
			Small Message(All Players(All Teams), Custom String("sometimes peace is the best option."));
			Call Subroutine(GoodFortunes);
		Else If(Global.temp == 4);
			Small Message(All Players(All Teams), Custom String("seems that your future is bright."));
			For Global Variable(loopCounter3, 0, 3, 1);
				Call Subroutine(GoodFortunes);
				Wait(1, Ignore Condition);
			End;
		Else If(Global.temp == 5);
			Small Message(All Players(All Teams), Custom String("don't miss the opporunity, enjoy your run to the fullest!"));
			For Global Variable(loopCounter3, 0, 7, 1);
				Call Subroutine(GoodFortunes);
				Wait(1, Ignore Condition);
			End;
		End;
		Wait(3, Ignore Condition);
		Small Message(All Players(All Teams), Custom String("anyway, i'll leave you for now, toodles"));
		Wait(3, Ignore Condition);
		Destroy Dummy Bot(Team 1, 5);
		Global.temp = Global.roomType[Global.roomPositionX];
		Global.temp[Global.roomPositionY] = Global.currentRoom == 5 ? 8 : 0;
		Global.roomType[Global.roomPositionX] = Global.temp;
		Global.battleInProgress = False;
		Small Message(All Players(All Teams), Custom String("room cleared"));
		Global.currentRoom = Global.currentRoom == 5 ? 8 : 0;
		Respawn(All Players(Team 1));
		Teleport(All Players(Team 1), Vector(12, 0, 0));
		Stop Chasing Player Variable(All Players(Team 1), ultimateAmount);
		Global.isEventActive = False;
		Global.eventOccured = True;
	}
}

rule("haha bastion goes brrrrrr")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Bastion;
	}

	conditions
	{
		Ability Cooldown(Event Player, Button(Ability 1)) > 1;
	}

	actions
	{
		Wait(0.200, Ignore Condition);
		Set Ability Cooldown(Event Player, Button(Ability 1), 1);
	}
}

rule("splash damage")
{
	event
	{
		Player Dealt Damage;
		Team 1;
		Sojourn;
	}

	conditions
	{
		Event Ability == Button(Secondary Fire);
	}

	actions
	{
		Play Effect(All Players(All Teams), Bad Explosion, Color(Red), Position Of(Victim), 12);
		Damage(Players Within Radius(Victim, Event Was Critical Hit ? 12 : 6, Team 2, Off), Event Player, Event Damage * (
			Event Was Critical Hit ? 0.800 : 0.400));
	}
}

rule("heal on kills")
{
	event
	{
		Player Earned Elimination;
		Team 1;
		Junker Queen;
	}

	actions
	{
		If(Normalized Health(Event Player) < 1);
			Heal(Event Player, Null, Max Health(Event Player) * 0.200);
		Else;
			Add Health Pool To Player(Event Player, Health, Max Health(Event Player) * 0.100, False, False);
	}
}

rule("item displays")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Melee)) == True;
		Global.currentRoom != 7;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Event Player.itemDisplays = !Event Player.itemDisplays;
	}
}

rule("when the h happens")
{
	event
	{
		Ongoing - Global;
	}

	conditions
	{
		Server Load >= 255;
	}

	actions
	{
		Wait(0.500, Abort When False);
		Set Slow Motion(20);
		Wait Until(Server Load < 255, 99999);
		Set Slow Motion(100);
	}
}

rule("projs")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Lifeweaver;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Global.eventTimer > 0;
	}

	actions
	{
		Create Projectile(Mercy Caduceus Blaster, Event Player, Eye Position(Event Player), Facing Direction Of(Event Player) + Vector(
			Random Real(-0.010, 0.010), Random Real(-0.010, 0.010), Random Real(-0.010, 0.010)), To World, Damage, Team 2, 20, 3, 0,
			Bad Explosion, Explosion Sound, 0, 50, 3, 4, 1, 0);
		Wait(Random Real(0.100, 0.250), Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("SpawnSoul")
{
	event
	{
		Subroutine;
		SpawnSoul;
	}

	actions
	{
		Global.newItemPos = Global.param2;
		Global.itemExtraEffect = -1;
		Modify Global Variable(itemPositions, Append To Array, Global.param2);
		Modify Global Variable(itemSlots, Append To Array, 5);
		Modify Global Variable(itemSubtypes, Append To Array, 12 + Global.param1);
		Global.newItemName = Array(Custom String("Soul of Petra"), Custom String("Soul of Diablo"), Custom String("Soul of Mithrix"))
			[Global.param1];
		Modify Global Variable(itemRarities, Append To Array, 1);
		Modify Global Variable(itemProperties, Append To Array, Empty Array);
		Modify Global Variable(itemPropertyValue, Append To Array, Empty Array);
		Modify Global Variable(itemUnique, Append To Array, 0);
		Modify Global Variable(itemPowers, Append To Array, 0);
		Modify Global Variable(itemNames, Append To Array, Global.newItemName);
		Create Effect(All Players(All Teams), Orb, Color(Violet), Evaluate Once(Global.newItemPos), 1, Visible To Position and Radius);
		Modify Global Variable(itemEffects, Append To Array, Last Created Entity);
		Create In-World Text(All Players(All Teams), Global.itemNames[Evaluate Once(Count Of(Global.itemNames) - 1)], Evaluate Once(
			Global.newItemPos), 1, Clip Against Surfaces, Visible To Position and String, Color(Violet), Default Visibility);
		Modify Global Variable(itemTexts, Append To Array, Last Text ID);
		Modify Global Variable(extraItemEffects, Append To Array, Global.itemExtraEffect);
		Global.uniqueItemSpawn = False;
		Global.isUniqueItem = False;
		Global.newItemRarity = 0;
	}
}

rule("unique weapons bonus projectiles")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[0] != 0;
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		If(Event Player.playerUniqueItems[0] == 1);
			Event Player.randomRoll = Random Integer(3, 5);
			For Player Variable(Event Player, loop4, 0, 1 + Event Player.randomRoll, 1);
				Create Projectile(Mercy Caduceus Blaster, Event Player, Null, Direction From Angles(Horizontal Facing Angle Of(Event Player)
					+ Random Real(-5, 5), Vertical Facing Angle Of(Event Player) + Random Real(-5, 5)), To World, Damage, Team 2, 12, 2, 0,
					Bad Explosion, Explosion Sound, 0, 40, 5, 0, 0, 0);
				Wait(0.016, Ignore Condition);
			End;
			Wait(0.600, Ignore Condition);
		Else If(Event Player.playerUniqueItems[0] == 2);
			Create Projectile(Mei Icicle, Event Player, Null, Null, To World, Damage, Team 2, 40, 4, 0, Bad Explosion, Explosion Sound, 0, 60,
				5, 0, 0, 0);
			Wait(0.600, Ignore Condition);
		Else If(Event Player.playerUniqueItems[0] == 3);
			Create Beam Effect(All Players(All Teams), Winston Tesla Cannon Beam, Eye Position(Event Player), Eye Position(Event Player)
				+ Facing Direction Of(Event Player) * 70, Team 1, None);
			Event Player.abilityEffects = Last Created Entity;
			Damage(Ray Cast Hit Player(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(Event Player) * 70,
				All Players(Team 2), Event Player, False), Event Player, 90);
			Wait(0.200, Ignore Condition);
			Destroy Effect(Event Player.abilityEffects);
			Wait(0.400, Ignore Condition);
		Else If(Event Player.playerUniqueItems[0] == 4);
			Create Homing Projectile(Ramattra Ravenous Vortex Sphere, Event Player, Null, Null, To World, Damage, Team 2, 45, 1, 0,
				Bad Explosion, Explosion Sound, 0.050, 16, 10, 0, Player Closest To Reticle(Event Player, Team 2), 1);
			Wait(0.600, Ignore Condition);
		Else If(Event Player.playerUniqueItems[0] == 5);
			Create Projectile(Pharah Rocket, Event Player, Null, Null, To World, Damage, Team 2, 30, 0.500, 1.250,
				Bastion Tank Cannon Explosion Effect, Bastion Tank Cannon Explosion Sound, 0, 30, 5, 15, 3, 15);
			Wait(0.600, Ignore Condition);
		End;
		Loop If Condition Is True;
	}
}

rule("no self heal")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Hero Of(Event Player) == Hero(Lifeweaver);
	}

	actions
	{
		Start Healing Modification(Event Player, Event Player, 0, Receivers Healers and Healing Percent);
		Event Player.heroDamageMod = Last Healing Modification ID;
		Wait Until(Hero Of(Event Player) != Hero(Lifeweaver), 99999);
		Stop Healing Modification(Event Player.heroDamageMod);
	}
}

rule("orbius")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[0] == 6;
		Count Of(Event Player.orbEffects) == 0;
	}

	actions
	{
		For Player Variable(Event Player, loop3, 0, 3, 1);
			Create Effect(All Players(All Teams), Sphere, Color(Yellow), Update Every Frame(Eye Position(Event Player) + Direction From Angles(
				Horizontal Facing Angle Of(Event Player) + Evaluate Once(-45 + Event Player.loop3 * 45), 0) * -2), 0.150,
				Visible To Position and Radius);
			Modify Player Variable(Event Player, orbEffects, Append To Array, Last Created Entity);
		End;
		Wait Until(Event Player.playerUniqueItems[0] != 6, 99999);
		For Player Variable(Event Player, loop3, 0, 3, 1);
			Destroy Effect(Event Player.orbEffects[Event Player.loop3]);
		End;
		Event Player.orbEffects = Empty Array;
		Wait(1, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("orbz")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.playerUniqueItems[0] == 6;
		Global.battleInProgress == True;
		Number Of Living Players(Team 2) > 0;
	}

	actions
	{
		Wait(Random Real(0.300, 0.600), Ignore Condition);
		Event Player.randomRoll = Random Real(0, 1);
		For Player Variable(Event Player, loop3, 0, 3, 1);
			If(Event Player.randomRoll <= 0.500 ^ Event Player.loop3);
				Event Player.abilityTarget = Random Value In Array(All Living Players(Team 2));
				Create Homing Projectile(Baptiste Biotic Launcher, Event Player, Eye Position(Event Player) + Direction From Angles(
					Horizontal Facing Angle Of(Event Player) + -45 + Event Player.loop3 * 45, 0) * -2, Null, To World, Damage, Team 2, 10, 2, 0,
					Bad Explosion, Explosion Sound, 0, 45, 5, 0, Event Player.abilityTarget, 1);
			End;
		End;
		Loop If Condition Is True;
	}
}

rule("tracer iframes")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Tracer;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Status(Event Player, Null, Invincible, 0.225);
	}
}

rule("furrah")
{
	event
	{
		Player Dealt Knockback;
		Team 1;
		Pharah;
	}

	conditions
	{
		Event Ability == Button(Ability 2);
		Victim != Event Player;
	}

	actions
	{
		Set Status(Victim, Event Player, Knocked Down, 1);
	}
}

rule("restart keybind")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
		Event Player == Host Player;
	}

	actions
	{
		Restart Match;
	}
}

rule("bap")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		Baptiste;
	}

	conditions
	{
		Is Using Ability 2(Event Player) == True;
	}

	actions
	{
		Set Status(All Players(Team 1), Event Player, Unkillable, 5);
	}
}

rule("Ramat Smart AB1")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ramattra;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Button Held(Event Player, Button(Ability 1)) == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Ability 1));
		Wait(8, Ignore Condition);
		Abort If(Is Using Ultimate(Event Player) == True);
		Allow Button(Event Player, Button(Ability 1));
	}
}

rule("Ramat Smart ULT")
{
	event
	{
		Ongoing - Each Player;
		All;
		Ramattra;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Is Button Held(Event Player, Button(Ultimate)) == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Ability 1));
		Wait Until(Is Using Ultimate(Event Player) == False, 99999);
		Allow Button(Event Player, Button(Ability 1));
	}
}

rule("Furry Smart Attack")
{
	event
	{
		Ongoing - Each Player;
		All;
		Kiriko;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Primary Fire));
	}
}

rule("Schizo Smart Attack")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Secondary Fire));
	}
}

rule("Lucio \"Lets break your spine\"")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Hero Of(Event Player) == Hero(Lúcio);
	}

	actions
	{
		If(Array Contains(All Tank Heroes, Hero Of(Closest Player To(Event Player, Team 2))));
			Wait(0.250, Ignore Condition);
			Wait Until(Is Standing(Event Player) == True, 99999);
			Abort If(Distance Between(Event Player, Eye Position(Closest Player To(Event Player, Team 2))) > 1.750);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
		Else;
			Wait(0.250, Ignore Condition);
			Wait Until(Is Standing(Event Player) == True, 99999);
			Abort If(Distance Between(Event Player, Eye Position(Closest Player To(Event Player, Team 2))) > 1.500);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
			Damage(Closest Player To(Event Player, Team 2), Event Player, 100000);
	}
}

disabled rule("set eye pos")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("AurƗx");
	}

	actions
	{
		Event Player.zero = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 10, All Players(All Teams), Event Player, True);
		Wait(0.016, Ignore Condition);
		Loop;
		Event Player.zero = Null;
	}
}

rule("aurix")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("AurƗx");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"A cryptic symbol shimmers into existence, its true meaning known only to the one who wields it."));
		Create Effect(All Players(All Teams), Echo Cloning Effect, Color(Red), Event Player, 1, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Winston Primal Rage Effect, Color(White), Event Player, 1, Visible To Position and Radius);
		disabled Create Beam Effect(All Players(All Teams), Omnic Slicer Beam, Eye Position(Event Player), Event Player.zero, Color(White),
			Visible To Position and Radius);
		Play Effect(All Players(All Teams), Doomfist Meteor Strike Impact Effect, Color(White), Event Player, 1);
	}
}

rule("expert")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("ExpertWings");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"A gust of wind sweeps through the area, carrying with it the promise of unfettered flight."));
		Create Effect(All Players(All Teams), Reaper Wraith Form Effect, Color(Red), Event Player, 1, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Torbjörn Overloading Effect, Color(Red), Eye Position(Event Player), 1,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Soldier: 76 Sprinting Effect, Color(Red), Event Player, 20, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Lúcio Sound Barrier Protected Effect, Color(Team 2), Event Player, 1,
			Visible To Position and Radius);
		Play Effect(All Players(All Teams), Moira Fade Reappear Effect, Color(White), Event Player, 1);
	}
}

rule("chilli")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("chilli");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"A wave of heat engulfs the surroundings, causing nearby enemies to sweat and squirm."));
		Create Effect(All Players(All Teams), Ashe Dynamite Burning Material Effect, Color(Red), Event Player, 1,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Ashe Dynamite Burning Particle Effect, Color(Red), Event Player, 1,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Wrecking Ball Piledriver Fire Effect, Color(Team 1), Event Player, 1,
			Visible To Position and Radius);
		Play Effect(All Players(All Teams), Ashe Dynamite Explosion Effect, Color(White), Event Player, 1);
	}
}

rule("Clammy")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("ClammyMilk");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"A strange aura of unease permeates the air, as if something is... not quite right."));
		disabled Create Effect(All Players(All Teams), Sigma Gravitic Flux Target Effect, Color(White), Event Player, 1,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Cloud, Color(Black), Event Player, 5, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Reaper Wraith Form Effect, Color(Black), Event Player, 10, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Ana Sleeping Effect, Color(Team 1), Event Player, 1, Visible To Position and Radius);
		Play Effect(All Players(All Teams), Widowmaker Venom Mine Explosion Effect, Color(White), Event Player, 1);
	}
}

rule("nocap")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("NOCAP");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"A resounding voice echoes through the land, declaring truth and honesty above all else."));
		Create Effect(All Players(All Teams), Good Aura, Color(Yellow), Event Player, 1, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Sigma Gravitic Flux Target Effect, Color(Yellow), Event Player, 1.500,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Heal Target Effect, Color(White), Event Player, 10, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Sombra Hacked Looping Effect, Color(Team 1), Event Player, 1,
			Visible To Position and Radius);
		Play Effect(All Players(All Teams), Ana Biotic Grenade Explosion Effect, Color(White), Event Player, 1);
		Play Effect(All Players(All Teams), Baptiste Biotic Launcher Explosion Effect, Color(White), Event Player, 1);
		Play Effect(All Players(All Teams), Heal Target Active Effect, Color(White), Event Player, 1);
	}
}

rule("padthai")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("padthai");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"The tantalizing aroma of exotic spices fills the air, causing hunger pangs to strike."));
		Play Effect(All Players(All Teams), Lúcio Sound Barrier Cast Effect, Color(White), Event Player, 1);
		Create Effect(All Players(All Teams), Cassidy Flashbang Stunned Effect, Color(White), Event Player, 1,
			Visible To Position and Radius);
	}
}

rule("sylver")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("Sylver247");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String("A radiant glow emanates from the player, illuminating the path ahead."));
		Create Effect(All Players(All Teams), Baptiste Immortality Field Protected Effect, Color(Yellow), Event Player, 1,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Ana Biotic Grenade Increased Healing Effect, Color(White), Event Player, 1,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Heal Target Effect, Color(White), Event Player, 1, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Heal Target Active Effect, Color(White), Event Player, 1, Visible To Position and Radius);
		Play Effect(All Players(All Teams), Wrecking Ball Piledriver Impact Effect, Color(White), Event Player, 1);
	}
}

rule("kalmaroo")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("Kalmaroo");
	}

	actions
	{
		Wait(1, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"A mischievous grin spreads across the player's face, hinting at untold secrets."));
		Create Effect(All Players(All Teams), Soldier: 76 Sprinting Effect, Color(Red), Event Player, 50, Visible To Position and Radius);
		Create Effect(All Players(All Teams), Wrecking Ball Adaptive Shield Target Effect, Color(Team 1), Event Player, 1,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Soldier: 76 Sprinting Effect, Color(Team 1), Event Player, 1.500,
			Visible To Position and Radius);
		Create Effect(All Players(All Teams), Mercy Damage Boosted Effect, Color(Team 2), Event Player, 0.500,
			Visible To Position and Radius);
		Play Effect(All Players(All Teams), Sombra Logo Effect, Color(White), Event Player, 1);
		Play Effect(All Players(All Teams), DVa Self Destruct Explosion Effect, Color(White), Event Player, 1);
		Play Effect(All Players(All Teams), Sombra EMP Explosion Sound, Color(White), Event Player, 1);
	}
}

rule("kopek")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("KopekIsHigh");
	}

	actions
	{
		Wait(0.250, Ignore Condition);
		Big Message(All Players(All Teams), Custom String(
			"From the frozen wastes, Kopek emerges, their presence heralded by a chill wind."));
		Create Effect(All Players(All Teams), Mei Frozen Effect, Color(Blue), Event Player, 1, Visible To Position and Radius);
		Play Effect(All Players(All Teams), Hanzo Sonic Arrow Initial Pulse Effect, Color(White), Event Player, 1);
		Play Effect(All Players(All Teams), Hanzo Sonic Arrow Initial Pulse Effect, Color(White), Event Player, 1);
		Play Effect(All Players(All Teams), Buff Impact Sound, Color(White), Event Player, 1);
	}
}

disabled rule("padthai pos")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("padthai");
	}

	actions
	{
		Wait(0.167, Ignore Condition);
		Event Player.padthaiX = Position Of(Event Player);
		Loop;
	}
}

disabled rule("padthai sparks")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Game In Progress == True;
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("padthai");
	}

	actions
	{
		Event Player.sparksNum = 20;
		Loop If(Event Player.sparksNum == 0);
		Create Effect(All Players(All Teams), Sparkles, Color(White), Event Player.padthaiX, 0.500, Position and Radius);
		Event Player.sparksNum = Event Player.sparksNum - 1;
		disabled Wait(0.100, Ignore Condition);
	}
}

rule("Is that the devil?")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Melee)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Dummy Bot(Event Player) != True;
		Event Player.transformationEffect == False;
	}

	actions
	{
		Big Message(All Players(All Teams), Custom String("A presence of extreme evil emerges..."));
		Event Player.itemRarity = Array(6, 0, 0, 0, 0);
		Event Player.playerUniqueItems = Array(0, 0, 0, 0, 0);
		Event Player.weaponPower = 0;
		Event Player.bodyPower = 0;
		Event Player.headPower = 0;
		Event Player.legsPower = 0;
		Event Player.specialPower = 0;
		Event Player.specialGemstoneType = 0;
		Event Player.weaponProperties = Array(Empty Array, Empty Array);
		Event Player.bodyProperties = Array(Empty Array, Empty Array);
		Event Player.headProperties = Array(Empty Array, Empty Array);
		Event Player.legsProperties = Array(Empty Array, Empty Array);
		Event Player.specialProperties = Array(Empty Array, Empty Array);
		Global.savePowers[Slot Of(Event Player)] = Empty Array;
		Global.saveItemNames[Slot Of(Event Player)] = 0;
		Global.saveWeaponProperties[Slot Of(Event Player)] = 0;
		Global.saveBodyProperties[Slot Of(Event Player)] = 0;
		Global.saveHeadProperties[Slot Of(Event Player)] = 0;
		Global.saveLegsProperties[Slot Of(Event Player)] = 0;
		Global.saveSpecialProperties[Slot Of(Event Player)] = 0;
		Global.saveItemRarity[Slot Of(Event Player)] = Array(6, 0, 0, 0, 0);
		Global.saveUniqueItems[Slot Of(Event Player)] = Array(0, 0, 0, 0, 0);
		Global.saveSpecialGemstoneType[Slot Of(Event Player)] = 0;
		Event Player.weaponPower = 690;
		Event Player.itemNames = Array(Custom String("+??? Killer Instinct"), Custom String("none"), Custom String("none"), Custom String(
			"none"), Custom String("none"));
		Start Scaling Player(Event Player, 3, True);
		Start Scaling Barriers(Event Player, 3, True);
		Start Modifying Hero Voice Lines(Event Player, 0.500, True);
		Event Player.statMoveSpeed = 300;
		Event Player.Scale = 300;
		Disallow Button(Event Player, Button(Ability 1));
		Disallow Button(Event Player, Button(Ability 2));
		Chase Player Variable At Rate(Event Player, playerRage, 100, Global.battleInProgress ? 2 : 0, Destination and Rate);
		Event Player.playerRole = 1;
		Disallow Button(Event Player, Button(Ultimate));
		Start Forcing Player To Be Hero(Event Player, Hero(Reaper));
		Event Player.ChoseToBeDevil = True;
	}
}

rule("Animated Primary")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Ammo(Event Player, 0) == 4;
		Event Player.ChoseToBeDevil == True;
	}

	actions
	{
		Disallow Button(Event Player, Button(Primary Fire));
		Wait(0.490, Ignore Condition);
		Set Ultimate Charge(Event Player, 100);
		Allow Button(Event Player, Button(Ultimate));
		Wait(0.016, Ignore Condition);
		Press Button(Event Player, Button(Ultimate));
		Set Ammo(Event Player, 0, 8);
		Wait(0.016, Ignore Condition);
		Disallow Button(Event Player, Button(Ultimate));
		Allow Button(Event Player, Button(Primary Fire));
	}
}

rule("Animated Secondary")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Secondary Fire)) == True;
		Event Player.isDowned == False;
		Event Player.ChoseToBeDevil == True;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Create Projectile(Ramattra Ravenous Vortex Sphere, Event Player, Null, Null, To World, Damage, Team 2, 50, 1, 10,
			Widowmaker Venom Mine Explosion Effect, Sigma Hypersphere Implosion Sound, 0.125, 100, 100, 5, 20, 25);
		Wait(0.250, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("Animated Ability 1")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 1)) == True;
		Ability Cooldown(Event Player, Button(Ability 1)) == 0;
		Event Player.isDowned == False;
		Has Status(Event Player, Rooted) == False;
		Event Player.ChoseToBeDevil == True;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Set Invisible(Event Player, All);
		Play Effect(All Players(All Teams), Moira Fade Disappear Sound, Color(Team 1), Position Of(Event Player), 200);
		Play Effect(All Players(All Teams), Moira Fade Disappear Effect, Color(Team 1), Eye Position(Event Player) / Vector(1, 2, 1), 50);
		Wait(0.250, Ignore Condition);
		Set Invisible(Event Player, None);
		Play Effect(All Players(All Teams), Moira Fade Reappear Sound, Color(Team 1), Position Of(Event Player), 200);
		Play Effect(All Players(All Teams), Moira Fade Reappear Effect, Color(Team 1), Eye Position(Event Player) / Vector(1, 2, 1), 50);
		Teleport(Event Player, Nearest Walkable Position(Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ Facing Direction Of(Event Player) * 100, All Players(All Teams), Event Player, True)));
		Event Player.abilityTarget = Players Within Radius(Event Player, 5, Team 2, Off);
		For Player Variable(Event Player, loopCounter, 0, Count Of(Event Player.abilityTarget), 1);
			Apply Impulse(Event Player.abilityTarget[Event Player.loopCounter], Direction Towards(Event Player,
				Event Player.abilityTarget[Event Player.loopCounter]) + Vector(0, 0.100, 0), 25, To World, Cancel Contrary Motion);
			Damage(Event Player.abilityTarget[Event Player.loopCounter], Event Player, 50);
			Wait(0.016, Ignore Condition);
		End;
		Set Ability Cooldown(Event Player, Button(Ability 1), 7);
	}
}

rule("Animated Ability 2")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ability 2)) == True;
		Ability Cooldown(Event Player, Button(Ability 2)) == 0;
		Event Player.isDowned == False;
		Event Player.usingAbility1 == False;
		Event Player.ChoseToBeDevil == True;
	}

	actions
	{
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Set Status(Event Player, Null, Rooted, 2.600);
		Wait(0.600, Ignore Condition);
		For Player Variable(Event Player, loopCounter, 0, 20, 1);
			Play Effect(All Players(All Teams), Moira Fade Reappear Effect, Color(Team 1), Eye Position(Event Player) + Direction From Angles(
				Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player) + Random Real(-15, 15))
				* Random Real(2, 15), 0.600);
			Play Effect(All Players(All Teams), Sigma Hypersphere Implosion Effect, Color(Team 2), Eye Position(Event Player)
				+ Direction From Angles(Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player)
				+ Random Real(-15, 15)) * Random Real(2, 15), 0.600);
			Play Effect(All Players(All Teams), Moira Fade Reappear Effect, Color(Team 2), Eye Position(Event Player) + Direction From Angles(
				Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player) + Random Real(-15, 15))
				* Random Real(2, 15), 0.600);
			Play Effect(All Players(All Teams), Sigma Hypersphere Implosion Effect, Color(Team 1), Eye Position(Event Player)
				+ Direction From Angles(Horizontal Facing Angle Of(Event Player) + Random Real(-15, 15), Vertical Facing Angle Of(Event Player)
				+ Random Real(-15, 15)) * Random Real(2, 15), 0.600);
			Damage(Filtered Array(Players in View Angle(Event Player, Team 2, 40), Distance Between(Current Array Element, Event Player)
				<= 15), Event Player, 50);
			Wait(0.100, Ignore Condition);
		End;
		Clear Status(Event Player, Rooted);
		Set Ability Cooldown(Event Player, Button(Ability 2), 13);
	}
}

rule("Animated Ult")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Ultimate)) == True;
		Event Player.playerRage >= 100;
		Event Player.isDowned == False;
		Event Player.ChoseToBeDevil == True;
	}

	actions
	{
		Wait(0.250, Abort When False);
		Event Player.randomRoll = Random Real(0, 100);
		Event Player.isCritical = Event Player.randomRoll <= Event Player.statCriticalChance;
		Big Message(All Players(All Teams), Custom String("{0} souls of the damned, claim these mortal vessels!", Hero Icon String(Hero Of(
			Event Player))));
		Event Player.AnimatedUlt = True;
	}
}

rule("Animated Ult Damage")
{
	event
	{
		Ongoing - Each Player;
		Team 1;
		All;
	}

	conditions
	{
		Event Player.isDowned == False;
		Event Player.PlayerName == Custom String("AnimatedNerd");
		Global.battleInProgress == True;
		Event Player.AnimatedUlt == True;
		Event Player.ChoseToBeDevil == True;
	}

	actions
	{
		Create Homing Projectile(Sigma Hypersphere, Event Player, Null, Null, To World, Damage, Team 2, 500, 1, 10,
			Moira Fade Disappear Effect, Doomfist Meteor Strike Impact Sound, 0, 37.500, 100, 10, Random Value In Array(All Living Players(
			Team 2)), 1);
		Wait Until(Number Of Living Players(Team 2) > 0, 99999);
		Wait(0.250, Ignore Condition);
		Event Player.playerRage = 50;
		Loop If Condition Is True;
		Event Player.AnimatedUlt = False;
		Event Player.playerRage = 0;
	}
}

disabled rule("set eye pos")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Event Player.PlayerName == Custom String("AurƗx");
	}

	actions
	{
		Event Player.zero = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player) + Facing Direction Of(
			Event Player) * 2, All Players(All Teams), Event Player, True);
		Wait(0.016, Ignore Condition);
		Loop;
		Event Player.zero = Null;
	}
}
